From e3635e8ad2ad4b74d9213b5ace963c87a19d560d Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Tue, 5 Nov 2019 18:34:02 +0100
Subject: [PATCH 01/51] panel-simple: Add support for BOE NV140FHM-N49 Full HD
 eDP panel

This panel is used in the Pinebook Pro.

Signed-off-by: Tobias Schramm <tobias@t-sys.eu>
---
 drivers/gpu/drm/panel/panel-simple.c | 34 ++++++++++++++++++++++++++++
 1 file changed, 34 insertions(+)

diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index 28fa6ba7b767..cce539b99c35 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -1033,6 +1033,36 @@ static const struct panel_desc boe_nv101wxmn51 = {
 	},
 };
 
+static const struct drm_display_mode boe_nv140fhmn49_modes[] = {
+	{
+		.clock = 150000,
+		.hdisplay = 1920,
+		.hsync_start = 1920 + 48,
+		.hsync_end = 1920 + 48 + 32,
+		.htotal = 1920 + 48 + 32 + 80,
+		.vdisplay = 1080,
+		.vsync_start = 1080 + 3,
+		.vsync_end = 1080 + 3 + 5,
+		.vtotal = 1080 + 3 + 5 + 24,
+		.vrefresh = 60,
+	},
+};
+
+static const struct panel_desc boe_nv140fhmn49 = {
+	.modes = boe_nv140fhmn49_modes,
+	.num_modes = ARRAY_SIZE(boe_nv140fhmn49_modes),
+	.bpc = 8,
+	.size = {
+		.width = 309,
+		.height = 174,
+	},
+	.delay = {
+		.prepare = 210,
+		.enable = 50,
+		.unprepare = 160,
+	},
+};
+
 static const struct drm_display_mode cdtech_s043wq26h_ct7_mode = {
 	.clock = 9000,
 	.hdisplay = 480,
@@ -3138,6 +3168,9 @@ static const struct of_device_id platform_of_match[] = {
 	}, {
 		.compatible = "boe,nv101wxmn51",
 		.data = &boe_nv101wxmn51,
+	}, {
+		.compatible = "boe,nv140fhmn49",
+		.data = &boe_nv140fhmn49,
 	}, {
 		.compatible = "cdtech,s043wq26h-ct7",
 		.data = &cdtech_s043wq26h_ct7,
@@ -3430,6 +3463,7 @@ static struct platform_driver panel_simple_platform_driver = {
 	.driver = {
 		.name = "panel-simple",
 		.of_match_table = platform_of_match,
+		.probe_type = PROBE_PREFER_ASYNCHRONOUS,
 	},
 	.probe = panel_simple_platform_probe,
 	.remove = panel_simple_platform_remove,
-- 
2.23.0

From 3921fd00e0829c98e8c8b2ce34cbe3b9740b7c9a Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Tue, 5 Nov 2019 18:38:32 +0100
Subject: [PATCH 02/51] cw2015: Add support for the CellWise cw2015 fuel gauge

The cw2015 is a shuntless single cell lithium battery fuel gauage.

Signed-off-by: Tobias Schramm <tobias@t-sys.eu>
---
 drivers/power/supply/Kconfig          |   7 +
 drivers/power/supply/Makefile         |   1 +
 drivers/power/supply/cw2015_battery.c | 949 ++++++++++++++++++++++++++
 include/linux/power/cw2015_battery.h  | 122 ++++
 4 files changed, 1079 insertions(+)
 create mode 100644 drivers/power/supply/cw2015_battery.c
 create mode 100644 include/linux/power/cw2015_battery.h

diff --git a/drivers/power/supply/Kconfig b/drivers/power/supply/Kconfig
index c84a7b1caeb6..e1f4504612a3 100644
--- a/drivers/power/supply/Kconfig
+++ b/drivers/power/supply/Kconfig
@@ -116,6 +116,13 @@ config BATTERY_CPCAP
 	  Say Y here to enable support for battery on Motorola
 	  phones and tablets such as droid 4.
 
+config BATTERY_CW2015
+	bool "CW2015 Battery driver"
+	default n
+	help
+	  If you say yes here you will get support for the battery of CW2015.
+	  This driver can give support for CW2015 Battery Interface.
+
 config BATTERY_DS2760
 	tristate "DS2760 battery driver (HP iPAQ & others)"
 	depends on W1
diff --git a/drivers/power/supply/Makefile b/drivers/power/supply/Makefile
index 6c7da920ea83..69727a10e835 100644
--- a/drivers/power/supply/Makefile
+++ b/drivers/power/supply/Makefile
@@ -24,6 +24,7 @@ obj-$(CONFIG_BATTERY_ACT8945A)	+= act8945a_charger.o
 obj-$(CONFIG_BATTERY_AXP20X)	+= axp20x_battery.o
 obj-$(CONFIG_CHARGER_AXP20X)	+= axp20x_ac_power.o
 obj-$(CONFIG_BATTERY_CPCAP)	+= cpcap-battery.o
+obj-$(CONFIG_BATTERY_CW2015)	+= cw2015_battery.o
 obj-$(CONFIG_BATTERY_DS2760)	+= ds2760_battery.o
 obj-$(CONFIG_BATTERY_DS2780)	+= ds2780_battery.o
 obj-$(CONFIG_BATTERY_DS2781)	+= ds2781_battery.o
diff --git a/drivers/power/supply/cw2015_battery.c b/drivers/power/supply/cw2015_battery.c
new file mode 100644
index 000000000000..4da65c606338
--- /dev/null
+++ b/drivers/power/supply/cw2015_battery.c
@@ -0,0 +1,949 @@
+/*
+ * Fuel gauge driver for CellWise 2013 / 2015
+ *
+ * Copyright (C) 2012, RockChip
+ * Copyright (C) 2019, Tobias Schramm
+ *
+ * Authors: xuhuicong <xhc@rock-chips.com>
+ * Authors: Tobias Schramm <tobias@t-sys.eu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+
+#include <linux/power/cw2015_battery.h>
+
+static int dbg_enable;
+module_param_named(dbg_level, dbg_enable, int, 0644);
+
+#define cw_printk(args...) \
+	do { \
+		if (dbg_enable) { \
+			pr_info(args); \
+		} \
+	} while (0)
+
+static int cw_read(struct i2c_client *client, u8 reg, u8 buf[])
+{
+	return i2c_smbus_read_i2c_block_data(client, reg, 1, buf);
+}
+
+static int cw_write(struct i2c_client *client, u8 reg, u8 const buf[])
+{
+	return i2c_smbus_write_i2c_block_data(client, reg, 1, &buf[0]);
+}
+
+static int cw_read_word(struct i2c_client *client, u8 reg, u8 buf[])
+{
+	return i2c_smbus_read_i2c_block_data(client, reg, 2, buf);
+}
+
+int cw_update_config_info(struct cw_battery *cw_bat)
+{
+	int ret;
+	u8 reg_val;
+	u8 i;
+	u8 reset_val;
+
+	cw_printk("[FGADC] test config_info = 0x%x\n",
+		  cw_bat->plat_data.cw_bat_config_info[0]);
+
+	/* make sure no in sleep mode */
+	ret = cw_read(cw_bat->client, CW2015_REG_MODE, &reg_val);
+	if (ret < 0)
+		return ret;
+
+	reset_val = reg_val;
+	if ((reg_val & CW2015_MODE_SLEEP_MASK) == CW2015_MODE_SLEEP) {
+		dev_err(&cw_bat->client->dev,
+			"device in sleep mode, cannot update battery info\n");
+		return -1;
+	}
+
+	/* update new battery info */
+	for (i = 0; i < CW2015_SIZE_BATINFO; i++) {
+		ret =
+		    cw_write(cw_bat->client, CW2015_REG_BATINFO + i,
+			     (u8 *)&cw_bat->plat_data.cw_bat_config_info[i]);
+
+		if (ret < 0)
+			return ret;
+	}
+
+	reg_val |= CW2015_CONFIG_UPDATE_FLG;	/* set UPDATE_FLAG */
+	reg_val &= ~CW2015_MASK_ATHD;	/* clear ATHD */
+	reg_val |= CW2015_ATHD;	/* set CW2015_ATHD */
+	ret = cw_write(cw_bat->client, CW2015_REG_CONFIG, &reg_val);
+	if (ret < 0)
+		return ret;
+
+	/* check 2015/cw2013 for CW2015_ATHD & update_flag */
+	ret = cw_read(cw_bat->client, CW2015_REG_CONFIG, &reg_val);
+	if (ret < 0)
+		return ret;
+
+	if (!(reg_val & CW2015_CONFIG_UPDATE_FLG)) {
+		dev_info(&cw_bat->client->dev,
+			 "update flag for new battery info have not set..\n");
+	}
+
+	if ((reg_val & CW2015_MASK_ATHD) != CW2015_ATHD)
+		dev_info(&cw_bat->client->dev, "the new CW2015_ATHD have not set..\n");
+
+	/* reset */
+	reset_val &= ~(CW2015_MODE_RESTART);
+	reg_val = reset_val | CW2015_MODE_RESTART;
+	ret = cw_write(cw_bat->client, CW2015_REG_MODE, &reg_val);
+	if (ret < 0)
+		return ret;
+
+	msleep(10);
+	ret = cw_write(cw_bat->client, CW2015_REG_MODE, &reset_val);
+	if (ret < 0)
+		return ret;
+
+	cw_printk("cw2015 update config success!\n");
+
+	return 0;
+}
+
+static int cw_init(struct cw_battery *cw_bat)
+{
+	int ret;
+	int i;
+	u8 reg_val = CW2015_MODE_SLEEP;
+
+	if ((reg_val & CW2015_MODE_SLEEP_MASK) == CW2015_MODE_SLEEP) {
+		reg_val = CW2015_MODE_NORMAL;
+		ret = cw_write(cw_bat->client, CW2015_REG_MODE, &reg_val);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = cw_read(cw_bat->client, CW2015_REG_CONFIG, &reg_val);
+	if (ret < 0)
+		return ret;
+
+	if ((reg_val & CW2015_MASK_ATHD) != CW2015_ATHD) {
+		dev_info(&cw_bat->client->dev, "the new CW2015_ATHD have not set\n");
+		reg_val &= ~CW2015_MASK_ATHD;	/* clear CW2015_ATHD */
+		reg_val |= CW2015_ATHD;	/* set CW2015_ATHD */
+		ret = cw_write(cw_bat->client, CW2015_REG_CONFIG, &reg_val);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = cw_read(cw_bat->client, CW2015_REG_CONFIG, &reg_val);
+	if (ret < 0)
+		return ret;
+
+	if (!(reg_val & CW2015_CONFIG_UPDATE_FLG)) {
+		cw_printk("update config flg is true, need update config\n");
+		ret = cw_update_config_info(cw_bat);
+		if (ret < 0) {
+			dev_info(&cw_bat->client->dev,
+				 "update flag for new battery info have not set\n");
+			return ret;
+		}
+	} else {
+		for (i = 0; i < CW2015_SIZE_BATINFO; i++) {
+			ret = cw_read(cw_bat->client, (CW2015_REG_BATINFO + i),
+				      &reg_val);
+			if (ret < 0)
+				return ret;
+
+			if (cw_bat->plat_data.cw_bat_config_info[i] != reg_val)
+				break;
+		}
+
+		if (i != CW2015_SIZE_BATINFO) {
+			dev_info(&cw_bat->client->dev,
+				 "update flag for new battery info have not set\n");
+			ret = cw_update_config_info(cw_bat);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	for (i = 0; i < CW2015_READ_TRIES; i++) {
+		ret = cw_read(cw_bat->client, CW2015_REG_SOC, &reg_val);
+		if (ret < 0)
+			return ret;
+		else if (reg_val <= 100) // SOC can't be more than 100 %
+			break;
+		msleep(120);
+	}
+
+	if (i >= CW2015_READ_TRIES) {
+		reg_val = CW2015_MODE_SLEEP;
+		ret = cw_write(cw_bat->client, CW2015_REG_MODE, &reg_val);
+		dev_info(&cw_bat->client->dev, "report battery capacity error");
+		return -1;
+	}
+
+	cw_printk("cw2015 init success!\n");
+	return 0;
+}
+
+static int check_charger_online(struct device *dev, void *data) {
+	struct device *cw_dev = data;
+	struct power_supply *supply = dev_get_drvdata(dev);
+	union power_supply_propval val;
+
+	if (supply->desc->type == POWER_SUPPLY_TYPE_BATTERY) {
+		dev_dbg(cw_dev, "Skipping power supply %s since it is a battery\n", dev_name(dev));
+		return 0; // Bail out, not a charger
+	}
+	if(!supply->desc->get_property(supply, POWER_SUPPLY_PROP_ONLINE, &val)) {
+		return val.intval;
+	} else {
+		dev_dbg(cw_dev, "Skipping power supply %s since it does not have an online property\n", dev_name(dev));
+	}
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static int device_parent_match_of_node(struct device *dev, const void *np) {
+	while(dev) {
+		if(dev->of_node == np) {
+			return 1;
+		}
+		dev = dev->parent;
+	}
+	return 0;
+}
+#endif
+
+static int get_charge_state(struct cw_battery *cw_bat)
+{
+#ifdef CONFIG_OF
+	int i = 0, online = 0;
+	struct device_node* supply_of;
+	struct device *cw_dev = &cw_bat->client->dev;
+	if (!cw_dev->of_node) {
+		dev_info(cw_dev, "Charger does not have an of node, scanning all supplies\n");
+#endif
+		return !!class_for_each_device(power_supply_class, NULL, cw_dev, check_charger_online);
+#ifdef CONFIG_OF
+	}
+	do {
+		struct device *supply_dev;
+		dev_dbg(cw_dev, "Scanning linked supplies of %s\n", cw_dev->of_node->name);
+		supply_of = of_parse_phandle(cw_dev->of_node, "power-supplies", i++);
+		if (!supply_of) {
+			dev_dbg(cw_dev, "Got empty of node, scan done\n");
+			break;
+		}
+		dev_dbg(cw_dev, "Got power supply %s\n", supply_of->name);
+		supply_dev = class_find_device(power_supply_class, NULL, supply_of, device_parent_match_of_node);
+		if (supply_dev) {
+			online = check_charger_online(supply_dev, NULL);
+			dev_dbg(supply_dev, "Charger online: %d\n", online);
+			put_device(supply_dev);
+		} else {
+			dev_warn(cw_dev, "Failed to get device for device node %s\n", supply_of->name);
+		}
+		of_node_put(supply_of);
+	} while(!online);
+	return online;
+#endif
+}
+
+static int cw_por(struct cw_battery *cw_bat)
+{
+	int ret;
+	unsigned char reset_val;
+
+	reset_val = CW2015_MODE_SLEEP;
+	ret = cw_write(cw_bat->client, CW2015_REG_MODE, &reset_val);
+	if (ret < 0)
+		return ret;
+	reset_val = CW2015_MODE_NORMAL;
+	msleep(20);
+	ret = cw_write(cw_bat->client, CW2015_REG_MODE, &reset_val);
+	if (ret < 0)
+		return ret;
+	ret = cw_init(cw_bat);
+	if (ret)
+		return ret;
+	return 0;
+}
+
+static int cw_get_capacity(struct cw_battery *cw_bat)
+{
+	int cw_capacity;
+	int ret;
+	unsigned char reg_val[2];
+
+	static int reset_loop;
+	static int charging_loop;
+	static int discharging_loop;
+	static int jump_flag;
+	static int charging_5_loop;
+	int sleep_cap;
+
+	ret = cw_read_word(cw_bat->client, CW2015_REG_SOC, reg_val);
+	if (ret < 0)
+		return ret;
+
+	cw_capacity = reg_val[0];
+
+	if ((cw_capacity < 0) || (cw_capacity > 100)) {
+		cw_printk("Error:  cw_capacity = %d\n", cw_capacity);
+		reset_loop++;
+		if (reset_loop >
+		    (CW2015_BATTERY_CAPACITY_ERROR / cw_bat->monitor_sec)) {
+			cw_por(cw_bat);
+			reset_loop = 0;
+		}
+		return cw_bat->capacity;
+	} else {
+		reset_loop = 0;
+	}
+
+	/* case 1 : aviod swing */
+	if (((cw_bat->charger_mode > 0) &&
+	     (cw_capacity <= cw_bat->capacity - 1) &&
+	     (cw_capacity > cw_bat->capacity - 9)) ||
+	    ((cw_bat->charger_mode == 0) &&
+	     (cw_capacity == (cw_bat->capacity + 1)))) {
+		if (!(cw_capacity == 0 && cw_bat->capacity <= 2))
+			cw_capacity = cw_bat->capacity;
+	}
+
+	/* case 2 : aviod no charge full */
+	if ((cw_bat->charger_mode > 0) &&
+	    (cw_capacity >= 95) && (cw_capacity <= cw_bat->capacity)) {
+		cw_printk("Chaman join no charge full\n");
+		charging_loop++;
+		if (charging_loop >
+		    (CW2015_BATTERY_UP_MAX_CHANGE / cw_bat->monitor_sec)) {
+			cw_capacity = (cw_bat->capacity + 1) <= 100 ?
+				      (cw_bat->capacity + 1) : 100;
+			charging_loop = 0;
+			jump_flag = 1;
+		} else {
+			cw_capacity = cw_bat->capacity;
+		}
+	}
+
+	/* case 3 : avoid battery level jump to CW_BAT */
+	if ((cw_bat->charger_mode == 0) &&
+	    (cw_capacity <= cw_bat->capacity) &&
+	    (cw_capacity >= 90) && (jump_flag == 1)) {
+		cw_printk("Chaman join no charge full discharging\n");
+#ifdef CONFIG_PM
+		if (cw_bat->suspend_resume_mark == 1) {
+			cw_bat->suspend_resume_mark = 0;
+			sleep_cap = (cw_bat->after.tv_sec +
+				     discharging_loop *
+				     (cw_bat->monitor_sec / 1000)) /
+				     (CW2015_BATTERY_DOWN_MAX_CHANGE / 1000);
+			cw_printk("sleep_cap = %d\n", sleep_cap);
+
+			if (cw_capacity >= cw_bat->capacity - sleep_cap) {
+				return cw_capacity;
+			} else {
+				if (!sleep_cap)
+					discharging_loop = discharging_loop +
+						1 + cw_bat->after.tv_sec /
+						(cw_bat->monitor_sec / 1000);
+				else
+					discharging_loop = 0;
+				cw_printk("discharging_loop = %d\n",
+					  discharging_loop);
+				return cw_bat->capacity - sleep_cap;
+			}
+		}
+#endif
+		discharging_loop++;
+		if (discharging_loop >
+		    (CW2015_BATTERY_DOWN_MAX_CHANGE / cw_bat->monitor_sec)) {
+			if (cw_capacity >= cw_bat->capacity - 1)
+				jump_flag = 0;
+			else
+				cw_capacity = cw_bat->capacity - 1;
+
+			discharging_loop = 0;
+		} else {
+			cw_capacity = cw_bat->capacity;
+		}
+	}
+
+	/* case 4 : avoid battery level is 0% when long time charging */
+	if ((cw_bat->charger_mode > 0) && (cw_capacity == 0)) {
+		charging_5_loop++;
+		if (charging_5_loop >
+		    CW2015_BATTERY_CHARGING_ZERO / cw_bat->monitor_sec) {
+			cw_por(cw_bat);
+			charging_5_loop = 0;
+		}
+	} else if (charging_5_loop != 0) {
+		charging_5_loop = 0;
+	}
+#ifdef CONFIG_PM
+	if (cw_bat->suspend_resume_mark == 1)
+		cw_bat->suspend_resume_mark = 0;
+#endif
+	return cw_capacity;
+}
+
+static int cw_get_voltage(struct cw_battery *cw_bat)
+{
+	int ret;
+	u8 reg_val[2];
+	u16 value16, value16_1, value16_2, value16_3;
+	int voltage;
+	int res1, res2;
+
+	ret = cw_read_word(cw_bat->client, CW2015_REG_VCELL, reg_val);
+	if (ret < 0)
+		return ret;
+	value16 = (reg_val[0] << 8) + reg_val[1];
+
+	ret = cw_read_word(cw_bat->client, CW2015_REG_VCELL, reg_val);
+	if (ret < 0)
+		return ret;
+	value16_1 = (reg_val[0] << 8) + reg_val[1];
+
+	ret = cw_read_word(cw_bat->client, CW2015_REG_VCELL, reg_val);
+	if (ret < 0)
+		return ret;
+	value16_2 = (reg_val[0] << 8) + reg_val[1];
+
+	if (value16 > value16_1) {
+		value16_3 = value16;
+		value16 = value16_1;
+		value16_1 = value16_3;
+	}
+
+	if (value16_1 > value16_2) {
+		value16_3 = value16_1;
+		value16_1 = value16_2;
+		value16_2 = value16_3;
+	}
+
+	if (value16 > value16_1) {
+		value16_3 = value16;
+		value16 = value16_1;
+		value16_1 = value16_3;
+	}
+
+	voltage = value16_1 * 312 / 1024;
+
+	if (cw_bat->plat_data.divider_res1 &&
+	    cw_bat->plat_data.divider_res2) {
+		res1 = cw_bat->plat_data.divider_res1;
+		res2 = cw_bat->plat_data.divider_res2;
+		voltage = voltage * (res1 + res2) / res2;
+	} else if (cw_bat->dual_battery) {
+		voltage = voltage * 2;
+	}
+
+	dev_dbg(&cw_bat->client->dev, "the cw201x voltage=%d,reg_val=%x %x\n",
+		voltage, reg_val[0], reg_val[1]);
+	return voltage;
+}
+
+/*This function called when get RRT from cw2015*/
+static int cw_get_time_to_empty(struct cw_battery *cw_bat)
+{
+	int ret;
+	u8 reg_val;
+	u16 value16;
+
+	ret = cw_read(cw_bat->client, CW2015_REG_RRT_ALERT, &reg_val);
+	if (ret < 0)
+		return ret;
+
+	value16 = reg_val;
+
+	ret = cw_read(cw_bat->client, CW2015_REG_RRT_ALERT + 1, &reg_val);
+	if (ret < 0)
+		return ret;
+
+	value16 = ((value16 << 8) + reg_val) & CW2015_MASK_SOC;
+	return value16;
+}
+
+static void cw_update_charge_status(struct cw_battery *cw_bat)
+{
+	int cw_charger_mode;
+
+	cw_charger_mode = get_charge_state(cw_bat);
+	if (cw_bat->charger_mode != cw_charger_mode) {
+		cw_bat->charger_mode = cw_charger_mode;
+		cw_bat->bat_change = 1;
+		if (cw_charger_mode)
+			cw_bat->charge_count++;
+	}
+}
+
+static void cw_update_capacity(struct cw_battery *cw_bat)
+{
+	int cw_capacity;
+
+	cw_capacity = cw_get_capacity(cw_bat);
+	if ((cw_capacity >= 0) && (cw_capacity <= 100) &&
+	    (cw_bat->capacity != cw_capacity)) {
+		cw_bat->capacity = cw_capacity;
+		cw_bat->bat_change = 1;
+	}
+}
+
+static void cw_update_vol(struct cw_battery *cw_bat)
+{
+	int ret;
+
+	ret = cw_get_voltage(cw_bat);
+	if ((ret >= 0) && (cw_bat->voltage != ret))
+		cw_bat->voltage = ret;
+}
+
+static void cw_update_status(struct cw_battery *cw_bat)
+{
+	int status;
+
+	if (cw_bat->charger_mode > 0) {
+		if (cw_bat->capacity >= 100)
+			status = POWER_SUPPLY_STATUS_FULL;
+		else
+			status = POWER_SUPPLY_STATUS_CHARGING;
+	} else {
+		status = POWER_SUPPLY_STATUS_DISCHARGING;
+	}
+
+	if (cw_bat->status != status) {
+		cw_bat->status = status;
+		cw_bat->bat_change = 1;
+	}
+}
+
+static void cw_update_time_to_empty(struct cw_battery *cw_bat)
+{
+	int ret;
+
+	ret = cw_get_time_to_empty(cw_bat);
+	if ((ret >= 0) && (cw_bat->time_to_empty != ret)) {
+		cw_bat->time_to_empty = ret;
+		cw_bat->bat_change = 1;
+	}
+}
+
+static void cw_bat_work(struct work_struct *work)
+{
+	struct delayed_work *delay_work;
+	struct cw_battery *cw_bat;
+	int ret;
+	u8 reg_val;
+	int i = 0;
+
+	delay_work = container_of(work, struct delayed_work, work);
+	cw_bat =
+		container_of(delay_work, struct cw_battery, battery_delay_work);
+
+	/* Add for battery swap start */
+	ret = cw_read(cw_bat->client, CW2015_REG_MODE, &reg_val);
+	if (ret < 0) {
+		cw_bat->bat_mode = MODE_VIRTUAL;
+		cw_bat->bat_change = 1;
+	} else {
+		if ((reg_val & CW2015_MODE_SLEEP_MASK) == CW2015_MODE_SLEEP) {
+			for (i = 0; i < 5; i++) {
+				if (cw_por(cw_bat) == 0)
+					break;
+			}
+		}
+		cw_update_capacity(cw_bat);
+		cw_update_vol(cw_bat);
+		cw_update_charge_status(cw_bat);
+		cw_update_status(cw_bat);
+		cw_update_time_to_empty(cw_bat);
+	}
+	/* Add for battery swap end */
+	cw_printk("charger_mod = %d\n", cw_bat->charger_mode);
+	cw_printk("status = %d\n", cw_bat->status);
+	cw_printk("capacity = %d\n", cw_bat->capacity);
+	cw_printk("voltage = %d\n", cw_bat->voltage);
+
+#ifdef CONFIG_PM
+	if (cw_bat->suspend_resume_mark == 1)
+		cw_bat->suspend_resume_mark = 0;
+#endif
+
+	if (cw_bat->bat_change == 1) {
+		power_supply_changed(cw_bat->rk_bat);
+		cw_bat->bat_change = 0;
+	}
+	queue_delayed_work(cw_bat->battery_workqueue,
+			   &cw_bat->battery_delay_work,
+			   msecs_to_jiffies(cw_bat->monitor_sec));
+}
+
+static bool cw_battery_valid_time_to_empty(struct cw_battery *cw_bat)
+{
+	return cw_bat->time_to_empty > 0 && cw_bat->time_to_empty < CW2015_MASK_SOC &&
+		cw_bat->status == POWER_SUPPLY_STATUS_DISCHARGING;
+}
+
+static int cw_battery_get_property(struct power_supply *psy,
+				   enum power_supply_property psp,
+				   union power_supply_propval *val)
+{
+	int ret = 0;
+	struct cw_battery *cw_bat;
+
+	cw_bat = power_supply_get_drvdata(psy);
+	switch (psp) {
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = cw_bat->capacity;
+		if (cw_bat->bat_mode == MODE_VIRTUAL)
+			val->intval = CW2015_VIRTUAL_SOC;
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = cw_bat->status;
+		if (cw_bat->bat_mode == MODE_VIRTUAL)
+			val->intval = CW2015_VIRTUAL_STATUS;
+		break;
+
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = cw_bat->voltage <= 0 ? 0 : 1;
+		if (cw_bat->bat_mode == MODE_VIRTUAL)
+			val->intval = CW2015_VIRTUAL_PRESET;
+		break;
+
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = cw_bat->voltage * 1000;
+		if (cw_bat->bat_mode == MODE_VIRTUAL)
+			val->intval = CW2015_VIRTUAL_VOLTAGE * 1000;
+		break;
+
+	case POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:
+		if (cw_battery_valid_time_to_empty(cw_bat)) {
+			val->intval = cw_bat->time_to_empty;
+		} else {
+			val->intval = 0;
+		}
+		if (cw_bat->bat_mode == MODE_VIRTUAL)
+			val->intval = CW2015_VIRTUAL_TIME2EMPTY;
+		break;
+
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = POWER_SUPPLY_TECHNOLOGY_LION;
+		break;
+
+	case POWER_SUPPLY_PROP_CHARGE_COUNTER:
+		val->intval = cw_bat->charge_count;
+		break;
+
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		val->intval = cw_bat->plat_data.design_capacity * 1000;
+		break;
+
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = CW2015_VIRTUAL_TEMPERATURE;
+		break;
+
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		if (cw_battery_valid_time_to_empty(cw_bat)) {
+			// calculate remaining capacity
+			val->intval = cw_bat->plat_data.design_capacity * 1000;
+			val->intval = val->intval * cw_bat->capacity / 100;
+
+			// estimate current based on time to empty (in minutes)
+			val->intval = 60 * val->intval / cw_bat->time_to_empty;
+		} else {
+			val->intval = 0;
+		}
+
+		if (cw_bat->bat_mode == MODE_VIRTUAL)
+			val->intval = CW2015_VIRTUAL_CURRENT;
+		break;
+
+	default:
+		break;
+	}
+	return ret;
+}
+
+static enum power_supply_property cw_battery_properties[] = {
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_CHARGE_COUNTER,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+static const struct power_supply_desc cw2015_bat_desc = {
+	.name		= "rk-bat",
+	.type		= POWER_SUPPLY_TYPE_BATTERY,
+	.properties	= cw_battery_properties,
+	.num_properties	= ARRAY_SIZE(cw_battery_properties),
+	.get_property	= cw_battery_get_property,
+};
+
+#ifdef CONFIG_OF
+static int cw2015_parse_dt(struct cw_battery *cw_bat)
+{
+	struct device *dev = &cw_bat->client->dev;
+	struct device_node *node = dev->of_node;
+	struct property *prop;
+	int length;
+	u32 value;
+	int ret;
+	struct cw_bat_platform_data *data = &cw_bat->plat_data;
+	struct gpio_desc *hw_id0_io;
+	struct gpio_desc *hw_id1_io;
+	int hw_id0_val;
+	int hw_id1_val;
+
+	if (!node)
+		return -ENODEV;
+
+	memset(data, 0, sizeof(*data));
+
+	ret = of_property_read_u32(node, "hw_id_check", &value);
+	if (!ret && value) {
+		hw_id0_io = gpiod_get_optional(dev, "hw-id0", GPIOD_IN);
+		if (!hw_id0_io)
+			return -EINVAL;
+		if (IS_ERR(hw_id0_io))
+			return PTR_ERR(hw_id0_io);
+
+		hw_id0_val = gpiod_get_value(hw_id0_io);
+		gpiod_put(hw_id0_io);
+
+		hw_id1_io = gpiod_get_optional(dev, "hw-id1", GPIOD_IN);
+		if (!hw_id1_io)
+			return -EINVAL;
+		if (IS_ERR(hw_id1_io))
+			return PTR_ERR(hw_id1_io);
+
+		hw_id1_val = gpiod_get_value(hw_id1_io);
+		gpiod_put(hw_id1_io);
+
+		/*
+		 * ID1 = 0, ID0 = 1 : Battery
+		 * ID1 = 1, ID0 = 0 : Dual Battery
+		 * ID1 = 0, ID0 = 0 : Adapter
+		 */
+		if (hw_id0_val == 1 && hw_id1_val == 0)
+			cw_bat->dual_battery = false;
+		else if (hw_id0_val == 0 && hw_id1_val == 1)
+			cw_bat->dual_battery = true;
+		else
+			return -EINVAL;
+	}
+
+	/* determine the number of config info */
+	prop = of_find_property(node, "bat_config_info", &length);
+	if (!prop)
+		return -EINVAL;
+
+	length /= sizeof(u32);
+
+	if (length > 0) {
+		size_t size = sizeof(*data->cw_bat_config_info) * length;
+
+		data->cw_bat_config_info = devm_kzalloc(dev, size, GFP_KERNEL);
+		if (!data->cw_bat_config_info)
+			return -ENOMEM;
+
+		ret = of_property_read_u32_array(node, "bat_config_info",
+						 data->cw_bat_config_info,
+						 length);
+		if (ret < 0)
+			return ret;
+	}
+
+	cw_bat->bat_mode = MODE_BATTERY;
+	cw_bat->monitor_sec = CW2015_DEFAULT_MONITOR_SEC * CW2015_TIMER_MS_COUNTS;
+
+	ret = of_property_read_u32(node, "divider_res1", &value);
+	if (ret < 0)
+		value = 0;
+	data->divider_res1 = value;
+
+	ret = of_property_read_u32(node, "divider_res2", &value);
+	if (ret < 0)
+		value = 0;
+	data->divider_res2 = value;
+
+	ret = of_property_read_u32(node, "virtual_power", &value);
+	if (ret < 0)
+		value = 0;
+	cw_bat->bat_mode = value;
+
+	ret = of_property_read_u32(node, "monitor_sec", &value);
+	if (ret < 0)
+		dev_err(dev, "monitor_sec missing!\n");
+	else
+		cw_bat->monitor_sec = value * CW2015_TIMER_MS_COUNTS;
+
+	ret = of_property_read_u32(node, "design_capacity", &value);
+	if (ret < 0) {
+		dev_err(dev, "design_capacity missing!\n");
+		data->design_capacity = 2000;
+	} else {
+		data->design_capacity = value;
+	}
+
+	return 0;
+}
+#else
+static int cw2015_parse_dt(struct cw_battery *cw_bat)
+{
+	return -ENODEV;
+}
+#endif
+
+static int cw_bat_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	int ret;
+	struct cw_battery *cw_bat;
+	struct power_supply_config psy_cfg = {0};
+
+	cw_bat = devm_kzalloc(&client->dev, sizeof(*cw_bat), GFP_KERNEL);
+	if (!cw_bat) {
+		dev_err(&client->dev,
+			"fail to allocate memory for cw2015\n");
+		return -ENOMEM;
+	}
+
+	i2c_set_clientdata(client, cw_bat);
+	cw_bat->client = client;
+
+	ret = cw2015_parse_dt(cw_bat);
+	if (ret < 0) {
+		dev_err(&client->dev,
+			"failed to find cw2015 platform data\n");
+		return -1;
+	}
+
+	cw_bat->capacity = 1;
+	cw_bat->voltage = 0;
+	cw_bat->status = 0;
+	cw_bat->suspend_resume_mark = 0;
+	cw_bat->charger_mode = CW2015_NO_CHARGING;
+	cw_bat->bat_change = 0;
+
+	ret = cw_init(cw_bat);
+	if (ret) {
+		pr_err("%s cw_init error\n", __func__);
+		return ret;
+	}
+
+	psy_cfg.drv_data = cw_bat;
+
+	cw_bat->rk_bat = devm_power_supply_register(&client->dev,
+		&cw2015_bat_desc, &psy_cfg);
+	if (IS_ERR(cw_bat->rk_bat)) {
+		dev_err(&cw_bat->client->dev,
+			"power supply register rk_bat error\n");
+		return -1;
+	}
+
+	cw_bat->battery_workqueue = create_singlethread_workqueue("rk_battery");
+	INIT_DELAYED_WORK(&cw_bat->battery_delay_work, cw_bat_work);
+	queue_delayed_work(cw_bat->battery_workqueue,
+			   &cw_bat->battery_delay_work, msecs_to_jiffies(10));
+
+	dev_info(&cw_bat->client->dev,
+		 "cw2015/cw2013 driver v1.2 probe sucess\n");
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int cw_bat_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct cw_battery *cw_bat = i2c_get_clientdata(client);
+	read_persistent_clock64(&cw_bat->suspend_time_before);
+	cancel_delayed_work(&cw_bat->battery_delay_work);
+	return 0;
+}
+
+static int cw_bat_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct cw_battery *cw_bat = i2c_get_clientdata(client);
+	cw_bat->suspend_resume_mark = 1;
+	read_persistent_clock64(&cw_bat->after);
+	cw_bat->after = timespec64_sub(cw_bat->after,
+				     cw_bat->suspend_time_before);
+	queue_delayed_work(cw_bat->battery_workqueue,
+			   &cw_bat->battery_delay_work, msecs_to_jiffies(2));
+	return 0;
+}
+
+static const struct dev_pm_ops cw_bat_pm_ops = {
+	.suspend  = cw_bat_suspend,
+	.resume   = cw_bat_resume,
+};
+#endif
+
+static int cw_bat_remove(struct i2c_client *client)
+{
+	struct cw_battery *cw_bat = i2c_get_clientdata(client);
+
+	dev_dbg(&cw_bat->client->dev, "%s\n", __func__);
+	cancel_delayed_work(&cw_bat->battery_delay_work);
+	return 0;
+}
+
+static const struct i2c_device_id cw_bat_id_table[] = {
+	{"cw201x", 0},
+	{}
+};
+
+static struct i2c_driver cw_bat_driver = {
+	.driver = {
+		.name = "cellwise,cw201x",
+#ifdef CONFIG_PM
+		.pm = &cw_bat_pm_ops,
+#endif
+	},
+	.probe = cw_bat_probe,
+	.remove = cw_bat_remove,
+	.id_table = cw_bat_id_table,
+};
+
+static int __init cw_bat_init(void)
+{
+	return i2c_add_driver(&cw_bat_driver);
+}
+
+static void __exit cw_bat_exit(void)
+{
+	i2c_del_driver(&cw_bat_driver);
+}
+
+module_init(cw_bat_init);
+module_exit(cw_bat_exit);
+
+MODULE_AUTHOR("xhc<xhc@rock-chips.com>");
+MODULE_DESCRIPTION("cw2015/cw2013 battery driver");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/power/cw2015_battery.h b/include/linux/power/cw2015_battery.h
new file mode 100644
index 000000000000..59ad35b0c7f2
--- /dev/null
+++ b/include/linux/power/cw2015_battery.h
@@ -0,0 +1,122 @@
+/*
+ * Fuel gauge driver for CellWise 2013 / 2015
+ *
+ * Copyright (C) 2012, RockChip
+ * Copyright (C) 2019, Tobias Schramm
+ *
+ * Authors: xuhuicong <xhc@rock-chips.com>
+ * Authors: Tobias Schramm <tobias@t-sys.eu>
+ *
+ * Based on rk30_adc_battery.c
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef CW2015_BATTERY_H
+#define CW2015_BATTERY_H
+
+#define CW2015_SIZE_BATINFO    64
+
+#define CW2015_GPIO_HIGH  1
+#define CW2015_GPIO_LOW   0
+
+#define CW2015_READ_TRIES 30
+
+#define CW2015_REG_VERSION             0x0
+#define CW2015_REG_VCELL               0x2
+#define CW2015_REG_SOC                 0x4
+#define CW2015_REG_RRT_ALERT           0x6
+#define CW2015_REG_CONFIG              0x8
+#define CW2015_REG_MODE                0xA
+#define CW2015_REG_BATINFO             0x10
+
+#define CW2015_MODE_SLEEP_MASK         (0x3<<6)
+#define CW2015_MODE_SLEEP              (0x3<<6)
+#define CW2015_MODE_NORMAL             (0x0<<6)
+#define CW2015_MODE_QUICK_START        (0x3<<4)
+#define CW2015_MODE_RESTART            (0xf<<0)
+
+#define CW2015_CONFIG_UPDATE_FLG       (0x01<<1)
+#define CW2015_ATHD                    (0x00<<3)
+#define CW2015_MASK_ATHD               (0x1f<<3)
+#define CW2015_MASK_SOC                (0x1fff)
+
+#define CW2015_I2C_SPEED			100000
+#define CW2015_BATTERY_UP_MAX_CHANGE		(420 * 1000)
+#define CW2015_BATTERY_DOWN_MAX_CHANGE		(120 * 1000)
+#define CW2015_BATTERY_DOWN_CHANGE		60
+#define CW2015_BATTERY_DOWN_MIN_CHANGE_RUN	30
+#define CW2015_BATTERY_DOWN_MIN_CHANGE_SLEEP	1800
+#define CW2015_BATTERY_JUMP_TO_ZERO		(30 * 1000)
+#define CW2015_BATTERY_CAPACITY_ERROR		(40 * 1000)
+#define CW2015_BATTERY_CHARGING_ZERO		(1800 * 1000)
+
+#define CW2015_DOUBLE_SERIES_BATTERY	0
+
+#define CW2015_CHARGING_ON		1
+#define CW2015_NO_CHARGING		0
+
+#define CW2015_BATTERY_DOWN_MAX_CHANGE_RUN_AC_ONLINE 3600
+
+#define CW2015_NO_STANDARD_AC_BIG_CHARGE_MODE 1
+/* #define CW2015_SYSTEM_SHUTDOWN_VOLTAGE  3400000 */
+#define CW2015_BAT_LOW_INTERRUPT    1
+
+#define CW2015_USB_CHARGER_MODE        1
+#define CW2015_AC_CHARGER_MODE         2
+#define   CW2015_QUICKSTART         0
+
+#define CW2015_TIMER_MS_COUNTS			1000
+#define CW2015_DEFAULT_MONITOR_SEC		8
+
+/* virtual params */
+#define CW2015_VIRTUAL_CURRENT			1000
+#define CW2015_VIRTUAL_VOLTAGE			3888
+#define CW2015_VIRTUAL_SOC			66
+#define CW2015_VIRTUAL_PRESET			1
+#define CW2015_VIRTUAL_TEMPERATURE		188
+#define CW2015_VIRTUAL_TIME2EMPTY		60
+#define CW2015_VIRTUAL_STATUS			POWER_SUPPLY_STATUS_CHARGING
+
+enum bat_mode {
+	MODE_BATTERY = 0,
+	MODE_VIRTUAL,
+};
+
+struct cw_bat_platform_data {
+	int divider_res1;
+	int divider_res2;
+	u32 *cw_bat_config_info;
+	int design_capacity;
+};
+
+struct cw_battery {
+	struct i2c_client *client;
+	struct workqueue_struct *battery_workqueue;
+	struct delayed_work battery_delay_work;
+	struct cw_bat_platform_data plat_data;
+
+	struct power_supply *rk_bat;
+
+#ifdef CONFIG_PM
+	struct timespec64 suspend_time_before;
+	struct timespec64 after;
+	int suspend_resume_mark;
+#endif
+	int charger_mode;
+	int capacity;
+	int voltage;
+	int status;
+	int time_to_empty;
+	int alt;
+	u32 monitor_sec;
+	u32 bat_mode;
+	int bat_change;
+	bool dual_battery;
+	int charge_count;
+};
+
+#endif
-- 
2.23.0

From cd62f13288544a7f367f4af47fa2ead7c0cc4356 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Tue, 5 Nov 2019 18:41:57 +0100
Subject: [PATCH 03/51] arm64: Add devicetree for the Pinebook Pro

This adds a rough first attempt at a devicetree for the Pinebook Pro. It's not
quite finished, as audio and bluetooth are currently untested. There seems to be
a problem with full shutdown, too. The pinebook is not quite off when shut down
through software.

Signed-off-by: Tobias Schramm <tobias@t-sys.eu>
---
 arch/arm64/boot/dts/rockchip/Makefile         |    1 +
 .../boot/dts/rockchip/rk3399-pinebook-pro.dts | 1085 +++++++++++++++++
 2 files changed, 1086 insertions(+)
 create mode 100644 arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts

diff --git a/arch/arm64/boot/dts/rockchip/Makefile b/arch/arm64/boot/dts/rockchip/Makefile
index 48fb631d5451..9099fb7e2073 100644
--- a/arch/arm64/boot/dts/rockchip/Makefile
+++ b/arch/arm64/boot/dts/rockchip/Makefile
@@ -28,6 +28,7 @@ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3399-nanopc-t4.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3399-nanopi-m4.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3399-nanopi-neo4.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3399-orangepi.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3399-pinebook-pro.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3399-puma-haikou.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3399-roc-pc.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3399-roc-pc-mezzanine.dtb
diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
new file mode 100644
index 000000000000..569c1490b024
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -0,0 +1,1085 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2017 Fuzhou Rockchip Electronics Co., Ltd.
+ * Copyright (c) 2018 Akash Gajjar <Akash_Gajjar@mentor.com>
+ */
+
+/dts-v1/;
+#include <dt-bindings/input/linux-event-codes.h>
+#include <dt-bindings/pwm/pwm.h>
+#include "rk3399.dtsi"
+#include "rk3399-opp.dtsi"
+
+/ {
+	model = "Pine64 Pinebook Pro";
+	compatible = "pine64,pinebook-pro", "rockchip,rk3399";
+
+	edp_panel: edp-panel { /* "boe,nv140fhmn49" */
+		compatible = "boe,nv140fhmn49", "simple-panel";
+		backlight = <&backlight>;
+		power-supply = <&vcc3v3_s0>;
+//		pinctrl-names = "default";
+//		pinctrl-0 = <&panel_en>;
+		enable-gpios = <&gpio1 RK_PA0 GPIO_ACTIVE_HIGH>;
+		prepare-delay-ms = <20>;
+		enable-delay-ms = <20>;
+		status = "okay";
+
+		ports {
+	                #address-cells = <0x01>;
+                        #size-cells = <0x00>;
+			port@0 {
+				panel_in_edp: endpoint@0 {
+					remote-endpoint = <&edp_out_panel>;
+				};
+			};
+		};
+	};
+
+	chosen {
+		bootargs = "earlycon=uart8250,mmio32,0xff1a0000";
+		stdout-path = "serial2:1500000n8";
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		drm_logo: drm-logo@00000000 {
+			compatible = "rockchip,drm-logo";
+			reg = <0x0 0x0 0x0 0x0>;
+		};
+	};
+
+	dc_12v: dc-12v {
+		compatible = "regulator-fixed";
+		regulator-name = "dc_12v";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	gpio-keys {
+		compatible = "gpio-keys";
+		autorepeat;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pwrbtn>;
+
+		power {
+			debounce-interval = <100>;
+			gpios = <&gpio0 RK_PA5 GPIO_ACTIVE_LOW>;
+			label = "GPIO Key Power";
+			linux,code = <KEY_POWER>;
+			wakeup-source;
+		};
+	};
+
+	
+	backlight: edp-backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm0 0 740740 0>;
+		power-supply = <&vcc3v3_s3>;
+		brightness-levels = <
+			  0   1   2   3   4   5   6   7
+			  8   9  10  11  12  13  14  15
+			 16  17  18  19  20  21  22  23
+			 24  25  26  27  28  29  30  31
+			 32  33  34  35  36  37  38  39
+			 40  41  42  43  44  45  46  47
+			 48  49  50  51  52  53  54  55
+			 56  57  58  59  60  61  62  63
+			 64  65  66  67  68  69  70  71
+			 72  73  74  75  76  77  78  79
+			 80  81  82  83  84  85  86  87
+			 88  89  90  91  92  93  94  95
+			 96  97  98  99 100 101 102 103
+			104 105 106 107 108 109 110 111
+			112 113 114 115 116 117 118 119
+			120 121 122 123 124 125 126 127
+			128 129 130 131 132 133 134 135
+			136 137 138 139 140 141 142 143
+			144 145 146 147 148 149 150 151
+			152 153 154 155 156 157 158 159
+			160 161 162 163 164 165 166 167
+			168 169 170 171 172 173 174 175
+			176 177 178 179 180 181 182 183
+			184 185 186 187 188 189 190 191
+			192 193 194 195 196 197 198 199
+			200 201 202 203 204 205 206 207
+			208 209 210 211 212 213 214 215
+			216 217 218 219 220 221 222 223
+			224 225 226 227 228 229 230 231
+			232 233 234 235 236 237 238 239
+			240 241 242 243 244 245 246 247
+			248 249 250 251 252 253 254 255>;
+		default-brightness-level = <200>;
+		status = "okay";
+	};
+
+	panel {
+		vcc_lcd_en_drv: vcc-lcd-en-drv {
+			rockchip,pins = <1 RK_PC6 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		panel_en: panel-en {
+			rockchip,pins = <1 RK_PA0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	vcc_lcd_en: vcc-lcd-en-regulator {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio1 RK_PC6 GPIO_ACTIVE_HIGH>;
+//		pinctrl-names = "default";
+//		pinctrl-0 = <&vcc_lcd_en_drv>;
+		regulator-name = "vcc_lcd_en";
+		regulator-enable-ramp-delay = <100000>;
+		vin-supply = <&vcc3v3_sys>;
+		regulator-always-on;
+
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	leds {
+
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&work_led_gpio>, <&diy_led_gpio>;
+
+		work-led {
+			label = "work";
+			default-state = "on";
+			gpios = <&gpio0 RK_PB3 GPIO_ACTIVE_HIGH>;
+		};
+
+		diy-led {
+			label = "diy";
+			default-state = "off";
+			gpios = <&gpio0 RK_PA2 GPIO_ACTIVE_HIGH>;
+		};
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		clocks = <&rk808 1>;
+		clock-names = "ext_clock";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_enable_h>;
+
+		/*
+		 * On the module itself this is one of these (depending
+		 * on the actual card populated):
+		 * - SDIO_RESET_L_WL_REG_ON
+		 * - PDN (power down when low)
+		 */
+		reset-gpios = <&gpio0 RK_PB2 GPIO_ACTIVE_LOW>;
+	};
+
+	wireless-wlan {
+		compatible = "wlan-platdata";
+		rockchip,grf = <&grf>;
+		wifi_chip_type = "ap6354";
+		sdio_vref = <1800>;
+		WIFI,host_wake_irq = <&gpio0 RK_PA3 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	wireless-bluetooth {
+		compatible = "bluetooth-platdata";
+		clocks = <&rk808 1>;
+		clock-names = "ext_clock";
+		uart_rts_gpios = <&gpio2 RK_PC3 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default", "rts_gpio";
+		pinctrl-0 = <&uart0_rts>;
+		pinctrl-1 = <&uart0_gpios>;
+		BT,reset_gpio    = <&gpio0 RK_PB1 GPIO_ACTIVE_HIGH>;
+		BT,wake_gpio     = <&gpio2 RK_PD3 GPIO_ACTIVE_HIGH>;
+		BT,wake_host_irq = <&gpio0 RK_PA4 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+/*
+	es8316-sound {
+		status = "okay";
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "rockchip,es8316-codec";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <256>;
+		simple-audio-card,widgets =
+			"Microphone", "Mic Jack",
+			"Headphone", "Headphone Jack";
+		simple-audio-card,routing =
+			"Mic Jack", "MICBIAS1",
+			"IN1P", "Mic Jack",
+			"Headphone Jack", "HPOL",
+			"Headphone Jack", "HPOR";
+
+		simple-audio-card,cpu {
+			sound-dai = <&i2s1>;
+		};
+
+		simple-audio-card,codec {
+			sound-dai = <&es8316>;
+		};
+	};
+*/
+	speaker-sound {
+		status = "okay";
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,name = "rk-es8316-spk-sound";
+		simple-audio-card,mclk-fs = <256>;
+
+		simple-audio-card,cpu {
+			sound-dai = <&i2s1>;
+			system-clock-frequency = <12288000>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&es8316>;
+			system-clock-frequency = <12288000>;
+		};
+	};
+
+	fan0: pwm-fan {
+		compatible = "pwm-fan";
+		pwms = <&pwm1 0 10000 0>;
+		cooling-min-state = <0>;
+		cooling-max-state = <3>;
+		#cooling-cells = <2>;
+		cooling-levels = <0 102 170 230>;
+	};
+
+	/* switched by pmic_sleep */
+	vcc1v8_s3: vcca1v8_s3: vcc1v8-s3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc1v8_s3";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&vcc_1v8>;
+	};
+
+	vcc3v3_pcie: vcc3v3-pcie-regulator {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio1 RK_PD0 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pcie_pwr_en>;
+		regulator-name = "vcc3v3_pcie";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&dc_12v>;
+	};
+
+	vcc_phy: vcc-phy-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_phy";
+		regulator-always-on;
+		regulator-boot-on;
+	};
+
+	vcc3v3_sys: vcc3v3-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&vcc_sys>;
+	};
+
+	/* Actually 3 regulators (host0, 1, 2) controlled by the same gpio */
+	vcc5v0_host: vcc5v0-host-regulator {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio4 RK_PC5 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_host_en>;
+		regulator-name = "vcc5v0_host";
+		regulator-always-on;
+		vin-supply = <&vcc_sys>;
+	};
+
+	vcc5v0_typec: vcc5v0-typec-regulator {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio1 RK_PA3 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_typec_en>;
+		regulator-name = "vcc5v0_typec";
+		regulator-always-on;
+		vin-supply = <&vcc_sys>;
+	};
+
+	vcc_sys: vcc-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&dc_12v>;
+	};
+
+	vdd_log: vdd-log {
+		compatible = "pwm-regulator";
+		pwms = <&pwm2 0 25000 1>;
+		pwm-supply = <&vcc_sys>;
+		regulator-name = "vdd_log";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <800000>;
+		regulator-max-microvolt = <1400000>;
+	};
+
+	mains_charger: dc-charger {
+		compatible = "gpio-charger";
+		charger-type = "mains";
+		gpios = <&gpio4 RK_PD0 GPIO_ACTIVE_LOW>;
+//		pinctrl-names = "default";
+//		pinctrl-0 = <&dc_det_gpio>;
+	};
+
+	usb_charger: usb-charger {
+		status = "okay";
+		compatible = "universal-charger";
+		extcon = <&fusb0>;
+	};
+};
+/*
+&display_subsystem {
+	status = "okay";
+
+	ports = <&vopb_out>, <&vopl_out>;
+	logo-memory-region = <&drm_logo>;
+
+	route {
+		route_dp: route-dp {
+			logo,uboot = "logo.bmp";
+			logo,kernel = "logo_kernel.bmp";
+			logo,mode = "center";
+			charge_logo,mode = "center";
+			connect = <&vopl_out_dp>;
+		};
+
+		route_edp: route-edp {
+			logo,uboot = "logo.bmp";
+			logo,kernel = "logo_kernel.bmp";
+			logo,mode = "center";
+			charge_logo,mode = "center";
+			connect = <&vopb_out_edp>;
+		};
+	};
+};
+*/
+&edp {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&edp_hpd>;
+
+	ports {
+		edp_out: port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			edp_out_panel: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&panel_in_edp>;
+			};
+		};
+	};
+};
+
+&cpu_l0 {
+	cpu-supply = <&vdd_cpu_l>;
+};
+
+&cpu_l1 {
+	cpu-supply = <&vdd_cpu_l>;
+};
+
+&cpu_l2 {
+	cpu-supply = <&vdd_cpu_l>;
+};
+
+&cpu_l3 {
+	cpu-supply = <&vdd_cpu_l>;
+};
+
+&cpu_b0 {
+	cpu-supply = <&vdd_cpu_b>;
+};
+
+&cpu_b1 {
+	cpu-supply = <&vdd_cpu_b>;
+};
+
+&cpu_alert0 {
+	temperature = <80000>;
+};
+
+&cpu_alert1 {
+	temperature = <95000>;
+};
+
+&cpu_crit {
+	temperature = <100000>;
+};
+
+&emmc_phy {
+	status = "okay";
+};
+
+&hdmi_sound {
+	status = "okay";
+};
+
+&hdmi {
+	ddc-i2c-bus = <&i2c3>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&hdmi_cec>;
+	status = "disabled";
+};
+
+&gpu {
+	mali-supply = <&vdd_gpu>;
+	status = "okay";
+};
+
+&i2c0 {
+	clock-frequency = <400000>;
+	i2c-scl-rising-time-ns = <168>;
+	i2c-scl-falling-time-ns = <4>;
+	status = "okay";
+
+	rk808: pmic@1b {
+		compatible = "rockchip,rk808";
+		reg = <0x1b>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <21 IRQ_TYPE_LEVEL_LOW>;
+		#clock-cells = <1>;
+		clock-output-names = "xin32k", "rk808-clkout2";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pmic_int_l>;
+		rockchip,system-power-controller;
+		wakeup-source;
+
+		vcc1-supply = <&vcc_sys>;
+		vcc2-supply = <&vcc_sys>;
+		vcc3-supply = <&vcc_sys>;
+		vcc4-supply = <&vcc_sys>;
+		vcc6-supply = <&vcc_sys>;
+		vcc7-supply = <&vcc_sys>;
+		vcc8-supply = <&vcc3v3_sys>;
+		vcc9-supply = <&vcc_sys>;
+		vcc10-supply = <&vcc_sys>;
+		vcc11-supply = <&vcc_sys>;
+		vcc12-supply = <&vcc3v3_sys>;
+		vddio-supply = <&vcc1v8_pmu>;
+
+		regulators {
+			vdd_center: DCDC_REG1 {
+				regulator-name = "vdd_center";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <750000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-ramp-delay = <6001>;
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdd_cpu_l: DCDC_REG2 {
+				regulator-name = "vdd_cpu_l";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <750000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-ramp-delay = <6001>;
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_ddr: DCDC_REG3 {
+				regulator-name = "vcc_ddr";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+
+			vcc_1v8: DCDC_REG4 {
+				regulator-name = "vcc_1v8";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vcc1v8_dvp: LDO_REG1 {
+				regulator-name = "vcc1v8_dvp";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc3v0_touch: LDO_REG2 {
+				regulator-name = "vcc3v0_touch";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc1v8_pmu: LDO_REG3 {
+				regulator-name = "vcc1v8_pmu";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vcc_sdio: LDO_REG4 {
+				regulator-name = "vcc_sdio";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3000000>;
+				};
+			};
+
+			vcca3v0_codec: LDO_REG5 {
+				regulator-name = "vcca3v0_codec";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_1v5: LDO_REG6 {
+				regulator-name = "vcc_1v5";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <1500000>;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1500000>;
+				};
+			};
+
+			vcca1v8_codec: LDO_REG7 {
+				regulator-name = "vcca1v8_codec";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_3v0: LDO_REG8 {
+				regulator-name = "vcc_3v0";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3000000>;
+				};
+			};
+
+			vcc3v3_s3: vcc_lan: SWITCH_REG1 {
+				regulator-name = "vcc3v3_s3";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc3v3_s0: SWITCH_REG2 {
+				regulator-name = "vcc3v3_s0";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+		};
+	};
+
+	vdd_cpu_b: regulator@40 {
+		compatible = "silergy,syr827";
+		reg = <0x40>;
+		fcs,suspend-voltage-selector = <1>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vsel1_gpio>;
+		vsel-gpios = <&gpio1 RK_PC1 GPIO_ACTIVE_HIGH>;
+		regulator-compatible = "fan53555-reg";
+		regulator-name = "vdd_cpu_b";
+		regulator-min-microvolt = <712500>;
+		regulator-max-microvolt = <1500000>;
+		regulator-ramp-delay = <1000>;
+		regulator-always-on;
+		regulator-boot-on;
+		vin-supply = <&vcc_sys>;
+
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	vdd_gpu: regulator@41 {
+		compatible = "silergy,syr828";
+		reg = <0x41>;
+		fcs,suspend-voltage-selector = <1>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vsel2_gpio>;
+		vsel-gpios = <&gpio1 RK_PB6 GPIO_ACTIVE_HIGH>;
+		regulator-compatible = "fan53555-reg";
+		regulator-name = "vdd_gpu";
+		regulator-min-microvolt = <712500>;
+		regulator-max-microvolt = <1500000>;
+		regulator-ramp-delay = <1000>;
+		regulator-always-on;
+		regulator-boot-on;
+		vin-supply = <&vcc_sys>;
+
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c1 {
+	i2c-scl-rising-time-ns = <300>;
+	i2c-scl-falling-time-ns = <15>;
+	status = "okay";
+
+	es8316: es8316@11 {
+		#sound-dai-cells = <0>;
+		compatible = "everest,es8316";
+		reg = <0x11>;
+		clocks = <&cru SCLK_I2S_8CH_OUT>;
+		clock-names = "mclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2s_8ch_mclk>;
+		spk-con-gpio = <&gpio4 RK_PD3 GPIO_ACTIVE_HIGH>;
+		hp-det-gpio = <&gpio0 RK_PB0 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+&i2c3 {
+	i2c-scl-rising-time-ns = <450>;
+	i2c-scl-falling-time-ns = <15>;
+	status = "okay";
+};
+
+
+
+&i2c4 {
+	i2c-scl-rising-time-ns = <600>;
+	i2c-scl-falling-time-ns = <20>;
+	status = "okay";
+
+	fusb0: fusb30x@22 {
+		compatible = "fairchild,fusb302";
+		reg = <0x22>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&fusb0_int>;
+		vbus-5v-gpios = <&gpio1 RK_PA3 GPIO_ACTIVE_HIGH>;
+		int-n-gpios = <&gpio1 RK_PA2 GPIO_ACTIVE_HIGH>;
+		fcs,int_n = <&gpio1 RK_PA2 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	cw2015@62 {
+		status = "okay";
+		compatible = "cellwise,cw201x";
+		reg = <0x62>;
+		bat_config_info = <
+			0x17 0x67 0x80 0x73 0x6E 0x6C 0x6B 0x63
+			0x77 0x51 0x5C 0x58 0x50 0x4C 0x48 0x36
+			0x15 0x0C 0x0C 0x19 0x5B 0x7D 0x6F 0x69
+			0x69 0x5B 0x0C 0x29 0x20 0x40 0x52 0x59
+			0x57 0x56 0x54 0x4F 0x3B 0x1F 0x7F 0x17
+			0x06 0x1A 0x30 0x5A 0x85 0x93 0x96 0x2D
+			0x48 0x77 0x9C 0xB3 0x80 0x52 0x94 0xCB
+			0x2F 0x00 0x64 0xA5 0xB5 0x11 0xF0 0x11
+		>;
+		monitor_sec = <5>;
+		virtual_power = <0>;
+		design_capacity = <9800>;
+		power-supplies = <&mains_charger>, <&fusb0>;
+	};
+};
+
+&i2s0 {
+	rockchip,playback-channels = <8>;
+	rockchip,capture-channels = <8>;
+	#sound-dai-cells = <0>;
+	status = "okay";
+};
+
+&i2s1 {
+	rockchip,playback-channels = <2>;
+	rockchip,capture-channels = <2>;
+	#sound-dai-cells = <0>;
+	status = "okay";
+};
+
+&i2s2 {
+	#sound-dai-cells = <0>;
+	status = "okay";
+};
+
+&io_domains {
+	status = "okay";
+
+	bt656-supply = <&vcc1v8_dvp>;
+	audio-supply = <&vcca1v8_codec>;
+	sdmmc-supply = <&vcc_sdio>;
+	gpio1830-supply = <&vcc_3v0>;
+};
+
+&pcie_phy {
+	status = "okay";
+};
+
+&pcie0 {
+	ep-gpios = <&gpio2 RK_PD4 GPIO_ACTIVE_HIGH>;
+	num-lanes = <4>;
+	max-link-speed = <2>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pcie_clkreqn_cpm>;
+	vpcie3v3-supply = <&vcc3v3_pcie>;
+	bus-scan-delay-ms = <1000>;
+	status = "okay";
+};
+
+&pmu_io_domains {
+	pmu1830-supply = <&vcc_3v0>;
+	status = "okay";
+};
+
+&pinctrl {
+	buttons {
+		pwrbtn: pwrbtn {
+			rockchip,pins = <0 RK_PA5 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	dc-charger {
+		dc_det_gpio: dc-det-gpio {
+			rockchip,pins = <4 RK_PD0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	fusb302x {
+		fusb0_int: fusb0-int {
+			rockchip,pins = <1 RK_PA2 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	leds {
+		work_led_gpio: work_led-gpio {
+			rockchip,pins = <0 RK_PB3 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		diy_led_gpio: diy_led-gpio {
+			rockchip,pins = <0 RK_PA2 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	lcd-panel {
+		lcd_panel_reset: lcd-panel-reset {
+			rockchip,pins = <4 RK_PD6 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	pcie {
+		pcie_pwr_en: pcie-pwr-en {
+			rockchip,pins = <1 RK_PD0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	pmic {
+		pmic_int_l: pmic-int-l {
+			rockchip,pins = <3 RK_PB2 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		vsel1_gpio: vsel1-gpio {
+			rockchip,pins = <1 RK_PC1 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+
+		vsel2_gpio: vsel2-gpio {
+			rockchip,pins = <1 RK_PB6 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+	sdio-pwrseq {
+		wifi_enable_h: wifi-enable-h {
+			rockchip,pins = <0 RK_PB2 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	usb-typec {
+		vcc5v0_typec_en: vcc5v0_typec_en {
+			rockchip,pins = <1 RK_PA3 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	rt5640 {
+		rt5640_hpcon: rt5640-hpcon {
+			rockchip,pins = <4 RK_PC5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	usb2 {
+		vcc5v0_host_en: vcc5v0-host-en {
+			rockchip,pins = <4 RK_PC5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	i2s0 {
+		i2s_8ch_mclk: i2s-8ch-mclk {
+			rockchip,pins = <4 0 RK_FUNC_1 &pcfg_pull_none>;
+		};
+	};
+
+	wireless-bluetooth {
+		uart0_gpios: uart0-gpios {
+			rockchip,pins =
+				<2 RK_PC3 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+};
+
+&pwm0 {
+	status = "okay";
+};
+
+&pwm1 {
+	status = "okay";
+};
+
+&pwm2 {
+	status = "okay";
+};
+
+&saradc {
+	vref-supply = <&vcca1v8_s3>;
+	status = "okay";
+};
+
+&sdmmc {
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	cd-gpios = <&gpio0 7 GPIO_ACTIVE_LOW>;
+	disable-wp;
+	sd-uhs-sdr104;
+	max-frequency = <150000000>;
+	vqmmc-supply = <&vcc_sdio>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc_clk &sdmmc_cmd &sdmmc_bus4>;
+	status = "okay";
+};
+
+&sdio0 {
+	supports-sdio;
+	bus-width = <4>;
+	disable-wp;
+	cap-sd-highspeed;
+	cap-sdio-irq;
+	keep-power-in-suspend;
+	mmc-pwrseq = <&sdio_pwrseq>;
+	non-removable;
+	num-slots = <1>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdio0_bus4 &sdio0_cmd &sdio0_clk>;
+	sd-uhs-sdr104;
+	status = "okay";
+	defer_pcie = <2000>;
+};
+
+&sdhci {
+	bus-width = <8>;
+	//mmc-hs400-1_8v;
+	mmc-hs200-1_8v;
+	//mmc-hs400-enhanced-strobe;
+	non-removable;
+	status = "okay";
+};
+
+&tcphy0 {
+	extcon = <&fusb0>;
+	status = "okay";
+};
+
+&tcphy1 {
+	status = "okay";
+};
+
+&tsadc {
+	/* tshut mode 0:CRU 1:GPIO */
+	rockchip,hw-tshut-mode = <1>;
+	/* tshut polarity 0:LOW 1:HIGH */
+	rockchip,hw-tshut-polarity = <1>;
+	status = "okay";
+};
+
+&u2phy0 {
+	status = "okay";
+
+	u2phy0_otg: otg-port {
+		status = "okay";
+	};
+
+	u2phy0_host: host-port {
+		phy-supply = <&vcc5v0_host>;
+		status = "okay";
+	};
+};
+
+&u2phy1 {
+	status = "okay";
+
+	u2phy1_otg: otg-port {
+		status = "okay";
+	};
+
+	u2phy1_host: host-port {
+		phy-supply = <&vcc5v0_host>;
+		status = "okay";
+	};
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_xfer &uart0_cts>;
+	status = "okay";
+};
+
+&uart2 {
+	status = "okay";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&usbdrd3_0 {
+	extcon = <&fusb0>;
+	status = "okay";
+};
+
+&usbdrd_dwc3_0 {
+	status = "okay";
+	dr_mode = "otg";
+};
+
+&usbdrd3_1 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_1 {
+	status = "okay";
+	dr_mode = "host";
+};
+
+&vopb {
+	status = "okay";
+};
+
+&vopb_mmu {
+	status = "okay";
+};
+
+&vopl {
+	status = "okay";
+};
+
+&vopl_mmu {
+	status = "okay";
+};
+
+&spi1 {
+	status = "okay";
+	max-freq = <10000000>;
+
+	spiflash: spi-flash@0 {
+		#address-cells = <0x1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		reg = <0x0>;
+		spi-max-frequency = <10000000>;
+		status = "okay";
+		m25p,fast-read;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			loader@8000 {
+				label = "loader";
+				reg = <0x0 0x3F8000>;
+			};
+
+			env@3f8000 {
+				label = "env";
+				reg = <0x3F8000 0x8000>;
+			};
+
+			vendor@7c0000 {
+				label = "vendor";
+				reg = <0x7C0000 0x40000>;
+			};
+		};
+	};
+};
-- 
2.23.0

From 6d040eac79396e8e35aec327c349027898fd3592 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Fri, 8 Nov 2019 13:39:02 +0100
Subject: [PATCH 04/51] panel-simple: Slow down display clock a little

This might help with marginal designs a bit and does still archieve 60 Hz
refresh rate
---
 drivers/gpu/drm/panel/panel-simple.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index cce539b99c35..11c96029bdf2 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -1035,15 +1035,15 @@ static const struct panel_desc boe_nv101wxmn51 = {
 
 static const struct drm_display_mode boe_nv140fhmn49_modes[] = {
 	{
-		.clock = 150000,
+		.clock = 148500,
 		.hdisplay = 1920,
 		.hsync_start = 1920 + 48,
 		.hsync_end = 1920 + 48 + 32,
-		.htotal = 1920 + 48 + 32 + 80,
+		.htotal = 2200,
 		.vdisplay = 1080,
 		.vsync_start = 1080 + 3,
 		.vsync_end = 1080 + 3 + 5,
-		.vtotal = 1080 + 3 + 5 + 24,
+		.vtotal = 1125,
 		.vrefresh = 60,
 	},
 };
-- 
2.23.0

From 494e55a5e4aabdf2f7de9f8a4d7108b2f820d9fb Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Fri, 8 Nov 2019 16:41:56 +0100
Subject: [PATCH 05/51] arm64: Enable charging via USB-C on the Pinebook Pro

---
 .../boot/dts/rockchip/rk3399-pinebook-pro.dts      | 14 +++++++++++---
 1 file changed, 11 insertions(+), 3 deletions(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index 569c1490b024..8140c33ae812 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -7,6 +7,7 @@
 /dts-v1/;
 #include <dt-bindings/input/linux-event-codes.h>
 #include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/usb/pd.h>
 #include "rk3399.dtsi"
 #include "rk3399-opp.dtsi"
 
@@ -311,7 +312,6 @@
 		pinctrl-names = "default";
 		pinctrl-0 = <&vcc5v0_typec_en>;
 		regulator-name = "vcc5v0_typec";
-		regulator-always-on;
 		vin-supply = <&vcc_sys>;
 	};
 
@@ -719,10 +719,18 @@
 		reg = <0x22>;
 		pinctrl-names = "default";
 		pinctrl-0 = <&fusb0_int>;
-		vbus-5v-gpios = <&gpio1 RK_PA3 GPIO_ACTIVE_HIGH>;
-		int-n-gpios = <&gpio1 RK_PA2 GPIO_ACTIVE_HIGH>;
 		fcs,int_n = <&gpio1 RK_PA2 GPIO_ACTIVE_HIGH>;
+		vbus-supply = <&vcc5v0_typec>;
 		status = "okay";
+		connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+			power-role = "dual";
+			try-power-role = "sink";
+			source-pdos = <PDO_FIXED(5000, 1400, PDO_FIXED_USB_COMM)>;
+			sink-pdos = <PDO_FIXED(5000, 2500, PDO_FIXED_USB_COMM)>;
+			op-sink-microwatt = <1000000>;
+		};
 	};
 
 	cw2015@62 {
-- 
2.23.0

From fd0bdc3a958a380c8d306154012806460db6394d Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Fri, 8 Nov 2019 22:47:14 +0100
Subject: [PATCH 06/51] arm64: Ignore eDP hpd on the Pinebook Pro

Hotplug detect of the eDP panel is not connected. Thus it needs to be ignored
---
 arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts | 1 +
 1 file changed, 1 insertion(+)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index 8140c33ae812..2b4fcebaa692 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -380,6 +380,7 @@
 	status = "okay";
 	pinctrl-names = "default";
 	pinctrl-0 = <&edp_hpd>;
+	force-hpd;
 
 	ports {
 		edp_out: port@1 {
-- 
2.23.0

From f32ecbf2d560a656dde92a8d23ff01151b9e3270 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Sat, 9 Nov 2019 12:59:44 +0100
Subject: [PATCH 07/51] arm64: Add 2 GHz operating power point to big cpu
 cluster on the Pinebook Pro

---
 arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index 2b4fcebaa692..9b577b25f07f 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -803,6 +803,13 @@
 	status = "okay";
 };
 
+&cluster1_opp {
+	opp08 {
+		opp-hz = /bits/ 64 <2000000000>;
+		opp-microvolt = <1300000>;
+	};
+};
+
 &pinctrl {
 	buttons {
 		pwrbtn: pwrbtn {
-- 
2.23.0

From 84d2365acef3d8e581015243b411236ae4405edd Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Thu, 7 Nov 2019 20:46:08 +0100
Subject: [PATCH 08/51] arm64: Add audio support for the Pinebook Pro

---
 .../boot/dts/rockchip/rk3399-pinebook-pro.dts | 64 +++++++++----------
 1 file changed, 29 insertions(+), 35 deletions(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index 9b577b25f07f..08a6de6b3e26 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -202,21 +202,27 @@
 		BT,wake_host_irq = <&gpio0 RK_PA4 GPIO_ACTIVE_HIGH>;
 		status = "okay";
 	};
-/*
+
 	es8316-sound {
 		status = "okay";
 		compatible = "simple-audio-card";
 		simple-audio-card,name = "rockchip,es8316-codec";
 		simple-audio-card,format = "i2s";
 		simple-audio-card,mclk-fs = <256>;
+
 		simple-audio-card,widgets =
 			"Microphone", "Mic Jack",
-			"Headphone", "Headphone Jack";
+			"Headphone", "Headphones",
+			"Speaker", "Speaker";
 		simple-audio-card,routing =
-			"Mic Jack", "MICBIAS1",
-			"IN1P", "Mic Jack",
-			"Headphone Jack", "HPOL",
-			"Headphone Jack", "HPOR";
+			"MIC1", "Mic Jack",
+			"Headphones", "HPOL",
+			"Headphones", "HPOR",
+			"Speaker", "HPOL",
+			"Speaker", "HPOR";
+
+		simple-audio-card,hp-det-gpio = <&gpio0 RK_PB0 GPIO_ACTIVE_HIGH>;
+		simple-audio-card,aux-devs = <&speaker_amp>;
 
 		simple-audio-card,cpu {
 			sound-dai = <&i2s1>;
@@ -226,22 +232,12 @@
 			sound-dai = <&es8316>;
 		};
 	};
-*/
-	speaker-sound {
-		status = "okay";
-		compatible = "simple-audio-card";
-		simple-audio-card,format = "i2s";
-		simple-audio-card,name = "rk-es8316-spk-sound";
-		simple-audio-card,mclk-fs = <256>;
 
-		simple-audio-card,cpu {
-			sound-dai = <&i2s1>;
-			system-clock-frequency = <12288000>;
-		};
-		simple-audio-card,codec {
-			sound-dai = <&es8316>;
-			system-clock-frequency = <12288000>;
-		};
+	speaker_amp: speaker-amplifier {
+		status = "okay";
+		compatible = "simple-audio-amplifier";
+		enable-gpios = <&gpio4 RK_PD3 GPIO_ACTIVE_HIGH>;
+		VCC-supply = <&vcc5v0_host>;
 	};
 
 	fan0: pwm-fan {
@@ -685,20 +681,18 @@
 };
 
 &i2c1 {
-	i2c-scl-rising-time-ns = <300>;
-	i2c-scl-falling-time-ns = <15>;
+	i2c-scl-rising-time-ns = <168>;
+	i2c-scl-falling-time-ns = <4>;
 	status = "okay";
 
+	clock-frequency = <100000>;
+
 	es8316: es8316@11 {
 		#sound-dai-cells = <0>;
 		compatible = "everest,es8316";
 		reg = <0x11>;
 		clocks = <&cru SCLK_I2S_8CH_OUT>;
 		clock-names = "mclk";
-		pinctrl-names = "default";
-		pinctrl-0 = <&i2s_8ch_mclk>;
-		spk-con-gpio = <&gpio4 RK_PD3 GPIO_ACTIVE_HIGH>;
-		hp-det-gpio = <&gpio0 RK_PB0 GPIO_ACTIVE_HIGH>;
 	};
 };
 
@@ -756,22 +750,22 @@
 };
 
 &i2s0 {
-	rockchip,playback-channels = <8>;
-	rockchip,capture-channels = <8>;
-	#sound-dai-cells = <0>;
-	status = "okay";
+	status = "disabled";
 };
 
 &i2s1 {
-	rockchip,playback-channels = <2>;
-	rockchip,capture-channels = <2>;
+	rockchip,i2s-broken-burst-len;
+	rockchip,playback-channels = <8>;
+	rockchip,capture-channels = <8>;
 	#sound-dai-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2s_8ch_mclk>, <&i2s1_2ch_bus>;
 	status = "okay";
 };
 
 &i2s2 {
 	#sound-dai-cells = <0>;
-	status = "okay";
+	status = "disabled";
 };
 
 &io_domains {
@@ -889,7 +883,7 @@
 		};
 	};
 
-	i2s0 {
+	i2s1 {
 		i2s_8ch_mclk: i2s-8ch-mclk {
 			rockchip,pins = <4 0 RK_FUNC_1 &pcfg_pull_none>;
 		};
-- 
2.23.0

From 5f0bad35075a390917a57b6b0822091d399819a4 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Sat, 9 Nov 2019 21:01:38 +0100
Subject: [PATCH 09/51] rk808: Poweroff on syscore powerdown if pm_power_off
 not available

Due to the inherent limitation of supporting only a single pm_power_off
function the rk808 will now power off on syscore_powerdown if platform
power control was requested
---
 drivers/mfd/rk808.c       | 40 +++++++++++++++++++++++++++------------
 include/linux/mfd/rk808.h |  1 +
 2 files changed, 29 insertions(+), 12 deletions(-)

diff --git a/drivers/mfd/rk808.c b/drivers/mfd/rk808.c
index 050478cabc95..0212f256c16f 100644
--- a/drivers/mfd/rk808.c
+++ b/drivers/mfd/rk808.c
@@ -526,15 +526,26 @@ static void rk8xx_syscore_shutdown(void)
 	struct rk808 *rk808 = i2c_get_clientdata(rk808_i2c_client);
 	int ret;
 
-	if (system_state == SYSTEM_POWER_OFF &&
-	    (rk808->variant == RK809_ID || rk808->variant == RK817_ID)) {
-		ret = regmap_update_bits(rk808->regmap,
-					 RK817_SYS_CFG(3),
-					 RK817_SLPPIN_FUNC_MSK,
-					 SLPPIN_DN_FUN);
-		if (ret) {
-			dev_warn(&rk808_i2c_client->dev,
-				 "Cannot switch to power down function\n");
+	if (system_state == SYSTEM_POWER_OFF) {
+		switch(rk808->variant) {
+		case RK809_ID:
+		case RK817_ID:
+			ret = regmap_update_bits(rk808->regmap,
+						 RK817_SYS_CFG(3),
+						 RK817_SLPPIN_FUNC_MSK,
+						 SLPPIN_DN_FUN);
+			if (ret) {
+				dev_warn(&rk808_i2c_client->dev,
+					 "Cannot switch to power down function\n");
+			}
+			break;
+		case RK808_ID:
+			if(rk808->use_syscore_powerdown) {
+				rk808_device_shutdown();
+			}
+			break;
+		default:
+			break;
 		}
 	}
 }
@@ -617,6 +628,7 @@ static int rk808_probe(struct i2c_client *client,
 		cells = rk808s;
 		nr_cells = ARRAY_SIZE(rk808s);
 		rk808->pm_pwroff_fn = rk808_device_shutdown;
+		register_syscore_ops(&rk808_syscore_ops);
 		break;
 	case RK818_ID:
 		rk808->regmap_cfg = &rk818_regmap_config;
@@ -688,9 +700,13 @@ static int rk808_probe(struct i2c_client *client,
 
 	pm_off = of_property_read_bool(np,
 				"rockchip,system-power-controller");
-	if (pm_off && !pm_power_off) {
-		rk808_i2c_client = client;
-		pm_power_off = rk808->pm_pwroff_fn;
+	if (pm_off) {
+		if (pm_power_off) {
+			rk808->use_syscore_powerdown = true;
+		} else {
+			rk808_i2c_client = client;
+			pm_power_off = rk808->pm_pwroff_fn;
+		}
 	}
 
 	if (pm_off && !pm_power_off_prepare) {
diff --git a/include/linux/mfd/rk808.h b/include/linux/mfd/rk808.h
index a59bf323f713..289089bbe75c 100644
--- a/include/linux/mfd/rk808.h
+++ b/include/linux/mfd/rk808.h
@@ -622,5 +622,6 @@ struct rk808 {
 	const struct regmap_irq_chip	*regmap_irq_chip;
 	void				(*pm_pwroff_fn)(void);
 	void				(*pm_pwroff_prep_fn)(void);
+	bool				use_syscore_powerdown;
 };
 #endif /* __LINUX_REGULATOR_RK808_H */
-- 
2.23.0

From 055ed00304baea5c59dca7f911469ff9e526aadf Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Sat, 9 Nov 2019 21:05:09 +0100
Subject: [PATCH 10/51] arm64: Use symbolic name for cd pin on mcc controller
 on the Pinebook Pro

---
 arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index 08a6de6b3e26..af6c8da7c057 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -918,7 +918,7 @@
 	bus-width = <4>;
 	cap-mmc-highspeed;
 	cap-sd-highspeed;
-	cd-gpios = <&gpio0 7 GPIO_ACTIVE_LOW>;
+	cd-gpios = <&gpio0 RK_PA7 GPIO_ACTIVE_LOW>;
 	disable-wp;
 	sd-uhs-sdr104;
 	max-frequency = <150000000>;
-- 
2.23.0

From 3b93da1c10615769a4c1fd536780a5c6846ad5e6 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Sat, 9 Nov 2019 21:19:03 +0100
Subject: [PATCH 11/51] arm64: Add gpio controlled leds to Pinebook Pro
 devicetree

---
 .../boot/dts/rockchip/rk3399-pinebook-pro.dts | 50 +++++++++++--------
 1 file changed, 29 insertions(+), 21 deletions(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index af6c8da7c057..f8d6fb740d35 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -8,6 +8,7 @@
 #include <dt-bindings/input/linux-event-codes.h>
 #include <dt-bindings/pwm/pwm.h>
 #include <dt-bindings/usb/pd.h>
+//#include <dt-bindings/leds/common.h>
 #include "rk3399.dtsi"
 #include "rk3399-opp.dtsi"
 
@@ -42,6 +43,32 @@
 		stdout-path = "serial2:1500000n8";
 	};
 
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pwrled &slpled>;
+
+		/* Hack using active_low as inversion. A real, inverted trigger would be nicer */
+		green-led {
+			gpios = <&gpio0 RK_PB3 GPIO_ACTIVE_LOW>;
+			label = "green:disk-activity";
+//			function = LED_FUNCTION_POWER;
+			linux,default-trigger = "disk-activity";
+			default-state = "off";
+//			color = <LED_COLOR_ID_GREEN>;
+		};
+
+		red-led {
+			gpios = <&gpio0 RK_PA2 GPIO_ACTIVE_HIGH>;
+			label = "red:standby";
+//			function = LED_FUNCTION_STANDBY;
+			default-state = "off";
+			panic-indicator;
+			retain-state-suspended;
+//			color = <LED_COLOR_ID_RED>;
+		};
+	};
+
 	reserved-memory {
 		#address-cells = <2>;
 		#size-cells = <2>;
@@ -145,25 +172,6 @@
 		};
 	};
 
-	leds {
-
-		compatible = "gpio-leds";
-		pinctrl-names = "default";
-		pinctrl-0 = <&work_led_gpio>, <&diy_led_gpio>;
-
-		work-led {
-			label = "work";
-			default-state = "on";
-			gpios = <&gpio0 RK_PB3 GPIO_ACTIVE_HIGH>;
-		};
-
-		diy-led {
-			label = "diy";
-			default-state = "off";
-			gpios = <&gpio0 RK_PA2 GPIO_ACTIVE_HIGH>;
-		};
-	};
-
 	sdio_pwrseq: sdio-pwrseq {
 		compatible = "mmc-pwrseq-simple";
 		clocks = <&rk808 1>;
@@ -824,11 +832,11 @@
 	};
 
 	leds {
-		work_led_gpio: work_led-gpio {
+		pwrled: pwrled {
 			rockchip,pins = <0 RK_PB3 RK_FUNC_GPIO &pcfg_pull_none>;
 		};
 
-		diy_led_gpio: diy_led-gpio {
+		slpled: slpled {
 			rockchip,pins = <0 RK_PA2 RK_FUNC_GPIO &pcfg_pull_none>;
 		};
 	};
-- 
2.23.0

From e8d71dd2eb396ca07c411931b2be5e89f6fb6071 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Sat, 9 Nov 2019 21:20:25 +0100
Subject: [PATCH 12/51] arm64: Support lid button on the Pinebook Pro

---
 .../boot/dts/rockchip/rk3399-pinebook-pro.dts  | 18 ++++++++++++++----
 1 file changed, 14 insertions(+), 4 deletions(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index f8d6fb740d35..15816f4a5413 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -93,17 +93,24 @@
 		compatible = "gpio-keys";
 		autorepeat;
 		pinctrl-names = "default";
-		pinctrl-0 = <&pwrbtn>;
+		pinctrl-0 = <&pwrbtn &lidbtn>;
 
 		power {
-			debounce-interval = <100>;
+			debounce-interval = <20>;
 			gpios = <&gpio0 RK_PA5 GPIO_ACTIVE_LOW>;
-			label = "GPIO Key Power";
+			label = "Power";
 			linux,code = <KEY_POWER>;
 			wakeup-source;
 		};
-	};
 
+		lid {
+			debounce-interval = <20>;
+			gpios = <&gpio1 RK_PA1 GPIO_ACTIVE_LOW>;
+			label = "Lid";
+			linux,code = <SW_LID>;
+			linux,input-type = <EV_SW>;
+		};
+	};
 	
 	backlight: edp-backlight {
 		compatible = "pwm-backlight";
@@ -817,6 +824,9 @@
 		pwrbtn: pwrbtn {
 			rockchip,pins = <0 RK_PA5 RK_FUNC_GPIO &pcfg_pull_up>;
 		};
+		lidbtn: lidbtn {
+			rockchip,pins = <1 RK_PA1 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
 	};
 
 	dc-charger {
-- 
2.23.0

From f066f61a6d1ee65e0c73f7a68ef50ed9e85026af Mon Sep 17 00:00:00 2001
From: Daniel Thompson <daniel.thompson@linaro.org>
Date: Mon, 11 Nov 2019 18:52:06 +0000
Subject: [PATCH 13/51] arm64: dts: rockchip: Use lid as a wake up source for
 Pinebook Pro

Generally speaking closing the lid triggers a suspend and opening it
should cause a wakeup.

Tested using suspend-to-idle (and probably not sufficient to wake up
from a deep suspend).

Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>
---
 arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts | 1 +
 1 file changed, 1 insertion(+)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index 15816f4a5413..1ddca1cbcd4a 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -109,6 +109,7 @@
 			label = "Lid";
 			linux,code = <SW_LID>;
 			linux,input-type = <EV_SW>;
+			wakeup-source;
 		};
 	};
 	
-- 
2.23.0

From 9f56fb67911c926fefd9514329dc66c09eee8aa9 Mon Sep 17 00:00:00 2001
From: Daniel Thompson <daniel.thompson@linaro.org>
Date: Mon, 11 Nov 2019 18:52:07 +0000
Subject: [PATCH 14/51] arm64: dts: rockchip: Fix mispelled compatible string

The correct vendor prefix for Fairchild Semiconductor is fcs.

Signed-off-by: Daniel Thompson <daniel.thompson@linaro.org>
---
 arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index 1ddca1cbcd4a..6b57057fa028 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -726,7 +726,7 @@
 	status = "okay";
 
 	fusb0: fusb30x@22 {
-		compatible = "fairchild,fusb302";
+		compatible = "fcs,fusb302";
 		reg = <0x22>;
 		pinctrl-names = "default";
 		pinctrl-0 = <&fusb0_int>;
-- 
2.23.0

From 9e1cc8713fd90cdb81211ec961775f75231bb0f3 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Tue, 12 Nov 2019 19:37:11 +0100
Subject: [PATCH 15/51] arm64: Route speaker audio through audio amplifier on
 Ponebook Pro

---
 arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index 6b57057fa028..3a27da05197f 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -234,8 +234,10 @@
 			"MIC1", "Mic Jack",
 			"Headphones", "HPOL",
 			"Headphones", "HPOR",
-			"Speaker", "HPOL",
-			"Speaker", "HPOR";
+			"Speaker Amplifier INL", "HPOL",
+			"Speaker Amplifier INR", "HPOR",
+			"Speaker", "Speaker Amplifier OUTL",
+			"Speaker", "Speaker Amplifier OUTR";
 
 		simple-audio-card,hp-det-gpio = <&gpio0 RK_PB0 GPIO_ACTIVE_HIGH>;
 		simple-audio-card,aux-devs = <&speaker_amp>;
@@ -254,6 +256,7 @@
 		compatible = "simple-audio-amplifier";
 		enable-gpios = <&gpio4 RK_PD3 GPIO_ACTIVE_HIGH>;
 		VCC-supply = <&vcc5v0_host>;
+		sound-name-prefix = "Speaker Amplifier";
 	};
 
 	fan0: pwm-fan {
-- 
2.23.0

From 8d7fb2d344169d60f18a1cb393c0e539223cc5a8 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Tue, 19 Nov 2019 16:08:48 +0100
Subject: [PATCH 16/51] cw2015: Touch up devicetree as mainline preparation

---
 drivers/power/supply/cw2015_battery.c | 74 ++++++++-------------------
 include/linux/power/cw2015_battery.h  |  4 +-
 2 files changed, 24 insertions(+), 54 deletions(-)

diff --git a/drivers/power/supply/cw2015_battery.c b/drivers/power/supply/cw2015_battery.c
index 4da65c606338..2e1a3db8eab4 100644
--- a/drivers/power/supply/cw2015_battery.c
+++ b/drivers/power/supply/cw2015_battery.c
@@ -36,6 +36,9 @@ module_param_named(dbg_level, dbg_enable, int, 0644);
 		} \
 	} while (0)
 
+
+#define PREFIX "cellwise,"
+
 static int cw_read(struct i2c_client *client, u8 reg, u8 buf[])
 {
 	return i2c_smbus_read_i2c_block_data(client, reg, 1, buf);
@@ -85,7 +88,7 @@ int cw_update_config_info(struct cw_battery *cw_bat)
 
 	reg_val |= CW2015_CONFIG_UPDATE_FLG;	/* set UPDATE_FLAG */
 	reg_val &= ~CW2015_MASK_ATHD;	/* clear ATHD */
-	reg_val |= CW2015_ATHD;	/* set CW2015_ATHD */
+	reg_val |= CW2015_ATHD(cw_bat->alert_level);	/* set CW2015_ATHD */
 	ret = cw_write(cw_bat->client, CW2015_REG_CONFIG, &reg_val);
 	if (ret < 0)
 		return ret;
@@ -100,7 +103,7 @@ int cw_update_config_info(struct cw_battery *cw_bat)
 			 "update flag for new battery info have not set..\n");
 	}
 
-	if ((reg_val & CW2015_MASK_ATHD) != CW2015_ATHD)
+	if ((reg_val & CW2015_MASK_ATHD) != CW2015_ATHD(cw_bat->alert_level))
 		dev_info(&cw_bat->client->dev, "the new CW2015_ATHD have not set..\n");
 
 	/* reset */
@@ -137,10 +140,10 @@ static int cw_init(struct cw_battery *cw_bat)
 	if (ret < 0)
 		return ret;
 
-	if ((reg_val & CW2015_MASK_ATHD) != CW2015_ATHD) {
+	if ((reg_val & CW2015_MASK_ATHD) != CW2015_ATHD(cw_bat->alert_level)) {
 		dev_info(&cw_bat->client->dev, "the new CW2015_ATHD have not set\n");
 		reg_val &= ~CW2015_MASK_ATHD;	/* clear CW2015_ATHD */
-		reg_val |= CW2015_ATHD;	/* set CW2015_ATHD */
+		reg_val |= ~CW2015_ATHD(cw_bat->alert_level);	/* set CW2015_ATHD */
 		ret = cw_write(cw_bat->client, CW2015_REG_CONFIG, &reg_val);
 		if (ret < 0)
 			return ret;
@@ -449,8 +452,6 @@ static int cw_get_voltage(struct cw_battery *cw_bat)
 		res1 = cw_bat->plat_data.divider_res1;
 		res2 = cw_bat->plat_data.divider_res2;
 		voltage = voltage * (res1 + res2) / res2;
-	} else if (cw_bat->dual_battery) {
-		voltage = voltage * 2;
 	}
 
 	dev_dbg(&cw_bat->client->dev, "the cw201x voltage=%d,reg_val=%x %x\n",
@@ -714,51 +715,14 @@ static int cw2015_parse_dt(struct cw_battery *cw_bat)
 	u32 value;
 	int ret;
 	struct cw_bat_platform_data *data = &cw_bat->plat_data;
-	struct gpio_desc *hw_id0_io;
-	struct gpio_desc *hw_id1_io;
-	int hw_id0_val;
-	int hw_id1_val;
 
 	if (!node)
 		return -ENODEV;
 
 	memset(data, 0, sizeof(*data));
 
-	ret = of_property_read_u32(node, "hw_id_check", &value);
-	if (!ret && value) {
-		hw_id0_io = gpiod_get_optional(dev, "hw-id0", GPIOD_IN);
-		if (!hw_id0_io)
-			return -EINVAL;
-		if (IS_ERR(hw_id0_io))
-			return PTR_ERR(hw_id0_io);
-
-		hw_id0_val = gpiod_get_value(hw_id0_io);
-		gpiod_put(hw_id0_io);
-
-		hw_id1_io = gpiod_get_optional(dev, "hw-id1", GPIOD_IN);
-		if (!hw_id1_io)
-			return -EINVAL;
-		if (IS_ERR(hw_id1_io))
-			return PTR_ERR(hw_id1_io);
-
-		hw_id1_val = gpiod_get_value(hw_id1_io);
-		gpiod_put(hw_id1_io);
-
-		/*
-		 * ID1 = 0, ID0 = 1 : Battery
-		 * ID1 = 1, ID0 = 0 : Dual Battery
-		 * ID1 = 0, ID0 = 0 : Adapter
-		 */
-		if (hw_id0_val == 1 && hw_id1_val == 0)
-			cw_bat->dual_battery = false;
-		else if (hw_id0_val == 0 && hw_id1_val == 1)
-			cw_bat->dual_battery = true;
-		else
-			return -EINVAL;
-	}
-
 	/* determine the number of config info */
-	prop = of_find_property(node, "bat_config_info", &length);
+	prop = of_find_property(node, PREFIX"bat-config-info", &length);
 	if (!prop)
 		return -EINVAL;
 
@@ -771,7 +735,7 @@ static int cw2015_parse_dt(struct cw_battery *cw_bat)
 		if (!data->cw_bat_config_info)
 			return -ENOMEM;
 
-		ret = of_property_read_u32_array(node, "bat_config_info",
+		ret = of_property_read_u32_array(node, PREFIX"bat-config-info",
 						 data->cw_bat_config_info,
 						 length);
 		if (ret < 0)
@@ -781,35 +745,41 @@ static int cw2015_parse_dt(struct cw_battery *cw_bat)
 	cw_bat->bat_mode = MODE_BATTERY;
 	cw_bat->monitor_sec = CW2015_DEFAULT_MONITOR_SEC * CW2015_TIMER_MS_COUNTS;
 
-	ret = of_property_read_u32(node, "divider_res1", &value);
+	ret = of_property_read_u32(node, PREFIX"divider-res1", &value);
 	if (ret < 0)
 		value = 0;
 	data->divider_res1 = value;
 
-	ret = of_property_read_u32(node, "divider_res2", &value);
+	ret = of_property_read_u32(node, PREFIX"divider-res2", &value);
 	if (ret < 0)
 		value = 0;
 	data->divider_res2 = value;
 
-	ret = of_property_read_u32(node, "virtual_power", &value);
+	ret = of_property_read_u32(node, PREFIX"virtual-power", &value);
 	if (ret < 0)
 		value = 0;
 	cw_bat->bat_mode = value;
 
-	ret = of_property_read_u32(node, "monitor_sec", &value);
+	ret = of_property_read_u32(node, PREFIX"monitor-interval", &value);
 	if (ret < 0)
-		dev_err(dev, "monitor_sec missing!\n");
+		dev_err(dev, "monitor-interval missing!\n");
 	else
 		cw_bat->monitor_sec = value * CW2015_TIMER_MS_COUNTS;
 
-	ret = of_property_read_u32(node, "design_capacity", &value);
+	ret = of_property_read_u32(node, PREFIX"design-capacity", &value);
 	if (ret < 0) {
-		dev_err(dev, "design_capacity missing!\n");
+		dev_err(dev, "design-capacity missing!\n");
 		data->design_capacity = 2000;
 	} else {
 		data->design_capacity = value;
 	}
 
+	of_property_read_u8(node, PREFIX"alert-level", &cw_bat->alert_level);
+	if (cw_bat->alert_level > 100) {
+		dev_err(dev, "invalid alert_level, clamping to 100 %%\n");
+		cw_bat->alert_level = 100;
+	}
+
 	return 0;
 }
 #else
diff --git a/include/linux/power/cw2015_battery.h b/include/linux/power/cw2015_battery.h
index 59ad35b0c7f2..c7abd8aa0c28 100644
--- a/include/linux/power/cw2015_battery.h
+++ b/include/linux/power/cw2015_battery.h
@@ -40,7 +40,7 @@
 #define CW2015_MODE_RESTART            (0xf<<0)
 
 #define CW2015_CONFIG_UPDATE_FLG       (0x01<<1)
-#define CW2015_ATHD                    (0x00<<3)
+#define CW2015_ATHD(x)                 ((x)<<3)
 #define CW2015_MASK_ATHD               (0x1f<<3)
 #define CW2015_MASK_SOC                (0x1fff)
 
@@ -115,8 +115,8 @@ struct cw_battery {
 	u32 monitor_sec;
 	u32 bat_mode;
 	int bat_change;
-	bool dual_battery;
 	int charge_count;
+	u8 alert_level;
 };
 
 #endif
-- 
2.23.0

From 7ccd1534254728e8795ae1c86c8f7fa07dfbe814 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Tue, 19 Nov 2019 16:10:01 +0100
Subject: [PATCH 17/51] cw2015: Make cw215_battery a proper module

---
 drivers/power/supply/Kconfig          |  7 +++----
 drivers/power/supply/cw2015_battery.c | 27 +++++++++++++++++++++++----
 2 files changed, 26 insertions(+), 8 deletions(-)

diff --git a/drivers/power/supply/Kconfig b/drivers/power/supply/Kconfig
index e1f4504612a3..38cf80db1930 100644
--- a/drivers/power/supply/Kconfig
+++ b/drivers/power/supply/Kconfig
@@ -117,11 +117,10 @@ config BATTERY_CPCAP
 	  phones and tablets such as droid 4.
 
 config BATTERY_CW2015
-	bool "CW2015 Battery driver"
-	default n
+	tristate "CW2015 Battery driver"
 	help
-	  If you say yes here you will get support for the battery of CW2015.
-	  This driver can give support for CW2015 Battery Interface.
+	  Say Y here to enable support for the cellwise cw2015
+	  battery fuel gauge (used in the Pinebook Pro & others)
 
 config BATTERY_DS2760
 	tristate "DS2760 battery driver (HP iPAQ & others)"
diff --git a/drivers/power/supply/cw2015_battery.c b/drivers/power/supply/cw2015_battery.c
index 2e1a3db8eab4..035c990a1a28 100644
--- a/drivers/power/supply/cw2015_battery.c
+++ b/drivers/power/supply/cw2015_battery.c
@@ -22,6 +22,7 @@
 #include <linux/platform_device.h>
 #include <linux/power_supply.h>
 #include <linux/slab.h>
+#include <linux/timekeeping.h>
 #include <linux/workqueue.h>
 
 #include <linux/power/cw2015_battery.h>
@@ -851,7 +852,7 @@ static int cw_bat_suspend(struct device *dev)
 {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct cw_battery *cw_bat = i2c_get_clientdata(client);
-	read_persistent_clock64(&cw_bat->suspend_time_before);
+	ktime_get_boottime_ts64(&cw_bat->suspend_time_before);
 	cancel_delayed_work(&cw_bat->battery_delay_work);
 	return 0;
 }
@@ -861,7 +862,7 @@ static int cw_bat_resume(struct device *dev)
 	struct i2c_client *client = to_i2c_client(dev);
 	struct cw_battery *cw_bat = i2c_get_clientdata(client);
 	cw_bat->suspend_resume_mark = 1;
-	read_persistent_clock64(&cw_bat->after);
+	ktime_get_boottime_ts64(&cw_bat->after);
 	cw_bat->after = timespec64_sub(cw_bat->after,
 				     cw_bat->suspend_time_before);
 	queue_delayed_work(cw_bat->battery_workqueue,
@@ -885,13 +886,31 @@ static int cw_bat_remove(struct i2c_client *client)
 }
 
 static const struct i2c_device_id cw_bat_id_table[] = {
-	{"cw201x", 0},
+	{ "cw201x", 0 },
+	{ "cw2013", 0 },
+	{ "cw2015", 0 },
 	{}
 };
 
+static const struct of_device_id cw2015_of_match[] = {
+	{ .compatible = PREFIX"cw201x" },
+	{ .compatible = PREFIX"cw2013" },
+	{ .compatible = PREFIX"cw2015" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, cw2015_of_match);
+
+static const struct of_device_id max17040_of_match[] = {
+	{ .compatible = "maxim,max17040" },
+	{ .compatible = "maxim,max77836-battery" },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(of, max17040_of_match);
+
 static struct i2c_driver cw_bat_driver = {
 	.driver = {
-		.name = "cellwise,cw201x",
+		.name = PREFIX"cw201x",
 #ifdef CONFIG_PM
 		.pm = &cw_bat_pm_ops,
 #endif
-- 
2.23.0

From c78462e90384945d43590dba60d42e44cd8511e3 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Tue, 19 Nov 2019 16:10:26 +0100
Subject: [PATCH 18/51] cw2015: Print of -> class fallback message only in
 debug mode

---
 drivers/power/supply/cw2015_battery.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/power/supply/cw2015_battery.c b/drivers/power/supply/cw2015_battery.c
index 035c990a1a28..2bd7b49984c7 100644
--- a/drivers/power/supply/cw2015_battery.c
+++ b/drivers/power/supply/cw2015_battery.c
@@ -238,7 +238,7 @@ static int get_charge_state(struct cw_battery *cw_bat)
 	struct device_node* supply_of;
 	struct device *cw_dev = &cw_bat->client->dev;
 	if (!cw_dev->of_node) {
-		dev_info(cw_dev, "Charger does not have an of node, scanning all supplies\n");
+		dev_dbg(cw_dev, "Charger does not have an of node, scanning all supplies\n");
 #endif
 		return !!class_for_each_device(power_supply_class, NULL, cw_dev, check_charger_online);
 #ifdef CONFIG_OF
-- 
2.23.0

From 3ef775dd7a0021ff798d21339c0ca7ac61d83c43 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Tue, 19 Nov 2019 16:11:10 +0100
Subject: [PATCH 19/51] cw2015: Rename battery to cw2015-battery

---
 drivers/power/supply/cw2015_battery.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/power/supply/cw2015_battery.c b/drivers/power/supply/cw2015_battery.c
index 2bd7b49984c7..4fe85bba7a8e 100644
--- a/drivers/power/supply/cw2015_battery.c
+++ b/drivers/power/supply/cw2015_battery.c
@@ -699,7 +699,7 @@ static enum power_supply_property cw_battery_properties[] = {
 };
 
 static const struct power_supply_desc cw2015_bat_desc = {
-	.name		= "rk-bat",
+	.name		= "cw2015-battery",
 	.type		= POWER_SUPPLY_TYPE_BATTERY,
 	.properties	= cw_battery_properties,
 	.num_properties	= ARRAY_SIZE(cw_battery_properties),
-- 
2.23.0

From 2f0f38b4b2318578d5bd74d189599620c1cec679 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Tue, 19 Nov 2019 16:11:31 +0100
Subject: [PATCH 20/51] cw2015: Return actual error code of of probing if it
 fails

---
 drivers/power/supply/cw2015_battery.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/power/supply/cw2015_battery.c b/drivers/power/supply/cw2015_battery.c
index 4fe85bba7a8e..886566db3b4e 100644
--- a/drivers/power/supply/cw2015_battery.c
+++ b/drivers/power/supply/cw2015_battery.c
@@ -811,7 +811,7 @@ static int cw_bat_probe(struct i2c_client *client,
 	if (ret < 0) {
 		dev_err(&client->dev,
 			"failed to find cw2015 platform data\n");
-		return -1;
+		return ret;
 	}
 
 	cw_bat->capacity = 1;
-- 
2.23.0

From 7a98fd7917ff53a70ce6ee25fdfe9b4792bc74ad Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Tue, 19 Nov 2019 16:12:40 +0100
Subject: [PATCH 21/51] arm64: Adjust Pinebook Pro devicetree to changed cw2015
 driver

---
 arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index 3a27da05197f..2edc06d40875 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -751,7 +751,7 @@
 		status = "okay";
 		compatible = "cellwise,cw201x";
 		reg = <0x62>;
-		bat_config_info = <
+		cellwise,bat-config-info = <
 			0x17 0x67 0x80 0x73 0x6E 0x6C 0x6B 0x63
 			0x77 0x51 0x5C 0x58 0x50 0x4C 0x48 0x36
 			0x15 0x0C 0x0C 0x19 0x5B 0x7D 0x6F 0x69
@@ -761,9 +761,9 @@
 			0x48 0x77 0x9C 0xB3 0x80 0x52 0x94 0xCB
 			0x2F 0x00 0x64 0xA5 0xB5 0x11 0xF0 0x11
 		>;
-		monitor_sec = <5>;
-		virtual_power = <0>;
-		design_capacity = <9800>;
+		cellwise,monitor-interval = <5>;
+		cellwise,virtual-power = <0>;
+		cellwise,design-capacity = <9800>;
 		power-supplies = <&mains_charger>, <&fusb0>;
 	};
 };
-- 
2.23.0

From 90a69cafa1c4e5a10a044a5857253c56544b1c17 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Tue, 19 Nov 2019 23:21:35 +0100
Subject: [PATCH 22/51] documentation: Add cellwise cw2105 devicetree binding
 documentation

---
 .../bindings/power/supply/cw2015_battery.txt  | 37 +++++++++++++++++++
 1 file changed, 37 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/power/supply/cw2015_battery.txt

diff --git a/Documentation/devicetree/bindings/power/supply/cw2015_battery.txt b/Documentation/devicetree/bindings/power/supply/cw2015_battery.txt
new file mode 100644
index 000000000000..b3fec5c91a2b
--- /dev/null
+++ b/Documentation/devicetree/bindings/power/supply/cw2015_battery.txt
@@ -0,0 +1,37 @@
+cw2015_battery
+~~~~~~~~~~~~~~~~
+
+The cellwise CW2015 is a shuntless single/multi-cell battery fuel gauge.
+
+Required properties :
+ - compatible : "cellwise,cw2015"
+ - cellwise,bat-config-info : Binary battery info
+
+Optional properties :
+ - cellwise,monitor-interval : Measurement interval in seconds
+ - cellwise,divider-res1 : Resistance of high side voltage divider resistor
+ - cellwise,divider-res2 : Resistance of low side voltage divider resistor
+ - cellwise,virtual-power : Default to disconnected battery state (gauge in pack mode)
+ - cellwise,design-capacity : Design capacity of the battery cell in milliampere hours
+ - cellwise,alert-level : Low battery alarm level in percent
+
+Example:
+	cw2015@62 {
+		status = "okay";
+		compatible = "cellwise,cw201x";
+		reg = <0x62>;
+		cellwise,bat-config-info = <
+			0x17 0x67 0x80 0x73 0x6E 0x6C 0x6B 0x63
+			0x77 0x51 0x5C 0x58 0x50 0x4C 0x48 0x36
+			0x15 0x0C 0x0C 0x19 0x5B 0x7D 0x6F 0x69
+			0x69 0x5B 0x0C 0x29 0x20 0x40 0x52 0x59
+			0x57 0x56 0x54 0x4F 0x3B 0x1F 0x7F 0x17
+			0x06 0x1A 0x30 0x5A 0x85 0x93 0x96 0x2D
+			0x48 0x77 0x9C 0xB3 0x80 0x52 0x94 0xCB
+			0x2F 0x00 0x64 0xA5 0xB5 0x11 0xF0 0x11
+		>;
+		cellwise,monitor-interval = <5>;
+		cellwise,virtual-power;
+		cellwise,design-capacity = <9800>;
+		power-supplies = <&mains_charger>, <&usb_charger>;
+	}
-- 
2.23.0

From 9343e0ef04502b23d9891a1cc205bcf8cea8ec2a Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Tue, 19 Nov 2019 23:40:06 +0100
Subject: [PATCH 23/51] cw2015: Transform separate high/low voltage divider
 resistor values into multi value property

---
 drivers/power/supply/cw2015_battery.c | 32 +++++++++++++++++++--------
 include/linux/power/cw2015_battery.h  |  4 ++--
 2 files changed, 25 insertions(+), 11 deletions(-)

diff --git a/drivers/power/supply/cw2015_battery.c b/drivers/power/supply/cw2015_battery.c
index 886566db3b4e..e400797d1718 100644
--- a/drivers/power/supply/cw2015_battery.c
+++ b/drivers/power/supply/cw2015_battery.c
@@ -448,10 +448,10 @@ static int cw_get_voltage(struct cw_battery *cw_bat)
 
 	voltage = value16_1 * 312 / 1024;
 
-	if (cw_bat->plat_data.divider_res1 &&
-	    cw_bat->plat_data.divider_res2) {
-		res1 = cw_bat->plat_data.divider_res1;
-		res2 = cw_bat->plat_data.divider_res2;
+	if (cw_bat->plat_data.divider_high &&
+	    cw_bat->plat_data.divider_low) {
+		res1 = cw_bat->plat_data.divider_high;
+		res2 = cw_bat->plat_data.divider_low;
 		voltage = voltage * (res1 + res2) / res2;
 	}
 
@@ -746,15 +746,29 @@ static int cw2015_parse_dt(struct cw_battery *cw_bat)
 	cw_bat->bat_mode = MODE_BATTERY;
 	cw_bat->monitor_sec = CW2015_DEFAULT_MONITOR_SEC * CW2015_TIMER_MS_COUNTS;
 
-	ret = of_property_read_u32(node, PREFIX"divider-res1", &value);
-	if (ret < 0)
-		value = 0;
-	data->divider_res1 = value;
+	prop = of_find_property(node, PREFIX"voltage-divider", &length);
+	if (prop) {
+		length /= sizeof(u32);
+		if (length != 2) {
+			dev_err(dev, "Length of voltage divider array must be 2, not %u\n", length);
+			return -EINVAL;
+		}
+		ret = of_property_read_u32_index(node, PREFIX"voltage-divider", 0, &data->divider_high);
+		if (ret) {
+			dev_err(dev, "Failed to read value of high side voltage divider resistor: %d\n", ret);
+			return ret;
+		}
+		ret = of_property_read_u32_index(node, PREFIX"voltage-divider", 1, &data->divider_low);
+		if (ret) {
+			dev_err(dev, "Failed to read value of low side voltage divider resistor: %d\n", ret);
+			return ret;
+		}
+	}
 
 	ret = of_property_read_u32(node, PREFIX"divider-res2", &value);
 	if (ret < 0)
 		value = 0;
-	data->divider_res2 = value;
+	data->divider_low = value;
 
 	ret = of_property_read_u32(node, PREFIX"virtual-power", &value);
 	if (ret < 0)
diff --git a/include/linux/power/cw2015_battery.h b/include/linux/power/cw2015_battery.h
index c7abd8aa0c28..77c8ce17799f 100644
--- a/include/linux/power/cw2015_battery.h
+++ b/include/linux/power/cw2015_battery.h
@@ -87,8 +87,8 @@ enum bat_mode {
 };
 
 struct cw_bat_platform_data {
-	int divider_res1;
-	int divider_res2;
+	u32 divider_high;
+	u32 divider_low;
 	u32 *cw_bat_config_info;
 	int design_capacity;
 };
-- 
2.23.0

From 3089fcc0993f72fd39dcb27235ff645d90162bfa Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Tue, 19 Nov 2019 23:55:47 +0100
Subject: [PATCH 24/51] documentation: Update cellwise cw2015 dt binding docs
 to reflect new voltage divider specification

---
 .../devicetree/bindings/power/supply/cw2015_battery.txt     | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/Documentation/devicetree/bindings/power/supply/cw2015_battery.txt b/Documentation/devicetree/bindings/power/supply/cw2015_battery.txt
index b3fec5c91a2b..e847391268f3 100644
--- a/Documentation/devicetree/bindings/power/supply/cw2015_battery.txt
+++ b/Documentation/devicetree/bindings/power/supply/cw2015_battery.txt
@@ -5,12 +5,12 @@ The cellwise CW2015 is a shuntless single/multi-cell battery fuel gauge.
 
 Required properties :
  - compatible : "cellwise,cw2015"
- - cellwise,bat-config-info : Binary battery info
+ - cellwise,bat-config-info : Binary battery info blob
 
 Optional properties :
  - cellwise,monitor-interval : Measurement interval in seconds
- - cellwise,divider-res1 : Resistance of high side voltage divider resistor
- - cellwise,divider-res2 : Resistance of low side voltage divider resistor
+ - cellwise,voltage-divider : Voltage divider for multi-cell packs,
+   specified as two integer values <high side>, <low side> in ohms.
  - cellwise,virtual-power : Default to disconnected battery state (gauge in pack mode)
  - cellwise,design-capacity : Design capacity of the battery cell in milliampere hours
  - cellwise,alert-level : Low battery alarm level in percent
-- 
2.23.0

From 066ce9c4c4b194bde30c75aa068026680afaf582 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Sat, 23 Nov 2019 17:17:27 +0100
Subject: [PATCH 25/51] mmc/core: pwrseq-simple: Power off on shutdown

Hack to ensure power sequencing on SDIO devices
---
 drivers/mmc/core/pwrseq_simple.c | 19 ++++++++++++++++---
 1 file changed, 16 insertions(+), 3 deletions(-)

diff --git a/drivers/mmc/core/pwrseq_simple.c b/drivers/mmc/core/pwrseq_simple.c
index ea4d3670560e..38fe7e29aba6 100644
--- a/drivers/mmc/core/pwrseq_simple.c
+++ b/drivers/mmc/core/pwrseq_simple.c
@@ -80,10 +80,8 @@ static void mmc_pwrseq_simple_post_power_on(struct mmc_host *host)
 		msleep(pwrseq->post_power_on_delay_ms);
 }
 
-static void mmc_pwrseq_simple_power_off(struct mmc_host *host)
+static void __mmc_pwrseq_simple_power_off(struct mmc_pwrseq_simple *pwrseq)
 {
-	struct mmc_pwrseq_simple *pwrseq = to_pwrseq_simple(host->pwrseq);
-
 	mmc_pwrseq_simple_set_gpios_value(pwrseq, 1);
 
 	if (pwrseq->power_off_delay_us)
@@ -96,6 +94,12 @@ static void mmc_pwrseq_simple_power_off(struct mmc_host *host)
 	}
 }
 
+static void mmc_pwrseq_simple_power_off(struct mmc_host *host)
+{
+	struct mmc_pwrseq_simple *pwrseq = to_pwrseq_simple(host->pwrseq);
+	__mmc_pwrseq_simple_power_off(pwrseq);
+}
+
 static const struct mmc_pwrseq_ops mmc_pwrseq_simple_ops = {
 	.pre_power_on = mmc_pwrseq_simple_pre_power_on,
 	.post_power_on = mmc_pwrseq_simple_post_power_on,
@@ -151,9 +155,18 @@ static int mmc_pwrseq_simple_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static void mmc_pwrseq_simple_shutdown(struct platform_device *pdev)
+{
+	struct mmc_pwrseq_simple *pwrseq = platform_get_drvdata(pdev);
+
+	dev_info(&pdev->dev, "Turning off mmc\n");
+	__mmc_pwrseq_simple_power_off(pwrseq);
+}
+
 static struct platform_driver mmc_pwrseq_simple_driver = {
 	.probe = mmc_pwrseq_simple_probe,
 	.remove = mmc_pwrseq_simple_remove,
+	.shutdown = mmc_pwrseq_simple_shutdown,
 	.driver = {
 		.name = "pwrseq_simple",
 		.of_match_table = mmc_pwrseq_simple_of_match,
-- 
2.23.0

From 290ee1ff8c22986fde8dd20dd2e60f59d7bf87fa Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Sat, 23 Nov 2019 23:12:23 +0100
Subject: [PATCH 26/51] arm64: Add longer powerup/powerdown delays to SDIO WiFi
 power sequence

---
 arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index 2edc06d40875..7b91b3320dac 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -186,6 +186,8 @@
 		clock-names = "ext_clock";
 		pinctrl-names = "default";
 		pinctrl-0 = <&wifi_enable_h>;
+		power-off-delay-us = <500000>;
+		post-power-on-delay-ms = <100>;
 
 		/*
 		 * On the module itself this is one of these (depending
-- 
2.23.0

From 2849a47c5cb7fe8e74c8c78d4aad63dacd92c775 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Sat, 23 Nov 2019 23:14:07 +0100
Subject: [PATCH 27/51] arm64: Remove superfluous devicetree properties from
 Pinebook Pro

---
 .../boot/dts/rockchip/rk3399-pinebook-pro.dts | 38 -------------------
 1 file changed, 38 deletions(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index 7b91b3320dac..89e19531b4b9 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -261,15 +261,6 @@
 		sound-name-prefix = "Speaker Amplifier";
 	};
 
-	fan0: pwm-fan {
-		compatible = "pwm-fan";
-		pwms = <&pwm1 0 10000 0>;
-		cooling-min-state = <0>;
-		cooling-max-state = <3>;
-		#cooling-cells = <2>;
-		cooling-levels = <0 102 170 230>;
-	};
-
 	/* switched by pmic_sleep */
 	vcc1v8_s3: vcca1v8_s3: vcc1v8-s3 {
 		compatible = "regulator-fixed";
@@ -367,32 +358,7 @@
 		extcon = <&fusb0>;
 	};
 };
-/*
-&display_subsystem {
-	status = "okay";
-
-	ports = <&vopb_out>, <&vopl_out>;
-	logo-memory-region = <&drm_logo>;
-
-	route {
-		route_dp: route-dp {
-			logo,uboot = "logo.bmp";
-			logo,kernel = "logo_kernel.bmp";
-			logo,mode = "center";
-			charge_logo,mode = "center";
-			connect = <&vopl_out_dp>;
-		};
 
-		route_edp: route-edp {
-			logo,uboot = "logo.bmp";
-			logo,kernel = "logo_kernel.bmp";
-			logo,mode = "center";
-			charge_logo,mode = "center";
-			connect = <&vopb_out_edp>;
-		};
-	};
-};
-*/
 &edp {
 	status = "okay";
 	pinctrl-names = "default";
@@ -925,10 +891,6 @@
 	status = "okay";
 };
 
-&pwm1 {
-	status = "okay";
-};
-
 &pwm2 {
 	status = "okay";
 };
-- 
2.23.0

From 0f29bdf5f1318dc5d93fac46c85f493a71cb6132 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Mon, 25 Nov 2019 21:05:04 +0100
Subject: [PATCH 28/51] drivers/power: cw2015_battery: Add design
 charge_full_design_property

Thanks to schaecsn for this suggestion
---
 drivers/power/supply/cw2015_battery.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/drivers/power/supply/cw2015_battery.c b/drivers/power/supply/cw2015_battery.c
index e400797d1718..3703ba3b96d0 100644
--- a/drivers/power/supply/cw2015_battery.c
+++ b/drivers/power/supply/cw2015_battery.c
@@ -655,6 +655,7 @@ static int cw_battery_get_property(struct power_supply *psy,
 		break;
 
 	case POWER_SUPPLY_PROP_CHARGE_FULL:
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
 		val->intval = cw_bat->plat_data.design_capacity * 1000;
 		break;
 
@@ -694,6 +695,7 @@ static enum power_supply_property cw_battery_properties[] = {
 	POWER_SUPPLY_PROP_TECHNOLOGY,
 	POWER_SUPPLY_PROP_CHARGE_COUNTER,
 	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
 	POWER_SUPPLY_PROP_TEMP,
 	POWER_SUPPLY_PROP_CURRENT_NOW,
 };
-- 
2.23.0

From 9e347f79acbda4c6c7d57d5ce46da5f6c2a71219 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Tue, 26 Nov 2019 13:57:44 +0100
Subject: [PATCH 29/51] arm64/dts: Remove fusb302 extcon for tcphy and usb

While this does not reflect the hardware it does at least make the usbc port
usable for normal USB operation
---
 arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index 89e19531b4b9..7f46b32c59b8 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -941,7 +941,7 @@
 };
 
 &tcphy0 {
-	extcon = <&fusb0>;
+//	extcon = <&fusb0>;
 	status = "okay";
 };
 
@@ -1010,7 +1010,7 @@
 };
 
 &usbdrd3_0 {
-	extcon = <&fusb0>;
+//	extcon = <&fusb0>;
 	status = "okay";
 };
 
-- 
2.23.0

From 28a0d385917e8f0612dccff387b416045dafc1d0 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Tue, 26 Nov 2019 19:20:34 +0100
Subject: [PATCH 30/51] usb/typec: tcpm: Add generic extcon for tcpm-enabled
 devices

Incomplete and hacky
---
 drivers/usb/typec/tcpm/tcpm.c | 77 +++++++++++++++++++++++++++++++++--
 1 file changed, 74 insertions(+), 3 deletions(-)

diff --git a/drivers/usb/typec/tcpm/tcpm.c b/drivers/usb/typec/tcpm/tcpm.c
index 5f61d9977a15..c89d8f1c2c34 100644
--- a/drivers/usb/typec/tcpm/tcpm.c
+++ b/drivers/usb/typec/tcpm/tcpm.c
@@ -8,6 +8,7 @@
 #include <linux/completion.h>
 #include <linux/debugfs.h>
 #include <linux/device.h>
+#include <linux/extcon-provider.h>
 #include <linux/jiffies.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
@@ -322,6 +323,12 @@ struct tcpm_port {
 	/* port belongs to a self powered device */
 	bool self_powered;
 
+
+#ifdef CONFIG_EXTCON
+	struct extcon_dev *extcon;
+	unsigned int *extcon_cables;
+#endif
+
 #ifdef CONFIG_DEBUG_FS
 	struct dentry *dentry;
 	struct mutex logbuffer_lock;	/* log buffer access lock */
@@ -608,6 +615,33 @@ static void tcpm_debugfs_exit(const struct tcpm_port *port) { }
 
 #endif
 
+static void tcpm_update_extcon_data(struct tcpm_port *port, bool attached) {
+#ifdef CONFIG_EXTCON
+	unsigned int *capability = port->extcon_cables;
+	if (port->data_role == TYPEC_HOST) {
+		extcon_set_state(port->extcon, EXTCON_USB, false);
+		extcon_set_state(port->extcon, EXTCON_USB_HOST, attached);
+	} else {
+		extcon_set_state(port->extcon, EXTCON_USB, true);
+		extcon_set_state(port->extcon, EXTCON_USB_HOST, attached);
+	}
+	while(*capability != EXTCON_NONE) {
+		union extcon_property_value val;
+		val.intval = true;
+		extcon_set_property(port->extcon, *capability, EXTCON_PROP_USB_SS, val);
+		val.intval = (port->polarity == TYPEC_POLARITY_CC2);
+		extcon_set_property(port->extcon, *capability,
+			EXTCON_PROP_USB_TYPEC_POLARITY, val);
+		extcon_sync(port->extcon, *capability);
+		capability++;
+	}
+	tcpm_log(port, "Extcon update (%s): %s, %s",
+		attached ? "attached" : "detached",
+		port->data_role == TYPEC_HOST ? "host" : "device",
+		port->polarity == TYPEC_POLARITY_CC1 ? "normal" : "flipped");
+#endif
+}
+
 static int tcpm_pd_transmit(struct tcpm_port *port,
 			    enum tcpm_transmit_type type,
 			    const struct pd_message *msg)
@@ -797,10 +831,11 @@ static int tcpm_set_roles(struct tcpm_port *port, bool attached,
 	else
 		orientation = TYPEC_ORIENTATION_REVERSE;
 
-	if (data == TYPEC_HOST)
+	if (data == TYPEC_HOST) {
 		usb_role = USB_ROLE_HOST;
-	else
+	} else {
 		usb_role = USB_ROLE_DEVICE;
+	}
 
 	ret = tcpm_mux_set(port, TYPEC_STATE_USB, usb_role, orientation);
 	if (ret < 0)
@@ -815,6 +850,8 @@ static int tcpm_set_roles(struct tcpm_port *port, bool attached,
 	typec_set_data_role(port->typec_port, data);
 	typec_set_pwr_role(port->typec_port, role);
 
+	tcpm_update_extcon_data(port, attached);
+
 	return 0;
 }
 
@@ -1025,7 +1062,7 @@ static void svdm_consume_modes(struct tcpm_port *port, const __le32 *payload,
 		paltmode->mode = i;
 		paltmode->vdo = le32_to_cpu(payload[i]);
 
-		tcpm_log(port, " Alternate mode %d: SVID 0x%04x, VDO %d: 0x%08x",
+		tcpm_log(port, "Alternate mode %d: SVID 0x%04x, VDO %d: 0x%08x",
 			 pmdata->altmodes, paltmode->svid,
 			 paltmode->mode, paltmode->vdo);
 
@@ -2730,6 +2767,8 @@ static void tcpm_detach(struct tcpm_port *port)
 		port->hard_reset_count = 0;
 
 	tcpm_reset_port(port);
+
+	tcpm_update_extcon_data(port, false);
 }
 
 static void tcpm_src_detach(struct tcpm_port *port)
@@ -4396,6 +4435,10 @@ static int tcpm_copy_vdos(u32 *dest_vdo, const u32 *src_vdo,
 	return nr_vdo;
 }
 
+unsigned int default_supported_cables[] = {
+	EXTCON_NONE
+};
+
 static int tcpm_fw_get_caps(struct tcpm_port *port,
 			    struct fwnode_handle *fwnode)
 {
@@ -4406,6 +4449,23 @@ static int tcpm_fw_get_caps(struct tcpm_port *port,
 	if (!fwnode)
 		return -EINVAL;
 
+#ifdef CONFIG_EXTCON
+	ret = fwnode_property_count_u32(fwnode, "extcon-cables");
+	if (ret > 0) {
+		port->extcon_cables = devm_kzalloc(port->dev, sizeof(u32) * ret, GFP_KERNEL);
+		if (!port->extcon_cables) {
+			dev_err(port->dev, "Failed to allocate memory for extcon cable types. "\
+				"Using default tyes");
+			goto extcon_default;
+		}
+		fwnode_property_read_u32_array(fwnode, "extcon-cables", port->extcon_cables, ret);
+	} else {
+extcon_default:
+		dev_info(port->dev, "No cable types defined, using default cables");
+		port->extcon_cables = default_supported_cables;
+	}
+#endif
+
 	/* USB data support is optional */
 	ret = fwnode_property_read_string(fwnode, "data-role", &cap_str);
 	if (ret == 0) {
@@ -4764,6 +4824,17 @@ struct tcpm_port *tcpm_register_port(struct device *dev, struct tcpc_dev *tcpc)
 	if (err < 0)
 		goto out_destroy_wq;
 
+#ifdef CONFIG_EXTCON
+	port->extcon = devm_extcon_dev_allocate(dev, port->extcon_cables);
+	if (IS_ERR(port->extcon)) {
+		dev_err(dev, "Failed to allocate extcon device: %ld", PTR_ERR(port->extcon));
+		goto out_destroy_wq;
+	}
+	if((err = devm_extcon_dev_register(dev, port->extcon))) {
+		dev_err(dev, "Failed to register extcon device: %d", err);
+		goto out_destroy_wq;
+	}
+#endif
 	if (!tcpc->config || !tcpc->config->try_role_hw)
 		port->try_role = port->typec_caps.prefer_role;
 	else
-- 
2.23.0

From 3d9863f1fd5cef3c230a8a69e1740c248f8ac101 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Tue, 26 Nov 2019 19:21:26 +0100
Subject: [PATCH 31/51] phy/rockchip: rockchip_typec_phy: Set phy capabilities
 on extcon port

Force capability flags on an external port attached via extcon.
---
 drivers/phy/rockchip/phy-rockchip-typec.c | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/drivers/phy/rockchip/phy-rockchip-typec.c b/drivers/phy/rockchip/phy-rockchip-typec.c
index 24563160197f..be0ce0c113c0 100644
--- a/drivers/phy/rockchip/phy-rockchip-typec.c
+++ b/drivers/phy/rockchip/phy-rockchip-typec.c
@@ -40,6 +40,7 @@
 #include <linux/clk-provider.h>
 #include <linux/delay.h>
 #include <linux/extcon.h>
+#include <linux/extcon-provider.h>
 #include <linux/io.h>
 #include <linux/iopoll.h>
 #include <linux/kernel.h>
@@ -1160,6 +1161,19 @@ static int rockchip_typec_phy_probe(struct platform_device *pdev)
 				dev_err(dev, "Invalid or missing extcon\n");
 			return PTR_ERR(tcphy->extcon);
 		}
+	} else {
+		extcon_set_property_capability(tcphy->extcon, EXTCON_USB,
+					       EXTCON_PROP_USB_SS);
+		extcon_set_property_capability(tcphy->extcon, EXTCON_USB_HOST,
+					       EXTCON_PROP_USB_SS);
+		extcon_set_property_capability(tcphy->extcon, EXTCON_DISP_DP,
+					       EXTCON_PROP_USB_SS);
+		extcon_set_property_capability(tcphy->extcon, EXTCON_USB,
+					       EXTCON_PROP_USB_TYPEC_POLARITY);
+		extcon_set_property_capability(tcphy->extcon, EXTCON_USB_HOST,
+					       EXTCON_PROP_USB_TYPEC_POLARITY);
+		extcon_set_property_capability(tcphy->extcon, EXTCON_DISP_DP,
+					       EXTCON_PROP_USB_TYPEC_POLARITY);
 	}
 
 	pm_runtime_enable(dev);
-- 
2.23.0

From f26186175e8fda28923a06b1d98e70f5bb2f2f2c Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Tue, 26 Nov 2019 19:24:30 +0100
Subject: [PATCH 32/51] arm64/dts: Enable USB functionality of USB-C port of
 Pinebook Pro

---
 arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index 7f46b32c59b8..e05f46b24c96 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -712,6 +712,7 @@
 			source-pdos = <PDO_FIXED(5000, 1400, PDO_FIXED_USB_COMM)>;
 			sink-pdos = <PDO_FIXED(5000, 2500, PDO_FIXED_USB_COMM)>;
 			op-sink-microwatt = <1000000>;
+			extcon-cables = <1 2 5 6 9 10 12 44>;
 		};
 	};
 
@@ -941,7 +942,7 @@
 };
 
 &tcphy0 {
-//	extcon = <&fusb0>;
+	extcon = <&fusb0>;
 	status = "okay";
 };
 
@@ -1010,13 +1011,12 @@
 };
 
 &usbdrd3_0 {
-//	extcon = <&fusb0>;
 	status = "okay";
 };
 
 &usbdrd_dwc3_0 {
 	status = "okay";
-	dr_mode = "otg";
+	dr_mode = "host";
 };
 
 &usbdrd3_1 {
-- 
2.23.0

From 6a3df434125c6caa9711723037b244badfa43e49 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Fri, 29 Nov 2019 18:05:38 +0100
Subject: [PATCH 33/51] usb/typec: bus: Catch invalid attention calls

Had one or two crashes during dev. Needs further investigation
---
 drivers/usb/typec/bus.c | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/drivers/usb/typec/bus.c b/drivers/usb/typec/bus.c
index 74cb3c2ecb34..be528066b46a 100644
--- a/drivers/usb/typec/bus.c
+++ b/drivers/usb/typec/bus.c
@@ -148,8 +148,14 @@ EXPORT_SYMBOL_GPL(typec_altmode_exit);
  */
 void typec_altmode_attention(struct typec_altmode *adev, u32 vdo)
 {
-	struct typec_altmode *pdev = &to_altmode(adev)->partner->adev;
+	struct typec_altmode *pdev;
+	WARN_ONCE(!adev, "typec bus attention: adev is NULL!");
+	WARN_ONCE(!to_altmode(adev)->partner, "typec bus attention: partner is NULL!");
+	if(!adev || !to_altmode(adev)->partner) {
+		return;
+	}
 
+	pdev = &to_altmode(adev)->partner->adev;
 	if (pdev->ops && pdev->ops->attention)
 		pdev->ops->attention(pdev, vdo);
 }
-- 
2.23.0

From ed276dbfb5ef09d9bec2116470acffdfc6097879 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Fri, 29 Nov 2019 18:15:16 +0100
Subject: [PATCH 34/51] usb/typec: displayport: Add extcon support

This patch adds extcon support to the displayport alternate mode.
This patch is not perfect. It does not clear the extcon DP
flag correctly once the DP altmode capable device is unplugged.
Needs work!
---
 drivers/usb/typec/altmodes/displayport.c | 51 ++++++++++++++++++++++--
 1 file changed, 48 insertions(+), 3 deletions(-)

diff --git a/drivers/usb/typec/altmodes/displayport.c b/drivers/usb/typec/altmodes/displayport.c
index 4092248a5936..bae1cbc7f101 100644
--- a/drivers/usb/typec/altmodes/displayport.c
+++ b/drivers/usb/typec/altmodes/displayport.c
@@ -9,6 +9,8 @@
  */
 
 #include <linux/delay.h>
+#include <linux/extcon.h>
+#include <linux/extcon-provider.h>
 #include <linux/mutex.h>
 #include <linux/module.h>
 #include <linux/usb/pd_vdo.h>
@@ -134,15 +136,49 @@ static int dp_altmode_status_update(struct dp_altmode *dp)
 	return ret;
 }
 
+static void dp_altmode_update_extcon(struct dp_altmode *dp, bool disconnect) {
+	const struct device *dev = &dp->port->dev;
+	struct extcon_dev* edev = NULL;
+
+	while (dev) {
+		edev = extcon_find_edev_by_node(dev->of_node);
+		if(!IS_ERR(edev)) {
+			break;
+		}
+		dev = dev->parent;
+	}
+
+	if (IS_ERR_OR_NULL(edev)) {
+		return;
+	}
+
+	if (disconnect || !dp->data.conf) {
+		extcon_set_state_sync(edev, EXTCON_DISP_DP, false);
+	} else {
+		extcon_set_state_sync(edev, EXTCON_DISP_DP, true);
+		if (DP_CONF_GET_PIN_ASSIGN(dp->data.conf) & DP_PIN_ASSIGN_MULTI_FUNC_MASK) {
+			extcon_set_state_sync(edev, EXTCON_USB_HOST, true);
+		} else {
+			extcon_set_state_sync(edev, EXTCON_USB_HOST, false);
+		}
+		extcon_set_state_sync(edev, EXTCON_USB, false);
+	}
+
+}
+
 static int dp_altmode_configured(struct dp_altmode *dp)
 {
 	int ret;
 
 	sysfs_notify(&dp->alt->dev.kobj, "displayport", "configuration");
 
-	if (!dp->data.conf)
+	if (!dp->data.conf) {
+		dp_altmode_update_extcon(dp, true);
 		return typec_altmode_notify(dp->alt, TYPEC_STATE_USB,
 					    &dp->data);
+	}
+
+	dp_altmode_update_extcon(dp, false);
 
 	ret = dp_altmode_notify(dp);
 	if (ret)
@@ -169,9 +205,11 @@ static int dp_altmode_configure_vdm(struct dp_altmode *dp, u32 conf)
 	if (ret) {
 		if (DP_CONF_GET_PIN_ASSIGN(dp->data.conf))
 			dp_altmode_notify(dp);
-		else
+		else {
+			dp_altmode_update_extcon(dp, true);
 			typec_altmode_notify(dp->alt, TYPEC_STATE_USB,
 					     &dp->data);
+		}
 	}
 
 	return ret;
@@ -210,6 +248,8 @@ static void dp_altmode_work(struct work_struct *work)
 	case DP_STATE_EXIT:
 		if (typec_altmode_exit(dp->alt))
 			dev_err(&dp->alt->dev, "Exit Mode Failed!\n");
+		else
+			dp_altmode_update_extcon(dp, true);
 		break;
 	default:
 		break;
@@ -519,8 +559,13 @@ int dp_altmode_probe(struct typec_altmode *alt)
 	if (!(DP_CAP_DFP_D_PIN_ASSIGN(port->vdo) &
 	      DP_CAP_UFP_D_PIN_ASSIGN(alt->vdo)) &&
 	    !(DP_CAP_UFP_D_PIN_ASSIGN(port->vdo) &
-	      DP_CAP_DFP_D_PIN_ASSIGN(alt->vdo)))
+	      DP_CAP_DFP_D_PIN_ASSIGN(alt->vdo))) {
+		dev_err(&alt->dev, "No compatible pin configuration found:"\
+			"%04lx -> %04lx, %04lx <- %04lx",
+			DP_CAP_DFP_D_PIN_ASSIGN(port->vdo), DP_CAP_UFP_D_PIN_ASSIGN(alt->vdo),
+			DP_CAP_UFP_D_PIN_ASSIGN(port->vdo), DP_CAP_DFP_D_PIN_ASSIGN(alt->vdo));
 		return -ENODEV;
+	}
 
 	ret = sysfs_create_group(&alt->dev.kobj, &dp_altmode_group);
 	if (ret)
-- 
2.23.0

From 12448bf1e6068440390f8aefc14b6e240d9036a9 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Fri, 29 Nov 2019 18:18:23 +0100
Subject: [PATCH 35/51] arm64/dts: Enable CDN DP controller on the Pinebook Pro

---
 arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index e05f46b24c96..9cedbcb05839 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -379,6 +379,11 @@
 	};
 };
 
+&cdn_dp {
+	status = "okay";
+	extcon = <&fusb0>;
+};
+
 &cpu_l0 {
 	cpu-supply = <&vdd_cpu_l>;
 };
-- 
2.23.0

From d91fd06136eb5aef21875a81d4e7315e7f9eb557 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Fri, 29 Nov 2019 18:19:30 +0100
Subject: [PATCH 36/51] arm64/dts: Add DP altmode to USB type C port on the
 Pinebook Pro

Advertises support for pin configurations C, D and E
---
 arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts | 1 +
 1 file changed, 1 insertion(+)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index 9cedbcb05839..19e4d8d2d186 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -718,6 +718,7 @@
 			sink-pdos = <PDO_FIXED(5000, 2500, PDO_FIXED_USB_COMM)>;
 			op-sink-microwatt = <1000000>;
 			extcon-cables = <1 2 5 6 9 10 12 44>;
+			typec-altmodes = <0xff01 1 0x001c0000 1>;
 		};
 	};
 
-- 
2.23.0

From 0f678d304c6d5b58014761c570e39c1ff238ec2e Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Sat, 30 Nov 2019 14:42:00 +0100
Subject: [PATCH 37/51] usb/typec: tcpm: Set extcon cable states to false on
 partner disconnect

---
 drivers/usb/typec/tcpm/tcpm.c | 17 +++++++++++------
 1 file changed, 11 insertions(+), 6 deletions(-)

diff --git a/drivers/usb/typec/tcpm/tcpm.c b/drivers/usb/typec/tcpm/tcpm.c
index c89d8f1c2c34..0e7c1508ebb1 100644
--- a/drivers/usb/typec/tcpm/tcpm.c
+++ b/drivers/usb/typec/tcpm/tcpm.c
@@ -625,13 +625,17 @@ static void tcpm_update_extcon_data(struct tcpm_port *port, bool attached) {
 		extcon_set_state(port->extcon, EXTCON_USB, true);
 		extcon_set_state(port->extcon, EXTCON_USB_HOST, attached);
 	}
-	while(*capability != EXTCON_NONE) {
+	while (*capability != EXTCON_NONE) {
 		union extcon_property_value val;
-		val.intval = true;
-		extcon_set_property(port->extcon, *capability, EXTCON_PROP_USB_SS, val);
-		val.intval = (port->polarity == TYPEC_POLARITY_CC2);
-		extcon_set_property(port->extcon, *capability,
-			EXTCON_PROP_USB_TYPEC_POLARITY, val);
+		if (attached) {
+			val.intval = true;
+			extcon_set_property(port->extcon, *capability, EXTCON_PROP_USB_SS, val);
+			val.intval = (port->polarity == TYPEC_POLARITY_CC2);
+			extcon_set_property(port->extcon, *capability,
+				EXTCON_PROP_USB_TYPEC_POLARITY, val);
+		} else {
+			extcon_set_state(port->extcon, *capability, false);
+		}
 		extcon_sync(port->extcon, *capability);
 		capability++;
 	}
@@ -2710,6 +2714,7 @@ static int tcpm_src_attach(struct tcpm_port *port)
 static void tcpm_typec_disconnect(struct tcpm_port *port)
 {
 	if (port->connected) {
+		tcpm_update_extcon_data(port, false);
 		typec_unregister_partner(port->partner);
 		port->partner = NULL;
 		port->connected = false;
-- 
2.23.0

From 67427fabee17ea770fcf86c517433e654f9a3a67 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Sat, 30 Nov 2019 14:59:28 +0100
Subject: [PATCH 38/51] usb/typec: tcpm: Don't set EXTCON_PROP_USB_SS

---
 drivers/usb/typec/tcpm/tcpm.c | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/drivers/usb/typec/tcpm/tcpm.c b/drivers/usb/typec/tcpm/tcpm.c
index 0e7c1508ebb1..78c93badea24 100644
--- a/drivers/usb/typec/tcpm/tcpm.c
+++ b/drivers/usb/typec/tcpm/tcpm.c
@@ -626,10 +626,8 @@ static void tcpm_update_extcon_data(struct tcpm_port *port, bool attached) {
 		extcon_set_state(port->extcon, EXTCON_USB_HOST, attached);
 	}
 	while (*capability != EXTCON_NONE) {
-		union extcon_property_value val;
 		if (attached) {
-			val.intval = true;
-			extcon_set_property(port->extcon, *capability, EXTCON_PROP_USB_SS, val);
+			union extcon_property_value val;
 			val.intval = (port->polarity == TYPEC_POLARITY_CC2);
 			extcon_set_property(port->extcon, *capability,
 				EXTCON_PROP_USB_TYPEC_POLARITY, val);
-- 
2.23.0

From 82d456cbdc964511b0e7c273c9576a74e54311d1 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Sat, 30 Nov 2019 15:00:29 +0100
Subject: [PATCH 39/51] phy/rockchip: rockchip_typec_phy: Set
 EXTCON_PROP_USB_SS on extcon

Set EXTCON_PROP_USB_SS for states EXTCON_USB, EXTCON_USB_HOST and EXTCON_DISP_DP
---
 drivers/phy/rockchip/phy-rockchip-typec.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/drivers/phy/rockchip/phy-rockchip-typec.c b/drivers/phy/rockchip/phy-rockchip-typec.c
index be0ce0c113c0..10551719ee1b 100644
--- a/drivers/phy/rockchip/phy-rockchip-typec.c
+++ b/drivers/phy/rockchip/phy-rockchip-typec.c
@@ -1162,6 +1162,7 @@ static int rockchip_typec_phy_probe(struct platform_device *pdev)
 			return PTR_ERR(tcphy->extcon);
 		}
 	} else {
+		union extcon_property_value extcon_true = { .intval = true };
 		extcon_set_property_capability(tcphy->extcon, EXTCON_USB,
 					       EXTCON_PROP_USB_SS);
 		extcon_set_property_capability(tcphy->extcon, EXTCON_USB_HOST,
@@ -1174,6 +1175,15 @@ static int rockchip_typec_phy_probe(struct platform_device *pdev)
 					       EXTCON_PROP_USB_TYPEC_POLARITY);
 		extcon_set_property_capability(tcphy->extcon, EXTCON_DISP_DP,
 					       EXTCON_PROP_USB_TYPEC_POLARITY);
+		extcon_set_property(tcphy->extcon, EXTCON_USB, EXTCON_PROP_USB_SS,
+				    extcon_true);
+		extcon_set_property(tcphy->extcon, EXTCON_USB_HOST, EXTCON_PROP_USB_SS,
+				    extcon_true);
+		extcon_set_property(tcphy->extcon, EXTCON_DISP_DP, EXTCON_PROP_USB_SS,
+				    extcon_true);
+		extcon_sync(tcphy->extcon, EXTCON_USB);
+		extcon_sync(tcphy->extcon, EXTCON_USB_HOST);
+		extcon_sync(tcphy->extcon, EXTCON_DISP_DP);
 	}
 
 	pm_runtime_enable(dev);
-- 
2.23.0

From 47e5f8a4a3dd081353d9cac6880ab28a20a18dc2 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Tue, 3 Dec 2019 15:52:18 +0100
Subject: [PATCH 40/51] phy/rockchip: rockchip_typec_phy: Remove setting of
 EXTCON_PROP_USB_SS property

---
 drivers/phy/rockchip/phy-rockchip-typec.c | 7 -------
 1 file changed, 7 deletions(-)

diff --git a/drivers/phy/rockchip/phy-rockchip-typec.c b/drivers/phy/rockchip/phy-rockchip-typec.c
index 10551719ee1b..f5b497b4b97e 100644
--- a/drivers/phy/rockchip/phy-rockchip-typec.c
+++ b/drivers/phy/rockchip/phy-rockchip-typec.c
@@ -1162,7 +1162,6 @@ static int rockchip_typec_phy_probe(struct platform_device *pdev)
 			return PTR_ERR(tcphy->extcon);
 		}
 	} else {
-		union extcon_property_value extcon_true = { .intval = true };
 		extcon_set_property_capability(tcphy->extcon, EXTCON_USB,
 					       EXTCON_PROP_USB_SS);
 		extcon_set_property_capability(tcphy->extcon, EXTCON_USB_HOST,
@@ -1175,12 +1174,6 @@ static int rockchip_typec_phy_probe(struct platform_device *pdev)
 					       EXTCON_PROP_USB_TYPEC_POLARITY);
 		extcon_set_property_capability(tcphy->extcon, EXTCON_DISP_DP,
 					       EXTCON_PROP_USB_TYPEC_POLARITY);
-		extcon_set_property(tcphy->extcon, EXTCON_USB, EXTCON_PROP_USB_SS,
-				    extcon_true);
-		extcon_set_property(tcphy->extcon, EXTCON_USB_HOST, EXTCON_PROP_USB_SS,
-				    extcon_true);
-		extcon_set_property(tcphy->extcon, EXTCON_DISP_DP, EXTCON_PROP_USB_SS,
-				    extcon_true);
 		extcon_sync(tcphy->extcon, EXTCON_USB);
 		extcon_sync(tcphy->extcon, EXTCON_USB_HOST);
 		extcon_sync(tcphy->extcon, EXTCON_DISP_DP);
-- 
2.23.0

From 6139c33e6966a326f34c5b4535a639685cde3c67 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Tue, 3 Dec 2019 15:53:52 +0100
Subject: [PATCH 41/51] usb/typec: altmodes: typec_displayport: Add extcon USB
 SS property setting

Set property EXTCON_PROP_USB_SS on extcon device when typec port is in
multi function mode
---
 drivers/usb/typec/altmodes/displayport.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/drivers/usb/typec/altmodes/displayport.c b/drivers/usb/typec/altmodes/displayport.c
index bae1cbc7f101..20d5a935e1fa 100644
--- a/drivers/usb/typec/altmodes/displayport.c
+++ b/drivers/usb/typec/altmodes/displayport.c
@@ -155,12 +155,16 @@ static void dp_altmode_update_extcon(struct dp_altmode *dp, bool disconnect) {
 	if (disconnect || !dp->data.conf) {
 		extcon_set_state_sync(edev, EXTCON_DISP_DP, false);
 	} else {
-		extcon_set_state_sync(edev, EXTCON_DISP_DP, true);
+		union extcon_property_value extcon_true = { .intval = true };
+		extcon_set_state(edev, EXTCON_DISP_DP, true);
 		if (DP_CONF_GET_PIN_ASSIGN(dp->data.conf) & DP_PIN_ASSIGN_MULTI_FUNC_MASK) {
 			extcon_set_state_sync(edev, EXTCON_USB_HOST, true);
+			extcon_set_property(edev, EXTCON_DISP_DP, EXTCON_PROP_USB_SS,
+						 extcon_true);
 		} else {
 			extcon_set_state_sync(edev, EXTCON_USB_HOST, false);
 		}
+		extcon_sync(edev, EXTCON_DISP_DP);
 		extcon_set_state_sync(edev, EXTCON_USB, false);
 	}
 
-- 
2.23.0

From a347327b2d62b610254a4013dbbb3cd3ee8e52f7 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Wed, 11 Dec 2019 12:20:24 +0100
Subject: [PATCH 42/51] power: supply: cw2015: add SPDX license identifier

---
 drivers/power/supply/cw2015_battery.c | 5 +----
 1 file changed, 1 insertion(+), 4 deletions(-)

diff --git a/drivers/power/supply/cw2015_battery.c b/drivers/power/supply/cw2015_battery.c
index 3703ba3b96d0..584d0b612b4b 100644
--- a/drivers/power/supply/cw2015_battery.c
+++ b/drivers/power/supply/cw2015_battery.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Fuel gauge driver for CellWise 2013 / 2015
  *
@@ -7,10 +8,6 @@
  * Authors: xuhuicong <xhc@rock-chips.com>
  * Authors: Tobias Schramm <tobias@t-sys.eu>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  */
 
 #include <linux/delay.h>
-- 
2.23.0

From 09a0ac745cad7e3df66ead4edb2582442bf6e641 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Wed, 11 Dec 2019 12:21:41 +0100
Subject: [PATCH 43/51] power: supply: cw2015: remove wrong of table

---
 drivers/power/supply/cw2015_battery.c | 8 --------
 1 file changed, 8 deletions(-)

diff --git a/drivers/power/supply/cw2015_battery.c b/drivers/power/supply/cw2015_battery.c
index 584d0b612b4b..c06301efffce 100644
--- a/drivers/power/supply/cw2015_battery.c
+++ b/drivers/power/supply/cw2015_battery.c
@@ -913,14 +913,6 @@ static const struct of_device_id cw2015_of_match[] = {
 };
 MODULE_DEVICE_TABLE(of, cw2015_of_match);
 
-static const struct of_device_id max17040_of_match[] = {
-	{ .compatible = "maxim,max17040" },
-	{ .compatible = "maxim,max77836-battery" },
-	{ },
-};
-
-MODULE_DEVICE_TABLE(of, max17040_of_match);
-
 static struct i2c_driver cw_bat_driver = {
 	.driver = {
 		.name = PREFIX"cw201x",
-- 
2.23.0

From 978aa8c2eef999ba7d63aa8dd449caffeb5431ee Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Wed, 11 Dec 2019 12:44:07 +0100
Subject: [PATCH 44/51] power: supply: cw2015: Perform style fixup

---
 drivers/power/supply/cw2015_battery.c | 98 ++++++++++++++++-----------
 1 file changed, 58 insertions(+), 40 deletions(-)

diff --git a/drivers/power/supply/cw2015_battery.c b/drivers/power/supply/cw2015_battery.c
index c06301efffce..b9da76850991 100644
--- a/drivers/power/supply/cw2015_battery.c
+++ b/drivers/power/supply/cw2015_battery.c
@@ -140,8 +140,8 @@ static int cw_init(struct cw_battery *cw_bat)
 
 	if ((reg_val & CW2015_MASK_ATHD) != CW2015_ATHD(cw_bat->alert_level)) {
 		dev_info(&cw_bat->client->dev, "the new CW2015_ATHD have not set\n");
-		reg_val &= ~CW2015_MASK_ATHD;	/* clear CW2015_ATHD */
-		reg_val |= ~CW2015_ATHD(cw_bat->alert_level);	/* set CW2015_ATHD */
+		reg_val &= ~CW2015_MASK_ATHD;
+		reg_val |= ~CW2015_ATHD(cw_bat->alert_level);
 		ret = cw_write(cw_bat->client, CW2015_REG_CONFIG, &reg_val);
 		if (ret < 0)
 			return ret;
@@ -199,27 +199,31 @@ static int cw_init(struct cw_battery *cw_bat)
 	return 0;
 }
 
-static int check_charger_online(struct device *dev, void *data) {
+static int check_charger_online(struct device *dev, void *data)
+{
 	struct device *cw_dev = data;
 	struct power_supply *supply = dev_get_drvdata(dev);
 	union power_supply_propval val;
 
 	if (supply->desc->type == POWER_SUPPLY_TYPE_BATTERY) {
-		dev_dbg(cw_dev, "Skipping power supply %s since it is a battery\n", dev_name(dev));
+		dev_dbg(cw_dev, "Skipping power supply %s since it is a battery\n",
+			dev_name(dev));
 		return 0; // Bail out, not a charger
 	}
-	if(!supply->desc->get_property(supply, POWER_SUPPLY_PROP_ONLINE, &val)) {
+	if (!supply->desc->get_property(supply, POWER_SUPPLY_PROP_ONLINE,
+					&val)) {
 		return val.intval;
-	} else {
-		dev_dbg(cw_dev, "Skipping power supply %s since it does not have an online property\n", dev_name(dev));
 	}
+	dev_dbg(cw_dev, "Skipping power supply %s since it does not "
+		"have an online property\n", dev_name(dev));
 	return 0;
 }
 
 #ifdef CONFIG_OF
-static int device_parent_match_of_node(struct device *dev, const void *np) {
-	while(dev) {
-		if(dev->of_node == np) {
+static int device_parent_match_of_node(struct device *dev, const void *np)
+{
+	while (dev) {
+		if (dev->of_node == np) {
 			return 1;
 		}
 		dev = dev->parent;
@@ -232,33 +236,42 @@ static int get_charge_state(struct cw_battery *cw_bat)
 {
 #ifdef CONFIG_OF
 	int i = 0, online = 0;
-	struct device_node* supply_of;
+	struct device_node *supply_of;
 	struct device *cw_dev = &cw_bat->client->dev;
+
 	if (!cw_dev->of_node) {
-		dev_dbg(cw_dev, "Charger does not have an of node, scanning all supplies\n");
+		dev_dbg(cw_dev, "Charger does not have an of node, scanning "
+			"all supplies\n");
 #endif
-		return !!class_for_each_device(power_supply_class, NULL, cw_dev, check_charger_online);
+		return !!class_for_each_device(power_supply_class, NULL,
+					       cw_dev, check_charger_online);
 #ifdef CONFIG_OF
 	}
 	do {
 		struct device *supply_dev;
-		dev_dbg(cw_dev, "Scanning linked supplies of %s\n", cw_dev->of_node->name);
-		supply_of = of_parse_phandle(cw_dev->of_node, "power-supplies", i++);
+
+		dev_dbg(cw_dev, "Scanning linked supplies of %s\n",
+			cw_dev->of_node->name);
+		supply_of = of_parse_phandle(cw_dev->of_node, "power-supplies",
+					     i++);
 		if (!supply_of) {
 			dev_dbg(cw_dev, "Got empty of node, scan done\n");
 			break;
 		}
 		dev_dbg(cw_dev, "Got power supply %s\n", supply_of->name);
-		supply_dev = class_find_device(power_supply_class, NULL, supply_of, device_parent_match_of_node);
+		supply_dev = class_find_device(power_supply_class, NULL,
+					       supply_of,
+					       device_parent_match_of_node);
 		if (supply_dev) {
 			online = check_charger_online(supply_dev, NULL);
 			dev_dbg(supply_dev, "Charger online: %d\n", online);
 			put_device(supply_dev);
 		} else {
-			dev_warn(cw_dev, "Failed to get device for device node %s\n", supply_of->name);
+			dev_warn(cw_dev, "Failed to get device for device "
+				 "node %s\n", supply_of->name);
 		}
 		of_node_put(supply_of);
-	} while(!online);
+	} while (!online);
 	return online;
 #endif
 }
@@ -311,9 +324,8 @@ static int cw_get_capacity(struct cw_battery *cw_bat)
 			reset_loop = 0;
 		}
 		return cw_bat->capacity;
-	} else {
-		reset_loop = 0;
 	}
+	reset_loop = 0;
 
 	/* case 1 : aviod swing */
 	if (((cw_bat->charger_mode > 0) &&
@@ -357,17 +369,16 @@ static int cw_get_capacity(struct cw_battery *cw_bat)
 
 			if (cw_capacity >= cw_bat->capacity - sleep_cap) {
 				return cw_capacity;
-			} else {
-				if (!sleep_cap)
-					discharging_loop = discharging_loop +
-						1 + cw_bat->after.tv_sec /
-						(cw_bat->monitor_sec / 1000);
-				else
-					discharging_loop = 0;
-				cw_printk("discharging_loop = %d\n",
-					  discharging_loop);
-				return cw_bat->capacity - sleep_cap;
 			}
+			if (!sleep_cap)
+				discharging_loop = discharging_loop +
+					1 + cw_bat->after.tv_sec /
+					(cw_bat->monitor_sec / 1000);
+			else
+				discharging_loop = 0;
+			cw_printk("discharging_loop = %d\n",
+				  discharging_loop);
+			return cw_bat->capacity - sleep_cap;
 		}
 #endif
 		discharging_loop++;
@@ -594,7 +605,8 @@ static void cw_bat_work(struct work_struct *work)
 
 static bool cw_battery_valid_time_to_empty(struct cw_battery *cw_bat)
 {
-	return cw_bat->time_to_empty > 0 && cw_bat->time_to_empty < CW2015_MASK_SOC &&
+	return cw_bat->time_to_empty > 0 &&
+		cw_bat->time_to_empty < CW2015_MASK_SOC &&
 		cw_bat->status == POWER_SUPPLY_STATUS_DISCHARGING;
 }
 
@@ -743,23 +755,29 @@ static int cw2015_parse_dt(struct cw_battery *cw_bat)
 	}
 
 	cw_bat->bat_mode = MODE_BATTERY;
-	cw_bat->monitor_sec = CW2015_DEFAULT_MONITOR_SEC * CW2015_TIMER_MS_COUNTS;
+	cw_bat->monitor_sec = CW2015_DEFAULT_MONITOR_SEC *
+			      CW2015_TIMER_MS_COUNTS;
 
 	prop = of_find_property(node, PREFIX"voltage-divider", &length);
 	if (prop) {
 		length /= sizeof(u32);
 		if (length != 2) {
-			dev_err(dev, "Length of voltage divider array must be 2, not %u\n", length);
+			dev_err(dev, "Length of voltage divider array must be "
+				"2, not %u\n", length);
 			return -EINVAL;
 		}
-		ret = of_property_read_u32_index(node, PREFIX"voltage-divider", 0, &data->divider_high);
+		ret = of_property_read_u32_index(node, PREFIX"voltage-divider",
+						 0, &data->divider_high);
 		if (ret) {
-			dev_err(dev, "Failed to read value of high side voltage divider resistor: %d\n", ret);
+			dev_err(dev, "Failed to read value of high side "
+				"voltage divider resistor: %d\n", ret);
 			return ret;
 		}
-		ret = of_property_read_u32_index(node, PREFIX"voltage-divider", 1, &data->divider_low);
+		ret = of_property_read_u32_index(node, PREFIX"voltage-divider",
+						 1, &data->divider_low);
 		if (ret) {
-			dev_err(dev, "Failed to read value of low side voltage divider resistor: %d\n", ret);
+			dev_err(dev, "Failed to read value of low side "
+				"voltage divider resistor: %d\n", ret);
 			return ret;
 		}
 	}
@@ -812,8 +830,6 @@ static int cw_bat_probe(struct i2c_client *client,
 
 	cw_bat = devm_kzalloc(&client->dev, sizeof(*cw_bat), GFP_KERNEL);
 	if (!cw_bat) {
-		dev_err(&client->dev,
-			"fail to allocate memory for cw2015\n");
 		return -ENOMEM;
 	}
 
@@ -856,7 +872,7 @@ static int cw_bat_probe(struct i2c_client *client,
 			   &cw_bat->battery_delay_work, msecs_to_jiffies(10));
 
 	dev_info(&cw_bat->client->dev,
-		 "cw2015/cw2013 driver v1.2 probe sucess\n");
+		 "cw2015/cw2013 driver probe success\n");
 	return 0;
 }
 
@@ -865,6 +881,7 @@ static int cw_bat_suspend(struct device *dev)
 {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct cw_battery *cw_bat = i2c_get_clientdata(client);
+
 	ktime_get_boottime_ts64(&cw_bat->suspend_time_before);
 	cancel_delayed_work(&cw_bat->battery_delay_work);
 	return 0;
@@ -874,6 +891,7 @@ static int cw_bat_resume(struct device *dev)
 {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct cw_battery *cw_bat = i2c_get_clientdata(client);
+
 	cw_bat->suspend_resume_mark = 1;
 	ktime_get_boottime_ts64(&cw_bat->after);
 	cw_bat->after = timespec64_sub(cw_bat->after,
-- 
2.23.0

From 360fee1d3deed3e172e6c38b03f673b783bec71e Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Wed, 18 Dec 2019 05:58:03 +0100
Subject: [PATCH 45/51] arm64: dts: Fix vcc5v0_host_en GPIO on Pinebook Pro

---
 arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index 19e4d8d2d186..98f55c5e9e48 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -305,7 +305,7 @@
 	vcc5v0_host: vcc5v0-host-regulator {
 		compatible = "regulator-fixed";
 		enable-active-high;
-		gpio = <&gpio4 RK_PC5 GPIO_ACTIVE_HIGH>;
+		gpio = <&gpio4 RK_PD2 GPIO_ACTIVE_HIGH>;
 		pinctrl-names = "default";
 		pinctrl-0 = <&vcc5v0_host_en>;
 		regulator-name = "vcc5v0_host";
@@ -876,7 +876,7 @@
 
 	usb2 {
 		vcc5v0_host_en: vcc5v0-host-en {
-			rockchip,pins = <4 RK_PC5 RK_FUNC_GPIO &pcfg_pull_none>;
+			rockchip,pins = <4 RK_PD2 RK_FUNC_GPIO &pcfg_pull_none>;
 		};
 	};
 
-- 
2.23.0

From 95599e7d1c4230f0d76447711466fed9fd9ee82c Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Wed, 18 Dec 2019 05:58:53 +0100
Subject: [PATCH 46/51] arm64: dts: Remove rt6540 pinctrl on Pinebook Pro

THere is nor rt5640 codec on the PBP
---
 arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts | 6 ------
 1 file changed, 6 deletions(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index 98f55c5e9e48..af858b927fa7 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -868,12 +868,6 @@
 		};
 	};
 
-	rt5640 {
-		rt5640_hpcon: rt5640-hpcon {
-			rockchip,pins = <4 RK_PC5 RK_FUNC_GPIO &pcfg_pull_none>;
-		};
-	};
-
 	usb2 {
 		vcc5v0_host_en: vcc5v0-host-en {
 			rockchip,pins = <4 RK_PD2 RK_FUNC_GPIO &pcfg_pull_none>;
-- 
2.23.0

From 68fbf8abffc25b42220d48ea24157c667a9d9699 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Wed, 18 Dec 2019 06:00:24 +0100
Subject: [PATCH 47/51] arm64: dts: Add low battery output of cw2015 as power
 key

---
 .../boot/dts/rockchip/rk3399-pinebook-pro.dts      | 14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index af858b927fa7..926f98d72431 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -93,7 +93,7 @@
 		compatible = "gpio-keys";
 		autorepeat;
 		pinctrl-names = "default";
-		pinctrl-0 = <&pwrbtn &lidbtn>;
+		pinctrl-0 = <&pwrbtn &lidbtn &lowbat>;
 
 		power {
 			debounce-interval = <20>;
@@ -111,8 +111,14 @@
 			linux,input-type = <EV_SW>;
 			wakeup-source;
 		};
+
+		low-battery {
+			gpios = <&gpio4 RK_PC5 GPIO_ACTIVE_LOW>;
+			label = "Low Battery";
+			linux,code = <KEY_POWER>;
+		};
 	};
-	
+
 	backlight: edp-backlight {
 		compatible = "pwm-backlight";
 		pwms = <&pwm0 0 740740 0>;
@@ -739,6 +745,7 @@
 		cellwise,monitor-interval = <5>;
 		cellwise,virtual-power = <0>;
 		cellwise,design-capacity = <9800>;
+		cellwise,alert-level = <3>;
 		power-supplies = <&mains_charger>, <&fusb0>;
 	};
 };
@@ -806,6 +813,9 @@
 		lidbtn: lidbtn {
 			rockchip,pins = <1 RK_PA1 RK_FUNC_GPIO &pcfg_pull_up>;
 		};
+		lowbat: lowbat {
+			rockchip,pins = <4 RK_PC5 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
 	};
 
 	dc-charger {
-- 
2.23.0

From 410fdf78f1d54bbd8de625a5ea44c031f49cb451 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Wed, 18 Dec 2019 18:14:24 +0100
Subject: [PATCH 48/51] arm64: dts: Tie pmic to correct irq on Pinebook Pro

---
 arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index 926f98d72431..d19e4102ef75 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -455,8 +455,8 @@
 	rk808: pmic@1b {
 		compatible = "rockchip,rk808";
 		reg = <0x1b>;
-		interrupt-parent = <&gpio1>;
-		interrupts = <21 IRQ_TYPE_LEVEL_LOW>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <10 IRQ_TYPE_LEVEL_LOW>;
 		#clock-cells = <1>;
 		clock-output-names = "xin32k", "rk808-clkout2";
 		pinctrl-names = "default";
-- 
2.23.0

From 87e0c99325e1cbdf58bab426bb50f88587debee9 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <tobias@t-sys.eu>
Date: Fri, 20 Dec 2019 04:37:19 +0100
Subject: [PATCH 49/51] Revert "arm64: dts: Add low battery output of cw2015 as
 power key"

This reverts commit e81a379aa96359d889daaf25da777f9eaa85a875.
Seems conversion of battery percentage to alert level is not correct. Don't use the cw2015
as a power key for now
---
 .../boot/dts/rockchip/rk3399-pinebook-pro.dts      | 14 ++------------
 1 file changed, 2 insertions(+), 12 deletions(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index d19e4102ef75..0411cc497961 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -93,7 +93,7 @@
 		compatible = "gpio-keys";
 		autorepeat;
 		pinctrl-names = "default";
-		pinctrl-0 = <&pwrbtn &lidbtn &lowbat>;
+		pinctrl-0 = <&pwrbtn &lidbtn>;
 
 		power {
 			debounce-interval = <20>;
@@ -111,14 +111,8 @@
 			linux,input-type = <EV_SW>;
 			wakeup-source;
 		};
-
-		low-battery {
-			gpios = <&gpio4 RK_PC5 GPIO_ACTIVE_LOW>;
-			label = "Low Battery";
-			linux,code = <KEY_POWER>;
-		};
 	};
-
+	
 	backlight: edp-backlight {
 		compatible = "pwm-backlight";
 		pwms = <&pwm0 0 740740 0>;
@@ -745,7 +739,6 @@
 		cellwise,monitor-interval = <5>;
 		cellwise,virtual-power = <0>;
 		cellwise,design-capacity = <9800>;
-		cellwise,alert-level = <3>;
 		power-supplies = <&mains_charger>, <&fusb0>;
 	};
 };
@@ -813,9 +806,6 @@
 		lidbtn: lidbtn {
 			rockchip,pins = <1 RK_PA1 RK_FUNC_GPIO &pcfg_pull_up>;
 		};
-		lowbat: lowbat {
-			rockchip,pins = <4 RK_PC5 RK_FUNC_GPIO &pcfg_pull_up>;
-		};
 	};
 
 	dc-charger {
-- 
2.23.0

From 8ce0be07a402308a0a74c7215a12b64ddabc66ef Mon Sep 17 00:00:00 2001
From: Icenowy Zheng <icenowy@aosc.io>
Date: Wed, 15 Jan 2020 01:05:22 +0800
Subject: [PATCH 50/51] mmc: core: host: support aliases

Signed-off-by: Icenowy Zheng <icenowy@aosc.io>
---
 drivers/mmc/core/host.c | 17 ++++++++++++++++-
 1 file changed, 16 insertions(+), 1 deletion(-)

diff --git a/drivers/mmc/core/host.c b/drivers/mmc/core/host.c
index 105b7a7c0251..f8ed54b96316 100644
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@ -400,6 +400,7 @@ struct mmc_host *mmc_alloc_host(int extra, struct device *dev)
 {
 	int err;
 	struct mmc_host *host;
+	int id;
 
 	host = kzalloc(sizeof(struct mmc_host) + extra, GFP_KERNEL);
 	if (!host)
@@ -408,7 +409,21 @@ struct mmc_host *mmc_alloc_host(int extra, struct device *dev)
 	/* scanning will be enabled when we're ready */
 	host->rescan_disable = 1;
 
-	err = ida_simple_get(&mmc_host_ida, 0, 0, GFP_KERNEL);
+	/* If OF aliases exist, start dynamic assignment after highest */
+	id = of_alias_get_highest_id("mmc");
+	id = (id < 0) ? 0 : id + 1;
+
+	/* If this devices has OF node, maybe it has an alias */
+	if (dev->of_node) {
+		int of_id = of_alias_get_id(dev->of_node, "mmc");
+
+		if (of_id < 0)
+			dev_warn(dev, "/aliases ID not available\n");
+		else
+			id = of_id;
+	}
+
+	err = ida_simple_get(&mmc_host_ida, id, 0, GFP_KERNEL);
 	if (err < 0) {
 		kfree(host);
 		return NULL;
-- 
2.23.0

From bfc827e390b4695d8d2277350504ac33625e2c38 Mon Sep 17 00:00:00 2001
From: Icenowy Zheng <icenowy@aosc.io>
Date: Wed, 15 Jan 2020 01:05:36 +0800
Subject: [PATCH 51/51] arm64: rockchip: dts: add mmc aliases to
 rk3399-pinebook-pro

Signed-off-by: Icenowy Zheng <icenowy@aosc.io>
---
 arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
index 0411cc497961..0f295c39b8d0 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-pinebook-pro.dts
@@ -16,6 +16,12 @@
 	model = "Pine64 Pinebook Pro";
 	compatible = "pine64,pinebook-pro", "rockchip,rk3399";
 
+	aliases {
+		mmc0 = &sdmmc;
+		mmc1 = &sdhci;
+		mmc2 = &sdio0;
+	};
+
 	edp_panel: edp-panel { /* "boe,nv140fhmn49" */
 		compatible = "boe,nv140fhmn49", "simple-panel";
 		backlight = <&backlight>;
-- 
2.23.0

