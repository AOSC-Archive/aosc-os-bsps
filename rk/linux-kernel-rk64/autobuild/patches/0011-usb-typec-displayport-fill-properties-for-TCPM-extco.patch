From aa03d88aea25921c369a73be670ae38406c99c11 Mon Sep 17 00:00:00 2001
From: Icenowy Zheng <icenowy@aosc.io>
Date: Tue, 27 Jul 2021 00:05:17 +0800
Subject: [PATCH 11/12] usb: typec: displayport: fill properties for TCPM
 extcon

Signed-off-by: Icenowy Zheng <icenowy@aosc.io>
---
 drivers/usb/typec/altmodes/displayport.c | 66 ++++++++++++++++++++++--
 1 file changed, 63 insertions(+), 3 deletions(-)

diff --git a/drivers/usb/typec/altmodes/displayport.c b/drivers/usb/typec/altmodes/displayport.c
index b7f094435b00..c09ed9374e75 100644
--- a/drivers/usb/typec/altmodes/displayport.c
+++ b/drivers/usb/typec/altmodes/displayport.c
@@ -9,6 +9,7 @@
  */
 
 #include <linux/delay.h>
+#include <linux/extcon-provider.h>
 #include <linux/mutex.h>
 #include <linux/module.h>
 #include <linux/usb/pd_vdo.h>
@@ -135,15 +136,69 @@ static int dp_altmode_status_update(struct dp_altmode *dp)
 	return ret;
 }
 
+static void dp_altmode_update_extcon(struct dp_altmode *dp, bool disconnect)
+{
+#ifdef CONFIG_EXTCON
+	const struct device *dev = dp->port->dev.parent->parent;
+	struct extcon_dev* edev = NULL;
+
+	edev = extcon_find_edev_by_node(dev->of_node);
+	if (IS_ERR_OR_NULL(edev))
+		return;
+
+	if (disconnect || !dp->data.conf) {
+		extcon_set_state_sync(edev, EXTCON_DISP_DP, false);
+	} else {
+		union extcon_property_value propval;
+		struct typec_port *tcport = typec_altmode2port(dp->alt);
+		extcon_set_state(edev, EXTCON_DISP_DP, true);
+
+		switch (typec_get_orientation(tcport)) {
+		case TYPEC_ORIENTATION_NONE:
+		case TYPEC_ORIENTATION_NORMAL:
+			propval.intval = 0;
+			break;
+		case TYPEC_ORIENTATION_REVERSE:
+			propval.intval = 1;
+			break;
+		}
+
+		extcon_set_property(edev, EXTCON_DISP_DP,
+				    EXTCON_PROP_USB_TYPEC_POLARITY,
+				    propval);
+
+		if (!(DP_CONF_GET_PIN_ASSIGN(dp->data.conf) &
+		      DP_PIN_ASSIGN_MULTI_FUNC_MASK))
+			propval.intval = 0;
+		else
+			propval.intval = 1;
+
+		extcon_set_property_sync(edev, EXTCON_USB,
+					 EXTCON_PROP_USB_SS,
+					 propval);
+		extcon_set_property_sync(edev, EXTCON_USB_HOST,
+					 EXTCON_PROP_USB_SS,
+					 propval);
+		extcon_set_property_sync(edev, EXTCON_DISP_DP,
+					 EXTCON_PROP_USB_SS,
+					 propval);
+	}
+#endif
+}
+
 static int dp_altmode_configured(struct dp_altmode *dp)
 {
 	int ret;
 
 	sysfs_notify(&dp->alt->dev.kobj, "displayport", "configuration");
 
-	if (!dp->data.conf)
+	if (!dp->data.conf) {
+		dp_altmode_update_extcon(dp, true);
 		return typec_altmode_notify(dp->alt, TYPEC_STATE_USB,
 					    &dp->data);
+	}
+
+	dp_altmode_update_extcon(dp, false);
 
 	ret = dp_altmode_notify(dp);
 	if (ret)
@@ -173,11 +228,14 @@ static int dp_altmode_configure_vdm(struct dp_altmode *dp, u32 conf)
 
 	ret = typec_altmode_vdm(dp->alt, header, &conf, 2);
 	if (ret) {
-		if (DP_CONF_GET_PIN_ASSIGN(dp->data.conf))
+		if (DP_CONF_GET_PIN_ASSIGN(dp->data.conf)) {
+			dp_altmode_update_extcon(dp, false);
 			dp_altmode_notify(dp);
-		else
+		} else {
+			dp_altmode_update_extcon(dp, true);
 			typec_altmode_notify(dp->alt, TYPEC_STATE_USB,
 					     &dp->data);
+		}
 	}
 
 	return ret;
@@ -220,6 +278,7 @@ static void dp_altmode_work(struct work_struct *work)
 	case DP_STATE_EXIT:
 		if (typec_altmode_exit(dp->alt))
 			dev_err(&dp->alt->dev, "Exit Mode Failed!\n");
+		dp_altmode_update_extcon(dp, true);
 		break;
 	default:
 		break;
@@ -250,6 +309,7 @@ static void dp_altmode_attention(struct typec_altmode *alt, const u32 vdo)
 	if (dp_altmode_notify(dp))
 		dev_err(&alt->dev, "%s: notification failed\n", __func__);
 
+	dp_altmode_update_extcon(dp, false);
 	if (old_state == DP_STATE_IDLE && dp->state != DP_STATE_IDLE)
 		schedule_work(&dp->work);
 
-- 
2.30.2

