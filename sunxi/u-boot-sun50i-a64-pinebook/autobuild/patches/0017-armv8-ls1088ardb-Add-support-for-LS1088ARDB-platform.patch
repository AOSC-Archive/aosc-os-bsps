From e84a324ba7950e88c0df4a2c656f533c723aeaae Mon Sep 17 00:00:00 2001
From: Ashish Kumar <Ashish.Kumar@nxp.com>
Date: Thu, 31 Aug 2017 16:12:54 +0530
Subject: [PATCH 017/256] armv8: ls1088ardb: Add support for LS1088ARDB
 platform

LS1088A is an ARMv8 implementation. The LS1088ARDB is an evaluatoin
platform that supports the LS1088A family SoCs. This patch add basic
support of the platform.

Signed-off-by: Alison Wang <alison.wang@nxp.com>
Signed-off-by: Prabhakar Kushwaha <prabhakar.kushwaha@nxp.com>
Signed-off-by: Ashish Kumar <Ashish.Kumar@nxp.com>
Signed-off-by: Raghav Dogra <raghav.dogra@nxp.com>
Signed-off-by: Shaohui Xie <Shaohui.Xie@nxp.com>
[YS: Disabled NAND in board header file]
Reviewed-by: York Sun <york.sun@nxp.com>

WIP: disable NAND for LS1088ARDB
---
 arch/arm/Kconfig                          |  14 ++
 arch/arm/cpu/armv8/Kconfig                |   1 +
 arch/arm/cpu/armv8/fsl-layerscape/Kconfig |   1 +
 arch/arm/dts/Makefile                     |   3 +-
 arch/arm/dts/fsl-ls1088a-rdb.dts          |  40 ++++
 board/freescale/ls1088a/Kconfig           |  15 ++
 board/freescale/ls1088a/MAINTAINERS       |   7 +
 board/freescale/ls1088a/Makefile          |   9 +
 board/freescale/ls1088a/README            |  66 ++++++
 board/freescale/ls1088a/ddr.c             | 102 +++++++++
 board/freescale/ls1088a/ddr.h             |  44 ++++
 board/freescale/ls1088a/eth_ls1088ardb.c  | 102 +++++++++
 board/freescale/ls1088a/ls1088a.c         | 332 ++++++++++++++++++++++++++++++
 board/freescale/ls1088a/ls1088a_qixis.h   |  34 +++
 configs/ls1088ardb_qspi_defconfig         |  29 +++
 include/configs/ls1088a_common.h          | 201 ++++++++++++++++++
 include/configs/ls1088ardb.h              | 317 ++++++++++++++++++++++++++++
 17 files changed, 1316 insertions(+), 1 deletion(-)
 create mode 100644 arch/arm/dts/fsl-ls1088a-rdb.dts
 create mode 100644 board/freescale/ls1088a/Kconfig
 create mode 100644 board/freescale/ls1088a/MAINTAINERS
 create mode 100644 board/freescale/ls1088a/Makefile
 create mode 100644 board/freescale/ls1088a/README
 create mode 100644 board/freescale/ls1088a/ddr.c
 create mode 100644 board/freescale/ls1088a/ddr.h
 create mode 100644 board/freescale/ls1088a/eth_ls1088ardb.c
 create mode 100644 board/freescale/ls1088a/ls1088a.c
 create mode 100644 board/freescale/ls1088a/ls1088a_qixis.h
 create mode 100644 configs/ls1088ardb_qspi_defconfig
 create mode 100644 include/configs/ls1088a_common.h
 create mode 100644 include/configs/ls1088ardb.h

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 53eae8953e..41bf86475d 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -909,6 +909,19 @@ config TARGET_LS1012AFRDM
 	  development platform that supports the QorIQ LS1012A
 	  Layerscape Architecture processor.
 
+config TARGET_LS1088ARDB
+	bool "Support ls1088ardb"
+	select ARCH_LS1088A
+	select ARM64
+	select ARMV8_MULTIENTRY
+	select ARCH_MISC_INIT
+	select BOARD_LATE_INIT
+	help
+	  Support for NXP LS1088ARDB platform.
+	  The LS1088A Reference design board (RDB) is a high-performance
+	  development platform that supports the QorIQ LS1088A
+	  Layerscape Architecture processor.
+
 config TARGET_LS1021AQDS
 	bool "Support ls1021aqds"
 	select BOARD_LATE_INIT
@@ -1192,6 +1205,7 @@ source "board/creative/xfi3/Kconfig"
 source "board/freescale/ls2080a/Kconfig"
 source "board/freescale/ls2080aqds/Kconfig"
 source "board/freescale/ls2080ardb/Kconfig"
+source "board/freescale/ls1088a/Kconfig"
 source "board/freescale/ls1021aqds/Kconfig"
 source "board/freescale/ls1043aqds/Kconfig"
 source "board/freescale/ls1021atwr/Kconfig"
diff --git a/arch/arm/cpu/armv8/Kconfig b/arch/arm/cpu/armv8/Kconfig
index 8e4c3dd8f2..aecdf814c8 100644
--- a/arch/arm/cpu/armv8/Kconfig
+++ b/arch/arm/cpu/armv8/Kconfig
@@ -88,6 +88,7 @@ config PSCI_RESET
 	depends on !ARCH_EXYNOS7 && !ARCH_BCM283X && !TARGET_LS2080A_EMU && \
 		   !TARGET_LS2080A_SIMU && !TARGET_LS2080AQDS && \
 		   !TARGET_LS2080ARDB && !TARGET_LS1012AQDS && \
+		   !TARGET_LS1088ARDB && \
 		   !TARGET_LS1012ARDB && !TARGET_LS1012AFRDM && \
 		   !TARGET_LS1043ARDB && !TARGET_LS1043AQDS && \
 		   !TARGET_LS1046ARDB && !TARGET_LS1046AQDS && \
diff --git a/arch/arm/cpu/armv8/fsl-layerscape/Kconfig b/arch/arm/cpu/armv8/fsl-layerscape/Kconfig
index 527051fb73..ca8cdd8f37 100644
--- a/arch/arm/cpu/armv8/fsl-layerscape/Kconfig
+++ b/arch/arm/cpu/armv8/fsl-layerscape/Kconfig
@@ -208,6 +208,7 @@ config SYS_LS_PPA_FW_ADDR
 	default 0x20400000 if SYS_LS_PPA_FW_IN_XIP && QSPI_BOOT && ARCH_LS2080A
 	default 0x40400000 if SYS_LS_PPA_FW_IN_XIP && QSPI_BOOT
 	default 0x580400000 if SYS_LS_PPA_FW_IN_XIP && ARCH_LS2080A
+	default 0x20400000 if SYS_LS_PPA_FW_IN_XIP && ARCH_LS1088A
 	default 0x60400000 if SYS_LS_PPA_FW_IN_XIP
 	default 0x400000 if SYS_LS_PPA_FW_IN_MMC
 	default 0x400000 if SYS_LS_PPA_FW_IN_NAND
diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index 762429c463..9c63fb4c34 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -187,7 +187,8 @@ dtb-$(CONFIG_ARCH_LS1021A) += ls1021a-qds-duart.dtb \
 dtb-$(CONFIG_FSL_LSCH3) += fsl-ls2080a-qds.dtb \
 	fsl-ls2080a-rdb.dtb \
 	fsl-ls2081a-rdb.dtb \
-	fsl-ls2088a-rdb-qspi.dtb
+	fsl-ls2088a-rdb-qspi.dtb \
+	fsl-ls1088a-rdb.dtb
 dtb-$(CONFIG_FSL_LSCH2) += fsl-ls1043a-qds-duart.dtb \
 	fsl-ls1043a-qds-lpuart.dtb \
 	fsl-ls1043a-rdb.dtb \
diff --git a/arch/arm/dts/fsl-ls1088a-rdb.dts b/arch/arm/dts/fsl-ls1088a-rdb.dts
new file mode 100644
index 0000000000..30ceed8212
--- /dev/null
+++ b/arch/arm/dts/fsl-ls1088a-rdb.dts
@@ -0,0 +1,40 @@
+/*
+ * NXP ls1088a RDB board device tree source
+ *
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/dts-v1/;
+
+#include "fsl-ls1088a.dtsi"
+
+/ {
+	model = "NXP Layerscape 1088a RDB Board";
+	compatible = "fsl,ls1088a-rdb", "fsl,ls1088a";
+	aliases {
+		spi0 = &qspi;
+	};
+};
+
+&qspi {
+	bus-num = <0>;
+	status = "okay";
+
+	qflash0: s25fs512s@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "spi-flash";
+		spi-max-frequency = <50000000>;
+		reg = <0>;
+	};
+
+	qflash1: s25fs512s@1 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "spi-flash";
+		spi-max-frequency = <50000000>;
+		reg = <1>;
+	 };
+};
diff --git a/board/freescale/ls1088a/Kconfig b/board/freescale/ls1088a/Kconfig
new file mode 100644
index 0000000000..a4d8223471
--- /dev/null
+++ b/board/freescale/ls1088a/Kconfig
@@ -0,0 +1,15 @@
+if TARGET_LS1088ARDB
+
+config SYS_BOARD
+	default "ls1088a"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_SOC
+	default "fsl-layerscape"
+
+config SYS_CONFIG_NAME
+	default "ls1088ardb"
+
+endif
diff --git a/board/freescale/ls1088a/MAINTAINERS b/board/freescale/ls1088a/MAINTAINERS
new file mode 100644
index 0000000000..12834f63be
--- /dev/null
+++ b/board/freescale/ls1088a/MAINTAINERS
@@ -0,0 +1,7 @@
+LS1088ARDB BOARD
+M:	Prabhakar Kushwaha <prabhakar.kushwaha@nxp.com>
+M:	Ashish Kumar <Ashish.Kumar@nxp.com>
+S:	Maintained
+F:	board/freescale/ls1088a/
+F:	include/configs/ls1088ardb.h
+F:	configs/ls1088ardb_qspi_defconfig
diff --git a/board/freescale/ls1088a/Makefile b/board/freescale/ls1088a/Makefile
new file mode 100644
index 0000000000..e997cf1adb
--- /dev/null
+++ b/board/freescale/ls1088a/Makefile
@@ -0,0 +1,9 @@
+#
+# Copyright 2017 NXP
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y += ls1088a.o
+obj-$(CONFIG_TARGET_LS1088ARDB) += eth_ls1088ardb.o
+obj-y += ddr.o
diff --git a/board/freescale/ls1088a/README b/board/freescale/ls1088a/README
new file mode 100644
index 0000000000..3f4d987631
--- /dev/null
+++ b/board/freescale/ls1088a/README
@@ -0,0 +1,66 @@
+Overview
+--------
+The LS1088A Reference Design (RDB) is a high-performance computing,
+evaluation, and development platform that supports ARM SoC LS1088A and its
+derivatives.
+
+
+LS1088A SoC Overview
+--------------------------------------
+Please refer arch/arm/cpu/armv8/fsl-layerscape/doc/README.soc
+
+RDB Default Switch Settings (1: ON; 0: OFF)
+-------------------------------------------
+
+For QSPI Boot
+SW1 0011 0001
+SW2 x100 0000
+SW3 1111 0010
+SW4 1001 0011
+SW5 1111 0000
+
+For SD Boot
+SW1 0010 0000
+SW2 0100 0000
+SW3 1111 0010
+SW4 1001 0011
+SW5 1111 0000
+
+For eMMC Boot
+SW1 0010 0000
+SW2 1100 0000
+SW3 1111 0010
+SW4 1001 0011
+SW5 1111 0000
+
+Alternately you can use this command to switch from QSPI to SD
+
+=> i2c mw 66 0x60 0x20; i2c mw 66 10 10;i2c mw 66 10 21
+
+ LS1088ARDB board Overview
+ -------------------------
+ - SERDES Connections, 16 lanes supporting:
+      - PCI Express - 3.0
+      - SATA 3.0
+      - XFI
+      - QSGMII
+ - DDR Controller
+     - One ports of 72-bits (8-bits ECC, 64-bits DATA) DDR4. Each port supports four
+       chip-selects on one DIMM connector. Support is up to 2133MT/s, Although MAX default
+       with FSL refernce software is 2100MT/s
+ - 2 QSPI-NOR Spansion(S25FS512SDSMFI011) flash of size 64MB
+ - IFC/Local Bus
+    - One 2 GB NAND flash with ECC support, not as boot source
+    - CPLD of size 2K
+ - USB 3.0
+    - Two high speed USB 3.0 ports
+    - First USB 3.0 port configured as Host with Type-A connector
+    - Second USB 3.0 port configured as OTG with micro-AB connector
+ - SDHC/eMMC
+    - SDHC slot and onboard eMMC are muxed together
+ - 4 I2C controllers
+ - Two SATA onboard connectors
+ - 2 UART
+ - JTAG support
+ - QSPI emulator support
+ - TDM riser support
diff --git a/board/freescale/ls1088a/ddr.c b/board/freescale/ls1088a/ddr.c
new file mode 100644
index 0000000000..0ecfd653b4
--- /dev/null
+++ b/board/freescale/ls1088a/ddr.c
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <fsl_ddr_sdram.h>
+#include <fsl_ddr_dimm_params.h>
+#include <asm/arch/soc.h>
+#include <asm/arch/clock.h>
+#include "ddr.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+			   dimm_params_t *pdimm,
+			   unsigned int ctrl_num)
+{
+	const struct board_specific_parameters *pbsp, *pbsp_highest = NULL;
+	ulong ddr_freq;
+
+	if (ctrl_num > 1) {
+		printf("Not supported controller number %d\n", ctrl_num);
+		return;
+	}
+	if (!pdimm->n_ranks)
+		return;
+
+	/*
+	 * we use identical timing for all slots. If needed, change the code
+	 * to  pbsp = rdimms[ctrl_num] or pbsp = udimms[ctrl_num];
+	 */
+	pbsp = udimms[0];
+
+	/* Get clk_adjust, wrlvl_start, wrlvl_ctl, according to the board ddr
+	 * freqency and n_banks specified in board_specific_parameters table.
+	 */
+	ddr_freq = get_ddr_freq(0) / 1000000;
+	while (pbsp->datarate_mhz_high) {
+		if (pbsp->n_ranks == pdimm->n_ranks) {
+			if (ddr_freq <= pbsp->datarate_mhz_high) {
+				popts->clk_adjust = pbsp->clk_adjust;
+				popts->wrlvl_start = pbsp->wrlvl_start;
+				popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+				popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+				goto found;
+			}
+			pbsp_highest = pbsp;
+		}
+		pbsp++;
+	}
+
+	if (pbsp_highest) {
+		printf("Error: board specific timing not found for %lu MT/s\n",
+		       ddr_freq);
+		printf("Trying to use the highest speed (%u) parameters\n",
+		       pbsp_highest->datarate_mhz_high);
+		popts->clk_adjust = pbsp_highest->clk_adjust;
+		popts->wrlvl_start = pbsp_highest->wrlvl_start;
+		popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+		popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+	} else {
+		panic("DIMM is not supported by this board");
+	}
+found:
+	debug("Found timing match: n_ranks %d, data rate %d, rank_gb %d\n"
+		"\tclk_adjust %d, wrlvl_start %d, wrlvl_ctrl_2 0x%x, wrlvl_ctrl_3 0x%x\n",
+		pbsp->n_ranks, pbsp->datarate_mhz_high, pbsp->rank_gb,
+		pbsp->clk_adjust, pbsp->wrlvl_start, pbsp->wrlvl_ctl_2,
+		pbsp->wrlvl_ctl_3);
+
+
+
+	popts->half_strength_driver_enable = 0;
+	/*
+	 * Write leveling override
+	 */
+	popts->wrlvl_override = 1;
+	popts->wrlvl_sample = 0xf;
+
+
+	/* Enable ZQ calibration */
+	popts->zq_en = 1;
+
+	/* Enable DDR hashing */
+	popts->addr_hash = 1;
+
+	popts->ddr_cdr1 = DDR_CDR1_DHC_EN | DDR_CDR1_ODT(DDR_CDR_ODT_60ohm);
+	popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_60ohm) |
+			  DDR_CDR2_VREF_TRAIN_EN | DDR_CDR2_VREF_RANGE_2;
+}
+
+
+int fsl_initdram(void)
+{
+	puts("Initializing DDR....using SPD\n");
+
+	gd->ram_size = fsl_ddr_sdram();
+
+	return 0;
+}
diff --git a/board/freescale/ls1088a/ddr.h b/board/freescale/ls1088a/ddr.h
new file mode 100644
index 0000000000..dfcfc1fae2
--- /dev/null
+++ b/board/freescale/ls1088a/ddr.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __LS1088A_DDR_H__
+#define __LS1088A_DDR_H__
+struct board_specific_parameters {
+	u32 n_ranks;
+	u32 datarate_mhz_high;
+	u32 rank_gb;
+	u32 clk_adjust;
+	u32 wrlvl_start;
+	u32 wrlvl_ctl_2;
+	u32 wrlvl_ctl_3;
+};
+
+/*
+ * These tables contain all valid speeds we want to override with board
+ * specific parameters. datarate_mhz_high values need to be in ascending order
+ * for each n_ranks group.
+ */
+
+static const struct board_specific_parameters udimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
+	 */
+#if defined(CONFIG_TARGET_LS1088ARDB)
+
+	{2,  1666, 0, 8,     8, 0x090A0B0E, 0x0F10110D,},
+	{2,  1900, 0, 4,     7, 0x09090B0D, 0x0E10120B,},
+	{2,  2300, 0, 8,     9, 0x0A0C0E11, 0x1214160F,},
+	{}
+
+#endif
+};
+
+static const struct board_specific_parameters *udimms[] = {
+	udimm0,
+};
+#endif
diff --git a/board/freescale/ls1088a/eth_ls1088ardb.c b/board/freescale/ls1088a/eth_ls1088ardb.c
new file mode 100644
index 0000000000..853d815da5
--- /dev/null
+++ b/board/freescale/ls1088a/eth_ls1088ardb.c
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <netdev.h>
+#include <malloc.h>
+#include <fsl_mdio.h>
+#include <miiphy.h>
+#include <phy.h>
+#include <fm_eth.h>
+#include <asm/io.h>
+#include <exports.h>
+#include <asm/arch/fsl_serdes.h>
+#include <fsl-mc/ldpaa_wriop.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define MC_BOOT_ENV_VAR "mcinitcmd"
+int board_eth_init(bd_t *bis)
+{
+#if defined(CONFIG_FSL_MC_ENET)
+	char *mc_boot_env_var;
+	int i, interface;
+	struct memac_mdio_info mdio_info;
+	struct mii_dev *dev;
+	struct ccsr_gur *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+	struct memac_mdio_controller *reg;
+	u32 srds_s1, cfg;
+
+	cfg = in_le32(&gur->rcwsr[FSL_CHASSIS3_SRDS1_REGSR - 1]) &
+				FSL_CHASSIS3_SRDS1_PRTCL_MASK;
+	cfg >>= FSL_CHASSIS3_SRDS1_PRTCL_SHIFT;
+
+	srds_s1 = serdes_get_number(FSL_SRDS_1, cfg);
+
+	reg = (struct memac_mdio_controller *)CONFIG_SYS_FSL_WRIOP1_MDIO1;
+	mdio_info.regs = reg;
+	mdio_info.name = DEFAULT_WRIOP_MDIO1_NAME;
+
+	/* Register the EMI 1 */
+	fm_memac_mdio_init(bis, &mdio_info);
+
+	reg = (struct memac_mdio_controller *)CONFIG_SYS_FSL_WRIOP1_MDIO2;
+	mdio_info.regs = reg;
+	mdio_info.name = DEFAULT_WRIOP_MDIO2_NAME;
+
+	/* Register the EMI 2 */
+	fm_memac_mdio_init(bis, &mdio_info);
+
+	switch (srds_s1) {
+	case 0x1D:
+		/*
+		 * XFI does not need a PHY to work, but to avoid U-boot use
+		 * default PHY address which is zero to a MAC when it found
+		 * a MAC has no PHY address, we give a PHY address to XFI
+		 * MAC error.
+		 */
+		wriop_set_phy_address(WRIOP1_DPMAC1, 0x0a);
+		wriop_set_phy_address(WRIOP1_DPMAC2, AQ_PHY_ADDR1);
+		wriop_set_phy_address(WRIOP1_DPMAC3, QSGMII1_PORT1_PHY_ADDR);
+		wriop_set_phy_address(WRIOP1_DPMAC4, QSGMII1_PORT2_PHY_ADDR);
+		wriop_set_phy_address(WRIOP1_DPMAC5, QSGMII1_PORT3_PHY_ADDR);
+		wriop_set_phy_address(WRIOP1_DPMAC6, QSGMII1_PORT4_PHY_ADDR);
+		wriop_set_phy_address(WRIOP1_DPMAC7, QSGMII2_PORT1_PHY_ADDR);
+		wriop_set_phy_address(WRIOP1_DPMAC8, QSGMII2_PORT2_PHY_ADDR);
+		wriop_set_phy_address(WRIOP1_DPMAC9, QSGMII2_PORT3_PHY_ADDR);
+		wriop_set_phy_address(WRIOP1_DPMAC10, QSGMII2_PORT4_PHY_ADDR);
+
+		break;
+	default:
+		printf("SerDes1 protocol 0x%x is not supported on LS1088ARDB\n",
+		       srds_s1);
+		break;
+	}
+
+	for (i = WRIOP1_DPMAC3; i <= WRIOP1_DPMAC10; i++) {
+		interface = wriop_get_enet_if(i);
+		switch (interface) {
+		case PHY_INTERFACE_MODE_QSGMII:
+			dev = miiphy_get_dev_by_name(DEFAULT_WRIOP_MDIO1_NAME);
+			wriop_set_mdio(i, dev);
+			break;
+		default:
+			break;
+		}
+	}
+
+	dev = miiphy_get_dev_by_name(DEFAULT_WRIOP_MDIO2_NAME);
+	wriop_set_mdio(WRIOP1_DPMAC2, dev);
+
+	mc_boot_env_var = env_get(MC_BOOT_ENV_VAR);
+	if (mc_boot_env_var)
+		run_command_list(mc_boot_env_var, -1, 0);
+	cpu_eth_init(bis);
+#endif /* CONFIG_FMAN_ENET */
+
+	return pci_eth_init(bis);
+}
diff --git a/board/freescale/ls1088a/ls1088a.c b/board/freescale/ls1088a/ls1088a.c
new file mode 100644
index 0000000000..a022da9827
--- /dev/null
+++ b/board/freescale/ls1088a/ls1088a.c
@@ -0,0 +1,332 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <i2c.h>
+#include <malloc.h>
+#include <errno.h>
+#include <netdev.h>
+#include <fsl_ifc.h>
+#include <fsl_ddr.h>
+#include <fsl_sec.h>
+#include <asm/io.h>
+#include <fdt_support.h>
+#include <libfdt.h>
+#include <fsl-mc/fsl_mc.h>
+#include <environment.h>
+#include <asm/arch-fsl-layerscape/soc.h>
+#include <asm/arch/ppa.h>
+
+#include "../common/qixis.h"
+#include "ls1088a_qixis.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+unsigned long long get_qixis_addr(void)
+{
+	unsigned long long addr;
+
+	if (gd->flags & GD_FLG_RELOC)
+		addr = QIXIS_BASE_PHYS;
+	else
+		addr = QIXIS_BASE_PHYS_EARLY;
+
+	/*
+	 * IFC address under 256MB is mapped to 0x30000000, any address above
+	 * is mapped to 0x5_10000000 up to 4GB.
+	 */
+	addr = addr  > 0x10000000 ? addr + 0x500000000ULL : addr + 0x30000000;
+
+	return addr;
+}
+
+int checkboard(void)
+{
+	char buf[64];
+	u8 sw;
+	static const char *const freq[] = {"100", "125", "156.25",
+					    "100 separate SSCG"};
+	int clock;
+
+
+	printf("Board: LS1088A-RDB, ");
+
+	sw = QIXIS_READ(arch);
+	printf("Board Arch: V%d, ", sw >> 4);
+
+	printf("Board version: %c, boot from ", (sw & 0xf) + 'A');
+
+
+	memset((u8 *)buf, 0x00, ARRAY_SIZE(buf));
+
+	sw = QIXIS_READ(brdcfg[0]);
+	sw = (sw & QIXIS_LBMAP_MASK) >> QIXIS_LBMAP_SHIFT;
+
+#ifdef CONFIG_SD_BOOT
+	puts("SD card\n");
+#endif
+	switch (sw) {
+	case 0:
+
+		puts("QSPI:");
+		sw = QIXIS_READ(brdcfg[0]);
+		sw = (sw & QIXIS_QMAP_MASK) >> QIXIS_QMAP_SHIFT;
+		if (sw == 0 || sw == 4)
+			puts("0\n");
+		else if (sw == 1)
+			puts("1\n");
+		else
+			puts("EMU\n");
+		break;
+
+	default:
+		printf("invalid setting of SW%u\n", QIXIS_LBMAP_SWITCH);
+		break;
+	}
+
+
+	printf("CPLD: v%d.%d\n", QIXIS_READ(scver), QIXIS_READ(tagdata));
+
+
+	/*
+	 * Display the actual SERDES reference clocks as configured by the
+	 * dip switches on the board.  Note that the SWx registers could
+	 * technically be set to force the reference clocks to match the
+	 * values that the SERDES expects (or vice versa).  For now, however,
+	 * we just display both values and hope the user notices when they
+	 * don't match.
+	 */
+	puts("SERDES1 Reference : ");
+	sw = QIXIS_READ(brdcfg[2]);
+	clock = (sw >> 6) & 3;
+	printf("Clock1 = %sMHz ", freq[clock]);
+	clock = (sw >> 4) & 3;
+	printf("Clock2 = %sMHz", freq[clock]);
+
+	puts("\nSERDES2 Reference : ");
+	clock = (sw >> 2) & 3;
+	printf("Clock1 = %sMHz ", freq[clock]);
+	clock = (sw >> 0) & 3;
+	printf("Clock2 = %sMHz\n", freq[clock]);
+
+	return 0;
+}
+
+bool if_board_diff_clk(void)
+{
+	u8 diff_conf = QIXIS_READ(dutcfg[11]);
+	return diff_conf & 0x80;
+}
+
+unsigned long get_board_sys_clk(void)
+{
+	u8 sysclk_conf = QIXIS_READ(brdcfg[1]);
+
+	switch (sysclk_conf & 0x0f) {
+	case QIXIS_SYSCLK_83:
+		return 83333333;
+	case QIXIS_SYSCLK_100:
+		return 100000000;
+	case QIXIS_SYSCLK_125:
+		return 125000000;
+	case QIXIS_SYSCLK_133:
+		return 133333333;
+	case QIXIS_SYSCLK_150:
+		return 150000000;
+	case QIXIS_SYSCLK_160:
+		return 160000000;
+	case QIXIS_SYSCLK_166:
+		return 166666666;
+	}
+
+	return 66666666;
+}
+
+unsigned long get_board_ddr_clk(void)
+{
+	u8 ddrclk_conf = QIXIS_READ(brdcfg[1]);
+
+	if (if_board_diff_clk())
+		return get_board_sys_clk();
+	switch ((ddrclk_conf & 0x30) >> 4) {
+	case QIXIS_DDRCLK_100:
+		return 100000000;
+	case QIXIS_DDRCLK_125:
+		return 125000000;
+	case QIXIS_DDRCLK_133:
+		return 133333333;
+	}
+
+	return 66666666;
+}
+
+int select_i2c_ch_pca9547(u8 ch)
+{
+	int ret;
+
+	ret = i2c_write(I2C_MUX_PCA_ADDR_PRI, 0, 1, &ch, 1);
+	if (ret) {
+		puts("PCA: failed to select proper channel\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+void board_retimer_init(void)
+{
+	u8 reg;
+
+	/* Retimer is connected to I2C1_CH5 */
+	select_i2c_ch_pca9547(I2C_MUX_CH5);
+
+	/* Access to Control/Shared register */
+	reg = 0x0;
+	i2c_write(I2C_RETIMER_ADDR, 0xff, 1, &reg, 1);
+
+	/* Read device revision and ID */
+	i2c_read(I2C_RETIMER_ADDR, 1, 1, &reg, 1);
+	debug("Retimer version id = 0x%x\n", reg);
+
+	/* Enable Broadcast. All writes target all channel register sets */
+	reg = 0x0c;
+	i2c_write(I2C_RETIMER_ADDR, 0xff, 1, &reg, 1);
+
+	/* Reset Channel Registers */
+	i2c_read(I2C_RETIMER_ADDR, 0, 1, &reg, 1);
+	reg |= 0x4;
+	i2c_write(I2C_RETIMER_ADDR, 0, 1, &reg, 1);
+
+	/* Set data rate as 10.3125 Gbps */
+	reg = 0x90;
+	i2c_write(I2C_RETIMER_ADDR, 0x60, 1, &reg, 1);
+	reg = 0xb3;
+	i2c_write(I2C_RETIMER_ADDR, 0x61, 1, &reg, 1);
+	reg = 0x90;
+	i2c_write(I2C_RETIMER_ADDR, 0x62, 1, &reg, 1);
+	reg = 0xb3;
+	i2c_write(I2C_RETIMER_ADDR, 0x63, 1, &reg, 1);
+	reg = 0xcd;
+	i2c_write(I2C_RETIMER_ADDR, 0x64, 1, &reg, 1);
+
+	/* Select VCO Divider to full rate (000) */
+	i2c_read(I2C_RETIMER_ADDR, 0x2F, 1, &reg, 1);
+	reg &= 0x0f;
+	reg |= 0x70;
+	i2c_write(I2C_RETIMER_ADDR, 0x2F, 1, &reg, 1);
+
+
+	/*return the default channel*/
+	select_i2c_ch_pca9547(I2C_MUX_CH_DEFAULT);
+}
+
+int board_init(void)
+{
+	init_final_memctl_regs();
+#if defined(CONFIG_TARGET_LS1088ARDB) && defined(CONFIG_FSL_MC_ENET)
+	u32 __iomem *irq_ccsr = (u32 __iomem *)ISC_BASE;
+#endif
+
+	select_i2c_ch_pca9547(I2C_MUX_CH_DEFAULT);
+	board_retimer_init();
+
+#ifdef CONFIG_ENV_IS_NOWHERE
+	gd->env_addr = (ulong)&default_environment[0];
+#endif
+
+#if defined(CONFIG_TARGET_LS1088ARDB) && defined(CONFIG_FSL_MC_ENET)
+	/* invert AQR105 IRQ pins polarity */
+	out_le32(irq_ccsr + IRQCR_OFFSET / 4, AQR105_IRQ_MASK);
+#endif
+
+#ifdef CONFIG_FSL_LS_PPA
+	ppa_init();
+#endif
+	return 0;
+}
+
+int board_early_init_f(void)
+{
+	fsl_lsch3_early_init_f();
+	return 0;
+}
+
+void detail_board_ddr_info(void)
+{
+	puts("\nDDR    ");
+	print_size(gd->bd->bi_dram[0].size + gd->bd->bi_dram[1].size, "");
+	print_ddr_info(0);
+}
+
+#if defined(CONFIG_ARCH_MISC_INIT)
+int arch_misc_init(void)
+{
+#ifdef CONFIG_FSL_CAAM
+	sec_init();
+#endif
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_MC_ENET
+void fdt_fixup_board_enet(void *fdt)
+{
+	int offset;
+
+	offset = fdt_path_offset(fdt, "/fsl-mc");
+
+	if (offset < 0)
+		offset = fdt_path_offset(fdt, "/fsl,dprc@0");
+
+	if (offset < 0) {
+		printf("%s: ERROR: fsl-mc node not found in device tree (error %d)\n",
+		       __func__, offset);
+		return;
+	}
+
+	if (get_mc_boot_status() == 0)
+		fdt_status_okay(fdt, offset);
+	else
+		fdt_status_fail(fdt, offset);
+}
+#endif
+
+#ifdef CONFIG_OF_BOARD_SETUP
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	int err, i;
+	u64 base[CONFIG_NR_DRAM_BANKS];
+	u64 size[CONFIG_NR_DRAM_BANKS];
+
+	ft_cpu_setup(blob, bd);
+
+	/* fixup DT for the two GPP DDR banks */
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
+		base[i] = gd->bd->bi_dram[i].start;
+		size[i] = gd->bd->bi_dram[i].size;
+	}
+
+#ifdef CONFIG_RESV_RAM
+	/* reduce size if reserved memory is within this bank */
+	if (gd->arch.resv_ram >= base[0] &&
+	    gd->arch.resv_ram < base[0] + size[0])
+		size[0] = gd->arch.resv_ram - base[0];
+	else if (gd->arch.resv_ram >= base[1] &&
+		 gd->arch.resv_ram < base[1] + size[1])
+		size[1] = gd->arch.resv_ram - base[1];
+#endif
+
+	fdt_fixup_memory_banks(blob, base, size, CONFIG_NR_DRAM_BANKS);
+
+#ifdef CONFIG_FSL_MC_ENET
+	fdt_fixup_board_enet(blob);
+	err = fsl_mc_ldpaa_exit(bd);
+	if (err)
+		return err;
+#endif
+
+	return 0;
+}
+#endif
diff --git a/board/freescale/ls1088a/ls1088a_qixis.h b/board/freescale/ls1088a/ls1088a_qixis.h
new file mode 100644
index 0000000000..9757d1b28c
--- /dev/null
+++ b/board/freescale/ls1088a/ls1088a_qixis.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __LS1088AQDS_QIXIS_H__
+#define __LS1088AQDS_QIXIS_H__
+
+/* Definitions of QIXIS Registers for LS1088AQDS */
+
+/* SYSCLK */
+#define QIXIS_SYSCLK_66			0x0
+#define QIXIS_SYSCLK_83			0x1
+#define QIXIS_SYSCLK_100		0x2
+#define QIXIS_SYSCLK_125		0x3
+#define QIXIS_SYSCLK_133		0x4
+#define QIXIS_SYSCLK_150		0x5
+#define QIXIS_SYSCLK_160		0x6
+#define QIXIS_SYSCLK_166		0x7
+
+/* DDRCLK */
+#define QIXIS_DDRCLK_66			0x0
+#define QIXIS_DDRCLK_100		0x1
+#define QIXIS_DDRCLK_125		0x2
+#define QIXIS_DDRCLK_133		0x3
+
+/* BRDCFG2 - SD clock*/
+#define QIXIS_SDCLK1_100		0x0
+#define QIXIS_SDCLK1_125		0x1
+#define QIXIS_SDCLK1_165		0x2
+#define QIXIS_SDCLK1_100_SP		0x3
+
+#endif
diff --git a/configs/ls1088ardb_qspi_defconfig b/configs/ls1088ardb_qspi_defconfig
new file mode 100644
index 0000000000..33e41247e6
--- /dev/null
+++ b/configs/ls1088ardb_qspi_defconfig
@@ -0,0 +1,29 @@
+CONFIG_ARM=y
+CONFIG_TARGET_LS1088ARDB=y
+# CONFIG_SYS_MALLOC_F is not set
+CONFIG_DM_SPI=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_DEFAULT_DEVICE_TREE="fsl-ls1088a-rdb"
+CONFIG_FIT=y
+CONFIG_FIT_VERBOSE=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_OF_STDOUT_VIA_ALIAS=y
+CONFIG_SYS_EXTRA_OPTIONS="SYS_FSL_DDR4, QSPI_BOOT"
+CONFIG_HUSH_PARSER=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_PING=y
+CONFIG_OF_CONTROL=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_DM=y
+CONFIG_SPI_FLASH=y
+CONFIG_NETDEVICES=y
+CONFIG_E1000=y
+CONFIG_SYS_NS16550=y
+CONFIG_FSL_DSPI=y
+CONFIG_EFI_LOADER_BOUNCE_BUFFER=y
+# CONFIG_DISPLAY_BOARDINFO is not set
+CONFIG_FSL_LS_PPA=y
diff --git a/include/configs/ls1088a_common.h b/include/configs/ls1088a_common.h
new file mode 100644
index 0000000000..c78ba5d6b6
--- /dev/null
+++ b/include/configs/ls1088a_common.h
@@ -0,0 +1,201 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __LS1088_COMMON_H
+#define __LS1088_COMMON_H
+
+
+#define CONFIG_REMAKE_ELF
+#define CONFIG_FSL_LAYERSCAPE
+#define CONFIG_MP
+
+#include <asm/arch/stream_id_lsch3.h>
+#include <asm/arch/config.h>
+#include <asm/arch/soc.h>
+
+/* Link Definitions */
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_FSL_OCRAM_BASE + 0xfff0)
+
+/* Link Definitions */
+#ifdef CONFIG_QSPI_BOOT
+#define CONFIG_SYS_TEXT_BASE            0x20100000
+#else
+#define CONFIG_SYS_TEXT_BASE		0x30100000
+#endif
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+
+#define CONFIG_SKIP_LOWLEVEL_INIT
+
+#define CONFIG_FSL_DDR_INTERACTIVE	/* Interactive debugging */
+
+#define CONFIG_VERY_BIG_RAM
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x80000000UL
+#define CONFIG_SYS_FSL_DDR_SDRAM_BASE_PHY	0
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+#define CONFIG_SYS_DDR_BLOCK2_BASE	0x8080000000ULL
+#define CONFIG_SYS_FSL_DDR_MAIN_NUM_CTRLS	1
+/*
+ * SMP Definitinos
+ */
+#define CPU_RELEASE_ADDR		secondary_boot_func
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 2048 * 1024)
+
+/* I2C */
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
+#define CONFIG_SYS_I2C_MXC_I2C2		/* enable I2C bus 2 */
+#define CONFIG_SYS_I2C_MXC_I2C3		/* enable I2C bus 3 */
+#define CONFIG_SYS_I2C_MXC_I2C4		/* enable I2C bus 4 */
+
+/* Serial Port */
+#define CONFIG_CONS_INDEX       1
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE     1
+#define CONFIG_SYS_NS16550_CLK          (get_bus_freq(0) / 2)
+
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/* IFC */
+#define CONFIG_FSL_IFC
+
+/*
+ * During booting, IFC is mapped at the region of 0x30000000.
+ * But this region is limited to 256MB. To accommodate NOR, promjet
+ * and FPGA. This region is divided as below:
+ * 0x30000000 - 0x37ffffff : 128MB : NOR flash
+ * 0x38000000 - 0x3BFFFFFF : 64MB  : Promjet
+ * 0x3C000000 - 0x40000000 : 64MB  : FPGA etc
+ *
+ * To accommodate bigger NOR flash and other devices, we will map IFC
+ * chip selects to as below:
+ * 0x5_1000_0000..0x5_1fff_ffff	Memory Hole
+ * 0x5_2000_0000..0x5_3fff_ffff	IFC CSx (FPGA, NAND and others 512MB)
+ * 0x5_4000_0000..0x5_7fff_ffff	ASIC or others 1GB
+ * 0x5_8000_0000..0x5_bfff_ffff	IFC CS0 1GB (NOR/Promjet)
+ * 0x5_C000_0000..0x5_ffff_ffff	IFC CS1 1GB (NOR/Promjet)
+ *
+ * For e.g. NOR flash at CS0 will be mapped to 0x580000000 after relocation.
+ * CONFIG_SYS_FLASH_BASE has the final address (core view)
+ * CONFIG_SYS_FLASH_BASE_PHYS has the final address (IFC view)
+ * CONFIG_SYS_FLASH_BASE_PHYS_EARLY has the temporary IFC address
+ * CONFIG_SYS_TEXT_BASE is linked to 0x30000000 for booting
+ */
+
+#define CONFIG_SYS_FLASH_BASE			0x580000000ULL
+#define CONFIG_SYS_FLASH_BASE_PHYS		0x80000000
+#define CONFIG_SYS_FLASH_BASE_PHYS_EARLY	0x00000000
+
+#define CONFIG_SYS_FLASH1_BASE_PHYS		0xC0000000
+#define CONFIG_SYS_FLASH1_BASE_PHYS_EARLY	0x8000000
+
+#ifndef __ASSEMBLY__
+unsigned long long get_qixis_addr(void);
+#endif
+
+#define QIXIS_BASE				get_qixis_addr()
+#define QIXIS_BASE_PHYS				0x20000000
+#define QIXIS_BASE_PHYS_EARLY			0xC000000
+
+
+#define CONFIG_SYS_NAND_BASE			0x530000000ULL
+#define CONFIG_SYS_NAND_BASE_PHYS		0x30000000
+
+
+/* MC firmware */
+/* TODO Actual DPL max length needs to be confirmed with the MC FW team */
+#define CONFIG_SYS_LS_MC_DPC_MAX_LENGTH	    0x20000
+#define CONFIG_SYS_LS_MC_DRAM_DPC_OFFSET    0x00F00000
+#define CONFIG_SYS_LS_MC_DPL_MAX_LENGTH	    0x20000
+#define CONFIG_SYS_LS_MC_DRAM_DPL_OFFSET    0x00F20000
+#define CONFIG_SYS_LS_MC_AIOP_IMG_MAX_LENGTH	0x200000
+#define CONFIG_SYS_LS_MC_DRAM_AIOP_IMG_OFFSET	0x07000000
+/*
+ * Carve out a DDR region which will not be used by u-boot/Linux
+ *
+ * It will be used by MC and Debug Server. The MC region must be
+ * 512MB aligned, so the min size to hide is 512MB.
+ */
+
+#if defined(CONFIG_FSL_MC_ENET)
+#define CONFIG_SYS_LS_MC_DRAM_BLOCK_MIN_SIZE		(512UL * 1024 * 1024)
+#endif
+
+#define CONFIG_FSL_CAAM			/* Enable SEC/CAAM */
+
+/* Command line configuration */
+#define CONFIG_CMD_GREPENV
+#define CONFIG_CMD_CACHE
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_LOAD_ADDR	(CONFIG_SYS_DDR_SDRAM_BASE + 0x10000000)
+
+/* Physical Memory Map */
+#define CONFIG_CHIP_SELECTS_PER_CTRL	4
+
+#define CONFIG_NR_DRAM_BANKS		2
+
+#define CONFIG_HWCONFIG
+#define HWCONFIG_BUFFER_SIZE		128
+
+/* #define CONFIG_DISPLAY_CPUINFO */
+
+/* Allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+/* Initial environment variables */
+#define CONFIG_EXTRA_ENV_SETTINGS		\
+	"hwconfig=fsl_ddr:bank_intlv=auto\0"	\
+	"loadaddr=0x80100000\0"			\
+	"kernel_addr=0x100000\0"		\
+	"ramdisk_addr=0x800000\0"		\
+	"ramdisk_size=0x2000000\0"		\
+	"fdt_high=0xa0000000\0"			\
+	"initrd_high=0xffffffffffffffff\0"	\
+	"kernel_start=0x581000000\0"		\
+	"kernel_load=0xa0000000\0"		\
+	"kernel_size=0x2800000\0"		\
+	"console=ttyAMA0,38400n8\0"		\
+	"mcinitcmd=fsl_mc start mc 0x580a00000"	\
+	" 0x580e00000 \0"
+
+#define CONFIG_BOOTARGS		"console=ttyS0,115200 root=/dev/ram0 " \
+				"earlycon=uart8250,mmio,0x21c0500 " \
+				"ramdisk_size=0x3000000 default_hugepagesz=2m" \
+				" hugepagesz=2m hugepages=256"
+#if defined(CONFIG_QSPI_BOOT)
+#define CONFIG_BOOTCOMMAND	"sf probe 0:0;" \
+				"sf read 0x80200000 0xd00000 0x100000;"\
+				" fsl_mc apply dpl 0x80200000 &&" \
+				" sf read $kernel_load $kernel_start" \
+				" $kernel_size && bootm $kernel_load"
+#else /* NOR BOOT*/
+#define CONFIG_BOOTCOMMAND	"fsl_mc apply dpl 0x580d00000 &&" \
+				" cp.b $kernel_start $kernel_load" \
+				" $kernel_size && bootm $kernel_load"
+#endif
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE /* Boot args buffer */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_CMDLINE_EDITING		1
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_MAXARGS		64	/* max command args */
+
+#define CONFIG_PANIC_HANG	/* do not reset board on panic */
+
+#define CONFIG_SYS_BOOTM_LEN   (64 << 20)      /* Increase max gunzip size */
+
+#endif /* __LS1088_COMMON_H */
diff --git a/include/configs/ls1088ardb.h b/include/configs/ls1088ardb.h
new file mode 100644
index 0000000000..3223278dfd
--- /dev/null
+++ b/include/configs/ls1088ardb.h
@@ -0,0 +1,317 @@
+/*
+ * Copyright 2017 NXP
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __LS1088A_RDB_H
+#define __LS1088A_RDB_H
+
+#include "ls1088a_common.h"
+
+#define CONFIG_DISPLAY_BOARDINFO_LATE
+
+#if defined(CONFIG_QSPI_BOOT)
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_SIZE			0x2000          /* 8KB */
+#define CONFIG_ENV_OFFSET		0x300000        /* 3MB */
+#define CONFIG_ENV_SECT_SIZE		0x40000
+#else
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_FLASH_BASE + 0x300000)
+#define CONFIG_ENV_SECT_SIZE		0x20000
+#define CONFIG_ENV_SIZE			0x20000
+#endif
+
+#if defined(CONFIG_QSPI_BOOT)
+#define CONFIG_QIXIS_I2C_ACCESS
+#define SYS_NO_FLASH
+#undef CONFIG_CMD_IMLS
+#endif
+
+#define CONFIG_SYS_CLK_FREQ		100000000
+#define CONFIG_DDR_CLK_FREQ		100000000
+#define COUNTER_FREQUENCY_REAL		25000000	/* 25MHz */
+#define COUNTER_FREQUENCY		25000000	/* 25MHz */
+
+#define CONFIG_DDR_SPD
+#ifdef CONFIG_EMU
+#define CONFIG_SYS_FSL_DDR_EMU
+#define CONFIG_SYS_MXC_I2C1_SPEED	40000000
+#define CONFIG_SYS_MXC_I2C2_SPEED	40000000
+#else
+#define CONFIG_DDR_ECC
+#define CONFIG_ECC_INIT_VIA_DDRCONTROLLER
+#define CONFIG_MEM_INIT_VALUE		0xdeadbeef
+#endif
+#define SPD_EEPROM_ADDRESS	0x51
+#define CONFIG_SYS_SPD_BUS_NUM	0	/* SPD on I2C bus 0 */
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+
+
+#if !defined(CONFIG_QSPI_BOOT) && !defined(CONFIG_SD_BOOT_QSPI)
+#define CONFIG_SYS_NOR0_CSPR_EXT	(0x0)
+#define CONFIG_SYS_NOR_AMASK		IFC_AMASK(128 * 1024 * 1024)
+#define CONFIG_SYS_NOR_AMASK_EARLY	IFC_AMASK(64 * 1024 * 1024)
+
+#define CONFIG_SYS_NOR0_CSPR					\
+	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS)		| \
+	CSPR_PORT_SIZE_16					| \
+	CSPR_MSEL_NOR						| \
+	CSPR_V)
+#define CONFIG_SYS_NOR0_CSPR_EARLY				\
+	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS_EARLY)	| \
+	CSPR_PORT_SIZE_16					| \
+	CSPR_MSEL_NOR						| \
+	CSPR_V)
+#define CONFIG_SYS_NOR_CSOR	CSOR_NOR_ADM_SHIFT(6)
+#define CONFIG_SYS_NOR_FTIM0	(FTIM0_NOR_TACSE(0x1) | \
+				FTIM0_NOR_TEADC(0x1) | \
+				FTIM0_NOR_TEAHC(0x1))
+#define CONFIG_SYS_NOR_FTIM1	(FTIM1_NOR_TACO(0x1) | \
+				FTIM1_NOR_TRAD_NOR(0x1))
+#define CONFIG_SYS_NOR_FTIM2	(FTIM2_NOR_TCS(0x0) | \
+				FTIM2_NOR_TCH(0x0) | \
+				FTIM2_NOR_TWP(0x1))
+#define CONFIG_SYS_NOR_FTIM3	0x04000000
+#define CONFIG_SYS_IFC_CCR	0x01000000
+
+#ifndef SYS_NO_FLASH
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS	45 /* count down from 45/5: 9..1 */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* number of banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	1024	/* sectors per device */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_BANKS_LIST	{ CONFIG_SYS_FLASH_BASE }
+#endif
+#endif
+#define CONFIG_SYS_NAND_MAX_ECCPOS	256
+#define CONFIG_SYS_NAND_MAX_OOBFREE	2
+
+#define CONFIG_SYS_NAND_CSPR_EXT	(0x0)
+#define CONFIG_SYS_NAND_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8 /* Port Size = 8 bit */ \
+				| CSPR_MSEL_NAND	/* MSEL = NAND */ \
+				| CSPR_V)
+#define CONFIG_SYS_NAND_AMASK	IFC_AMASK(64 * 1024)
+
+#define CONFIG_SYS_NAND_CSOR    (CSOR_NAND_ECC_ENC_EN   /* ECC on encode */ \
+				| CSOR_NAND_ECC_DEC_EN  /* ECC on decode */ \
+				| CSOR_NAND_ECC_MODE_4  /* 4-bit ECC */ \
+				| CSOR_NAND_RAL_3	/* RAL = 3Byes */ \
+				| CSOR_NAND_PGS_2K	/* Page Size = 2K */ \
+				| CSOR_NAND_SPRZ_64/* Spare size = 64 */ \
+				| CSOR_NAND_PB(64))	/*Pages Per Block = 64*/
+
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* ONFI NAND Flash mode0 Timing Params */
+#define CONFIG_SYS_NAND_FTIM0		(FTIM0_NAND_TCCST(0x07) | \
+					FTIM0_NAND_TWP(0x18)   | \
+					FTIM0_NAND_TWCHT(0x07) | \
+					FTIM0_NAND_TWH(0x0a))
+#define CONFIG_SYS_NAND_FTIM1		(FTIM1_NAND_TADLE(0x32) | \
+					FTIM1_NAND_TWBE(0x39)  | \
+					FTIM1_NAND_TRR(0x0e)   | \
+					FTIM1_NAND_TRP(0x18))
+#define CONFIG_SYS_NAND_FTIM2		(FTIM2_NAND_TRAD(0x0f) | \
+					FTIM2_NAND_TREH(0x0a) | \
+					FTIM2_NAND_TWHRE(0x1e))
+#define CONFIG_SYS_NAND_FTIM3		0x0
+
+#define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+
+#define CONFIG_FSL_QIXIS
+#define CONFIG_SYS_I2C_FPGA_ADDR	0x66
+#define QIXIS_LBMAP_SWITCH		2
+#define QIXIS_QMAP_MASK			0xe0
+#define QIXIS_QMAP_SHIFT		5
+#define QIXIS_LBMAP_MASK		0x1f
+#define QIXIS_LBMAP_SHIFT		5
+#define QIXIS_LBMAP_DFLTBANK		0x00
+#define QIXIS_LBMAP_ALTBANK		0x20
+#define QIXIS_LBMAP_SD			0x00
+#define QIXIS_LBMAP_SD_QSPI		0x00
+#define QIXIS_LBMAP_QSPI		0x00
+#define QIXIS_RCW_SRC_SD		0x40
+#define QIXIS_RCW_SRC_QSPI		0x62
+#define QIXIS_RST_CTL_RESET		0x31
+#define QIXIS_RCFG_CTL_RECONFIG_IDLE	0x20
+#define QIXIS_RCFG_CTL_RECONFIG_START	0x21
+#define QIXIS_RCFG_CTL_WATCHDOG_ENBLE	0x08
+#define	QIXIS_RST_FORCE_MEM		0x01
+
+#define CONFIG_SYS_FPGA_CSPR_EXT	(0x0)
+#define CONFIG_SYS_FPGA_CSPR		(CSPR_PHYS_ADDR(QIXIS_BASE_PHYS_EARLY) \
+					| CSPR_PORT_SIZE_8 \
+					| CSPR_MSEL_GPCM \
+					| CSPR_V)
+#define SYS_FPGA_CSPR_FINAL	(CSPR_PHYS_ADDR(QIXIS_BASE_PHYS) \
+					| CSPR_PORT_SIZE_8 \
+					| CSPR_MSEL_GPCM \
+					| CSPR_V)
+
+#define CONFIG_SYS_FPGA_AMASK		IFC_AMASK(64*1024)
+#define CONFIG_SYS_FPGA_CSOR		CSOR_GPCM_ADM_SHIFT(0)
+/* QIXIS Timing parameters*/
+#define SYS_FPGA_CS_FTIM0	(FTIM0_GPCM_TACSE(0x0e) | \
+					FTIM0_GPCM_TEADC(0x0e) | \
+					FTIM0_GPCM_TEAHC(0x0e))
+#define SYS_FPGA_CS_FTIM1	(FTIM1_GPCM_TACO(0xff) | \
+					FTIM1_GPCM_TRAD(0x3f))
+#define SYS_FPGA_CS_FTIM2	(FTIM2_GPCM_TCS(0xf) | \
+					FTIM2_GPCM_TCH(0xf) | \
+					FTIM2_GPCM_TWP(0x3E))
+#define SYS_FPGA_CS_FTIM3	0x0
+
+#if defined(CONFIG_QSPI_BOOT) || defined(CONFIG_SD_BOOT_QSPI)
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NAND_FTIM3
+#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_FPGA_CSPR_EXT
+#define CONFIG_SYS_CSPR2		CONFIG_SYS_FPGA_CSPR
+#define CONFIG_SYS_CSPR2_FINAL		SYS_FPGA_CSPR_FINAL
+#define CONFIG_SYS_AMASK2		CONFIG_SYS_FPGA_AMASK
+#define CONFIG_SYS_CSOR2		CONFIG_SYS_FPGA_CSOR
+#define CONFIG_SYS_CS2_FTIM0		SYS_FPGA_CS_FTIM0
+#define CONFIG_SYS_CS2_FTIM1		SYS_FPGA_CS_FTIM1
+#define CONFIG_SYS_CS2_FTIM2		SYS_FPGA_CS_FTIM2
+#define CONFIG_SYS_CS2_FTIM3		SYS_FPGA_CS_FTIM3
+#else
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR_EARLY
+#define CONFIG_SYS_CSPR0_FINAL		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+#endif
+
+
+#define CONFIG_SYS_LS_MC_BOOT_TIMEOUT_MS 5000
+
+/*
+ * I2C bus multiplexer
+ */
+#define I2C_MUX_PCA_ADDR_PRI		0x77
+#define I2C_MUX_PCA_ADDR_SEC		0x76 /* Secondary multiplexer */
+#define I2C_RETIMER_ADDR		0x18
+#define I2C_MUX_CH_DEFAULT		0x8
+#define I2C_MUX_CH5			0xD
+/*
+* RTC configuration
+*/
+#define RTC
+#define CONFIG_RTC_PCF8563 1
+#define CONFIG_SYS_I2C_RTC_ADDR         0x51  /* Channel 3*/
+#define CONFIG_CMD_DATE
+
+/* EEPROM */
+#define CONFIG_ID_EEPROM
+#define CONFIG_SYS_I2C_EEPROM_NXID
+#define CONFIG_SYS_EEPROM_BUS_NUM		0
+#define CONFIG_SYS_I2C_EEPROM_ADDR		0x57
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN		1
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS	3
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS	5
+
+/* QSPI device */
+#if defined(CONFIG_QSPI_BOOT)
+#define CONFIG_FSL_QSPI
+#define CONFIG_SPI_FLASH_SPANSION
+#define FSL_QSPI_FLASH_SIZE		(1 << 26)
+#define FSL_QSPI_FLASH_NUM		2
+#endif
+
+#define CONFIG_CMD_MEMINFO
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		0x9fffffff
+
+#define CONFIG_SYS_MONITOR_BASE CONFIG_SYS_TEXT_BASE
+
+#define CONFIG_FSL_MEMAC
+
+/* Initial environment variables */
+#if defined(CONFIG_QSPI_BOOT)
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#define CONFIG_EXTRA_ENV_SETTINGS		\
+	"hwconfig=fsl_ddr:bank_intlv=auto\0"	\
+	"loadaddr=0x90100000\0"			\
+	"kernel_addr=0x100000\0"		\
+	"ramdisk_addr=0x800000\0"		\
+	"ramdisk_size=0x2000000\0"		\
+	"fdt_high=0xa0000000\0"			\
+	"initrd_high=0xffffffffffffffff\0"	\
+	"kernel_start=0x1000000\0"		\
+	"kernel_load=0xa0000000\0"		\
+	"kernel_size=0x2800000\0"		\
+	"mcinitcmd=sf probe 0:0;sf read 0x80000000 0xA00000 0x100000;"	\
+	"sf read 0x80100000 0xE00000 0x100000;" \
+	"fsl_mc start mc 0x80000000 0x80100000\0"	\
+	"mcmemsize=0x70000000 \0"
+
+#endif
+
+/* MAC/PHY configuration */
+#ifdef CONFIG_FSL_MC_ENET
+#define CONFIG_PHYLIB_10G
+#define CONFIG_PHY_GIGE
+#define CONFIG_PHYLIB
+
+#define CONFIG_PHY_VITESSE
+#define CONFIG_PHY_AQUANTIA
+#define AQ_PHY_ADDR1			0x00
+#define AQR105_IRQ_MASK			0x00000004
+
+#define QSGMII1_PORT1_PHY_ADDR		0x0c
+#define QSGMII1_PORT2_PHY_ADDR		0x0d
+#define QSGMII1_PORT3_PHY_ADDR		0x0e
+#define QSGMII1_PORT4_PHY_ADDR		0x0f
+#define QSGMII2_PORT1_PHY_ADDR		0x1c
+#define QSGMII2_PORT2_PHY_ADDR		0x1d
+#define QSGMII2_PORT3_PHY_ADDR		0x1e
+#define QSGMII2_PORT4_PHY_ADDR		0x1f
+
+#define CONFIG_MII
+#define CONFIG_ETHPRIME		"DPMAC1@xgmii"
+#define CONFIG_PHY_GIGE
+#endif
+
+/*  MMC  */
+#ifdef CONFIG_MMC
+#define CONFIG_FSL_ESDHC
+#define CONFIG_SYS_FSL_MMC_HAS_CAPBLT_VS33
+#endif
+
+#undef CONFIG_CMDLINE_EDITING
+#include <config_distro_defaults.h>
+
+#define BOOT_TARGET_DEVICES(func) \
+	func(USB, usb, 0) \
+	func(MMC, mmc, 0) \
+	func(SCSI, scsi, 0) \
+	func(DHCP, dhcp, na)
+#include <config_distro_bootcmd.h>
+
+#include <asm/fsl_secure_boot.h>
+
+#endif /* __LS1088A_RDB_H */
-- 
2.13.6

