From 41fa83d1a6cdd8ddfb3fbe332252193ff8fb8b71 Mon Sep 17 00:00:00 2001
From: Rob Clark <robdclark@gmail.com>
Date: Sat, 9 Sep 2017 13:15:57 -0400
Subject: [PATCH 163/256] fat/fs: remove a bunch of dead code
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Spotted by chance, when trying to remove file_fat_ls(), I noticed there
were some dead users of the API.

Signed-off-by: Rob Clark <robdclark@gmail.com>
Acked-by: Stefan Br√ºns <stefan.bruens@rwth-aachen.de>
Reviewed-by: Simon Glass <sjg@chromium.org>
---
 fs/fat/Makefile |   4 --
 fs/fat/file.c   | 183 --------------------------------------------------------
 include/fat.h   |  20 -------
 3 files changed, 207 deletions(-)
 delete mode 100644 fs/fat/file.c

diff --git a/fs/fat/Makefile b/fs/fat/Makefile
index b60e8486c4..3e2a6b01a8 100644
--- a/fs/fat/Makefile
+++ b/fs/fat/Makefile
@@ -5,7 +5,3 @@
 
 obj-$(CONFIG_FS_FAT)	:= fat.o
 obj-$(CONFIG_FAT_WRITE):= fat_write.o
-
-ifndef CONFIG_SPL_BUILD
-obj-$(CONFIG_FS_FAT)	+= file.o
-endif
diff --git a/fs/fat/file.c b/fs/fat/file.c
deleted file mode 100644
index 89706117b9..0000000000
--- a/fs/fat/file.c
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
- * file.c
- *
- * Mini "VFS" by Marcus Sundberg
- *
- * 2002-07-28 - rjones@nexus-tech.net - ported to ppcboot v1.1.6
- * 2003-03-10 - kharris@nexus-tech.net - ported to uboot
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h>
-#include <config.h>
-#include <malloc.h>
-#include <fat.h>
-#include <linux/stat.h>
-#include <linux/time.h>
-
-/* Supported filesystems */
-static const struct filesystem filesystems[] = {
-	{ file_fat_detectfs,  file_fat_ls,  file_fat_read,  "FAT" },
-};
-#define NUM_FILESYS	(sizeof(filesystems)/sizeof(struct filesystem))
-
-/* The filesystem which was last detected */
-static int current_filesystem = FSTYPE_NONE;
-
-/* The current working directory */
-#define CWD_LEN		511
-char file_cwd[CWD_LEN+1] = "/";
-
-const char *
-file_getfsname(int idx)
-{
-	if (idx < 0 || idx >= NUM_FILESYS)
-		return NULL;
-
-	return filesystems[idx].name;
-}
-
-static void
-pathcpy(char *dest, const char *src)
-{
-	char *origdest = dest;
-
-	do {
-		if (dest-file_cwd >= CWD_LEN) {
-			*dest = '\0';
-			return;
-		}
-		*(dest) = *(src);
-		if (*src == '\0') {
-			if (dest-- != origdest && ISDIRDELIM(*dest)) {
-				*dest = '\0';
-			}
-			return;
-		}
-		++dest;
-
-		if (ISDIRDELIM(*src))
-			while (ISDIRDELIM(*src)) src++;
-		else
-			src++;
-	} while (1);
-}
-
-int
-file_cd(const char *path)
-{
-	if (ISDIRDELIM(*path)) {
-		while (ISDIRDELIM(*path)) path++;
-		strncpy(file_cwd+1, path, CWD_LEN-1);
-	} else {
-		const char *origpath = path;
-		char *tmpstr = file_cwd;
-		int back = 0;
-
-		while (*tmpstr != '\0') tmpstr++;
-		do {
-			tmpstr--;
-		} while (ISDIRDELIM(*tmpstr));
-
-		while (*path == '.') {
-			path++;
-			while (*path == '.') {
-				path++;
-				back++;
-			}
-			if (*path != '\0' && !ISDIRDELIM(*path)) {
-				path = origpath;
-				back = 0;
-				break;
-			}
-			while (ISDIRDELIM(*path)) path++;
-			origpath = path;
-		}
-
-		while (back--) {
-			/* Strip off path component */
-			while (!ISDIRDELIM(*tmpstr)) {
-				tmpstr--;
-			}
-			if (tmpstr == file_cwd) {
-				/* Incremented again right after the loop. */
-				tmpstr--;
-				break;
-			}
-			/* Skip delimiters */
-			while (ISDIRDELIM(*tmpstr)) tmpstr--;
-		}
-		tmpstr++;
-		if (*path == '\0') {
-			if (tmpstr == file_cwd) {
-				*tmpstr = '/';
-				tmpstr++;
-			}
-			*tmpstr = '\0';
-			return 0;
-		}
-		*tmpstr = '/';
-		pathcpy(tmpstr+1, path);
-	}
-
-	return 0;
-}
-
-int
-file_detectfs(void)
-{
-	int i;
-
-	current_filesystem = FSTYPE_NONE;
-
-	for (i = 0; i < NUM_FILESYS; i++) {
-		if (filesystems[i].detect() == 0) {
-			strcpy(file_cwd, "/");
-			current_filesystem = i;
-			break;
-		}
-	}
-
-	return current_filesystem;
-}
-
-int
-file_ls(const char *dir)
-{
-	char fullpath[1024];
-	const char *arg;
-
-	if (current_filesystem == FSTYPE_NONE) {
-		printf("Can't list files without a filesystem!\n");
-		return -1;
-	}
-
-	if (ISDIRDELIM(*dir)) {
-		arg = dir;
-	} else {
-		sprintf(fullpath, "%s/%s", file_cwd, dir);
-		arg = fullpath;
-	}
-	return filesystems[current_filesystem].ls(arg);
-}
-
-int file_read(const char *filename, void *buffer, int maxsize)
-{
-	char fullpath[1024];
-	const char *arg;
-
-	if (current_filesystem == FSTYPE_NONE) {
-		printf("Can't load file without a filesystem!\n");
-		return -1;
-	}
-
-	if (ISDIRDELIM(*filename)) {
-		arg = filename;
-	} else {
-		sprintf(fullpath, "%s/%s", file_cwd, filename);
-		arg = fullpath;
-	}
-
-	return filesystems[current_filesystem].read(arg, buffer, maxsize);
-}
diff --git a/include/fat.h b/include/fat.h
index 18d8981c48..b255ce5337 100644
--- a/include/fat.h
+++ b/include/fat.h
@@ -178,25 +178,6 @@ static inline u32 clust_to_sect(fsdata *fsdata, u32 clust)
 	return fsdata->data_begin + clust * fsdata->clust_size;
 }
 
-typedef int	(file_detectfs_func)(void);
-typedef int	(file_ls_func)(const char *dir);
-typedef int	(file_read_func)(const char *filename, void *buffer,
-				 int maxsize);
-
-struct filesystem {
-	file_detectfs_func	*detect;
-	file_ls_func		*ls;
-	file_read_func		*read;
-	const char		name[12];
-};
-
-/* FAT tables */
-file_detectfs_func	file_fat_detectfs;
-file_ls_func		file_fat_ls;
-file_read_func		file_fat_read;
-
-/* Currently this doesn't check if the dir exists or is valid... */
-int file_cd(const char *path);
 int file_fat_detectfs(void);
 int file_fat_ls(const char *dir);
 int fat_exists(const char *filename);
@@ -204,7 +185,6 @@ int fat_size(const char *filename, loff_t *size);
 int file_fat_read_at(const char *filename, loff_t pos, void *buffer,
 		     loff_t maxsize, loff_t *actread);
 int file_fat_read(const char *filename, void *buffer, int maxsize);
-const char *file_getfsname(int idx);
 int fat_set_blk_dev(struct blk_desc *rbdd, disk_partition_t *info);
 int fat_register_device(struct blk_desc *dev_desc, int part_no);
 
-- 
2.13.6

