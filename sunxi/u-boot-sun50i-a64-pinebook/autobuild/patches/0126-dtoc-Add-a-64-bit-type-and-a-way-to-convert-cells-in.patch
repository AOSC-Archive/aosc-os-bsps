From fbdfd228fb7bcdd16ddca3e081b1cc1d8205702b Mon Sep 17 00:00:00 2001
From: Simon Glass <sjg@chromium.org>
Date: Tue, 29 Aug 2017 14:15:48 -0600
Subject: [PATCH 126/256] dtoc: Add a 64-bit type and a way to convert cells
 into 64 bits

When dealing with multi-cell values we need a type that can hold this
value. Add this and a function to process it from a list of cell values.

Signed-off-by: Simon Glass <sjg@chromium.org>
Reviewed-by: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>
Tested-by: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>
Tested-by: Kever Yang <kever.yang@rock-chips.com>
---
 tools/dtoc/dtb_platdata.py |  3 +++
 tools/dtoc/fdt.py          |  2 +-
 tools/dtoc/fdt_util.py     | 14 ++++++++++++++
 3 files changed, 18 insertions(+), 1 deletion(-)

diff --git a/tools/dtoc/dtb_platdata.py b/tools/dtoc/dtb_platdata.py
index 041a33188f..4a1162a9fa 100644
--- a/tools/dtoc/dtb_platdata.py
+++ b/tools/dtoc/dtb_platdata.py
@@ -38,6 +38,7 @@ TYPE_NAMES = {
     fdt.TYPE_BYTE: 'unsigned char',
     fdt.TYPE_STRING: 'const char *',
     fdt.TYPE_BOOL: 'bool',
+    fdt.TYPE_INT64: 'fdt64_t',
 }
 
 STRUCT_PREFIX = 'dtd_'
@@ -95,6 +96,8 @@ def get_value(ftype, value):
         return '"%s"' % value
     elif ftype == fdt.TYPE_BOOL:
         return 'true'
+    elif ftype == fdt.TYPE_INT64:
+        return '%#x' % value
 
 def get_compat_name(node):
     """Get a node's first compatible string as a C identifier
diff --git a/tools/dtoc/fdt.py b/tools/dtoc/fdt.py
index 49409a62ec..ffd42ce541 100644
--- a/tools/dtoc/fdt.py
+++ b/tools/dtoc/fdt.py
@@ -21,7 +21,7 @@ import libfdt
 # so it is fairly efficient.
 
 # A list of types we support
-(TYPE_BYTE, TYPE_INT, TYPE_STRING, TYPE_BOOL) = range(4)
+(TYPE_BYTE, TYPE_INT, TYPE_STRING, TYPE_BOOL, TYPE_INT64) = range(5)
 
 def CheckErr(errnum, msg):
     if errnum:
diff --git a/tools/dtoc/fdt_util.py b/tools/dtoc/fdt_util.py
index b9dfae8d0e..bec6ee947a 100644
--- a/tools/dtoc/fdt_util.py
+++ b/tools/dtoc/fdt_util.py
@@ -29,6 +29,20 @@ def fdt32_to_cpu(val):
         val = val.encode('raw_unicode_escape')
     return struct.unpack('>I', val)[0]
 
+def fdt_cells_to_cpu(val, cells):
+    """Convert one or two cells to a long integer
+
+    Args:
+        Value to convert (array of one or more 4-character strings)
+
+    Return:
+        A native-endian long value
+    """
+    out = long(fdt32_to_cpu(val[0]))
+    if cells == 2:
+        out = out << 32 | fdt32_to_cpu(val[1])
+    return out
+
 def EnsureCompiled(fname):
     """Compile an fdt .dts source file into a .dtb binary blob if needed.
 
-- 
2.13.6

