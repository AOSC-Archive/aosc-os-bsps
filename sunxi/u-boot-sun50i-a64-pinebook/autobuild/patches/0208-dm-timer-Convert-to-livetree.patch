From b61e8b0c9e76dacf0b670c3948c3cd738b2379a3 Mon Sep 17 00:00:00 2001
From: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>
Date: Mon, 11 Sep 2017 22:04:10 +0200
Subject: [PATCH 208/256] dm: timer: Convert to livetree

This updates dm_timer_init to support a live tree and deals with
some fallout (i.e. the need to restructure the code such, that we
don't need multiple discontinuous #if CONFIG_IS_ENABLED blocks).

Signed-off-by: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>
Reviewed-by: Simon Glass <sjg@chromium.org>
Acked-by: Philipp Tomsich <philipp.tomsich@theobroma-systems.com>
---
 drivers/timer/timer-uclass.c | 45 ++++++++++++++++++++++----------------------
 1 file changed, 23 insertions(+), 22 deletions(-)

diff --git a/drivers/timer/timer-uclass.c b/drivers/timer/timer-uclass.c
index a84755f4c5..62d6f0b29a 100644
--- a/drivers/timer/timer-uclass.c
+++ b/drivers/timer/timer-uclass.c
@@ -8,6 +8,7 @@
 #include <dm.h>
 #include <dm/lists.h>
 #include <dm/device-internal.h>
+#include <dm/root.h>
 #include <clk.h>
 #include <errno.h>
 #include <timer.h>
@@ -54,9 +55,10 @@ static int timer_pre_probe(struct udevice *dev)
 		if (IS_ERR_VALUE(ret))
 			return ret;
 		uc_priv->clock_rate = ret;
-	} else
-		uc_priv->clock_rate = fdtdec_get_int(gd->fdt_blob,
-				dev_of_offset(dev),	"clock-frequency", 0);
+	} else {
+		uc_priv->clock_rate =
+			dev_read_u32_default(dev, "clock-frequency", 0);
+	}
 #endif
 
 	return 0;
@@ -83,9 +85,8 @@ u64 timer_conv_64(u32 count)
 
 int notrace dm_timer_init(void)
 {
-	__maybe_unused const void *blob = gd->fdt_blob;
 	struct udevice *dev = NULL;
-	int node = -ENOENT;
+	__maybe_unused ofnode node;
 	int ret;
 
 	if (gd->timer)
@@ -93,27 +94,27 @@ int notrace dm_timer_init(void)
 
 #if !CONFIG_IS_ENABLED(OF_PLATDATA)
 	/* Check for a chosen timer to be used for tick */
-	node = fdtdec_get_chosen_node(blob, "tick-timer");
+	node = ofnode_get_chosen_node("tick-timer");
+
+	if (ofnode_valid(node) &&
+	    uclass_get_device_by_ofnode(UCLASS_TIMER, node, &dev)) {
+		/*
+		 * If the timer is not marked to be bound before
+		 * relocation, bind it anyway.
+		 */
+		if (!lists_bind_fdt(dm_root(), node, &dev)) {
+			ret = device_probe(dev);
+			if (ret)
+				return ret;
+		}
+	}
 #endif
-	if (node < 0) {
-		/* No chosen timer, trying first available timer */
+
+	if (!dev) {
+		/* Fall back to the first available timer */
 		ret = uclass_first_device_err(UCLASS_TIMER, &dev);
 		if (ret)
 			return ret;
-	} else {
-		if (uclass_get_device_by_of_offset(UCLASS_TIMER, node, &dev)) {
-			/*
-			 * If the timer is not marked to be bound before
-			 * relocation, bind it anyway.
-			 */
-			if (node > 0 &&
-			    !lists_bind_fdt(gd->dm_root, offset_to_ofnode(node),
-					    &dev)) {
-				ret = device_probe(dev);
-				if (ret)
-					return ret;
-			}
-		}
 	}
 
 	if (dev) {
-- 
2.13.6

