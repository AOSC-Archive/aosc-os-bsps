From 5df91f1c82af1b2a87a1e028de7ddd092c313655 Mon Sep 17 00:00:00 2001
From: Bin Meng <bmeng.cn@gmail.com>
Date: Tue, 15 Aug 2017 22:41:56 -0700
Subject: [PATCH 178/256] x86: dm: video: Add a framebuffer driver that
 utilizes VBT

When a VBT is given to an FSP that supports graphics initialization,
the FSP will produce a graphics info HOB that contains all necessary
information for the linear frame buffer of the integrated graphics
device. This adds a DM video driver for it.

Signed-off-by: Bin Meng <bmeng.cn@gmail.com>
Reviewed-by: Simon Glass <sjg@chromium.org>
---
 arch/x86/Kconfig                |   8 +++
 arch/x86/lib/fsp/Makefile       |   1 +
 arch/x86/lib/fsp/fsp_graphics.c | 124 ++++++++++++++++++++++++++++++++++++++++
 3 files changed, 133 insertions(+)
 create mode 100644 arch/x86/lib/fsp/fsp_graphics.c

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index ddcee1bbe0..cda11d296b 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -592,6 +592,14 @@ config VBT_ADDR
 	  example, base address of 0xfff90000 indicates that the image will
 	  be put at offset 0x90000 from the beginning of a 1MB flash device.
 
+config VIDEO_FSP
+	bool "Enable FSP framebuffer driver support"
+	depends on HAVE_VBT && DM_VIDEO
+	help
+	  Turn on this option to enable a framebuffer driver when U-Boot is
+	  using Video BIOS Table (VBT) image for FSP firmware to initialize
+	  the integrated graphics device.
+
 config ROM_TABLE_ADDR
 	hex
 	default 0xf0000
diff --git a/arch/x86/lib/fsp/Makefile b/arch/x86/lib/fsp/Makefile
index 3ea4880a30..afe83dd324 100644
--- a/arch/x86/lib/fsp/Makefile
+++ b/arch/x86/lib/fsp/Makefile
@@ -8,4 +8,5 @@ obj-y += cmd_fsp.o
 obj-y += fsp_car.o
 obj-y += fsp_common.o
 obj-y += fsp_dram.o
+obj-$(CONFIG_VIDEO_FSP) += fsp_graphics.o
 obj-y += fsp_support.o
diff --git a/arch/x86/lib/fsp/fsp_graphics.c b/arch/x86/lib/fsp/fsp_graphics.c
new file mode 100644
index 0000000000..a19b067f8f
--- /dev/null
+++ b/arch/x86/lib/fsp/fsp_graphics.c
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2017, Bin Meng <bmeng.cn@gmail.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <vbe.h>
+#include <video.h>
+#include <asm/fsp/fsp_support.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct pixel {
+	u8 pos;
+	u8 size;
+};
+
+static const struct fsp_framebuffer {
+	struct pixel red;
+	struct pixel green;
+	struct pixel blue;
+	struct pixel rsvd;
+} fsp_framebuffer_format_map[] = {
+	[pixel_rgbx_8bpc] = { {0, 8}, {8, 8}, {16, 8}, {24, 8} },
+	[pixel_bgrx_8bpc] = { {16, 8}, {8, 8}, {0, 8}, {24, 8} },
+};
+
+static int save_vesa_mode(struct vesa_mode_info *vesa)
+{
+	const struct hob_graphics_info *ginfo;
+	const struct fsp_framebuffer *fbinfo;
+
+	ginfo = fsp_get_graphics_info(gd->arch.hob_list, NULL);
+
+	/*
+	 * If there is no graphics info structure, bail out and keep
+	 * running on the serial console.
+	 */
+	if (!ginfo) {
+		debug("FSP graphics hand-off block not found\n");
+		return -ENXIO;
+	}
+
+	vesa->x_resolution = ginfo->width;
+	vesa->y_resolution = ginfo->height;
+	vesa->bits_per_pixel = 32;
+	vesa->bytes_per_scanline = ginfo->pixels_per_scanline * 4;
+	vesa->phys_base_ptr = ginfo->fb_base;
+
+	if (ginfo->pixel_format >= pixel_bitmask) {
+		debug("FSP set unknown framebuffer format: %d\n",
+		      ginfo->pixel_format);
+		return -EINVAL;
+	}
+	fbinfo = &fsp_framebuffer_format_map[ginfo->pixel_format];
+	vesa->red_mask_size = fbinfo->red.size;
+	vesa->red_mask_pos = fbinfo->red.pos;
+	vesa->green_mask_size = fbinfo->green.size;
+	vesa->green_mask_pos = fbinfo->green.pos;
+	vesa->blue_mask_size = fbinfo->blue.size;
+	vesa->blue_mask_pos = fbinfo->blue.pos;
+	vesa->reserved_mask_size = fbinfo->rsvd.size;
+	vesa->reserved_mask_pos = fbinfo->rsvd.pos;
+
+	return 0;
+}
+
+static int fsp_video_probe(struct udevice *dev)
+{
+	struct video_uc_platdata *plat = dev_get_uclass_platdata(dev);
+	struct video_priv *uc_priv = dev_get_uclass_priv(dev);
+	struct vesa_mode_info *vesa = &mode_info.vesa;
+	int ret;
+
+	printf("Video: ");
+
+	/* Initialize vesa_mode_info structure */
+	ret = save_vesa_mode(vesa);
+	if (ret)
+		goto err;
+
+	/*
+	 * The framebuffer base address in the FSP graphics info HOB reflects
+	 * the value assigned by the FSP. After PCI enumeration the framebuffer
+	 * base address may be relocated. Let's get the updated one from device.
+	 *
+	 * For IGD, it seems to be always on BAR2.
+	 */
+	vesa->phys_base_ptr = dm_pci_read_bar32(dev, 2);
+
+	ret = vbe_setup_video_priv(vesa, uc_priv, plat);
+	if (ret)
+		goto err;
+
+	printf("%dx%dx%d\n", uc_priv->xsize, uc_priv->ysize,
+	       vesa->bits_per_pixel);
+
+	return 0;
+
+err:
+	printf("No video mode configured in FSP!\n");
+	return ret;
+}
+
+static const struct udevice_id fsp_video_ids[] = {
+	{ .compatible = "fsp-fb" },
+	{ }
+};
+
+U_BOOT_DRIVER(fsp_video) = {
+	.name	= "fsp_video",
+	.id	= UCLASS_VIDEO,
+	.of_match = fsp_video_ids,
+	.probe	= fsp_video_probe,
+};
+
+static struct pci_device_id fsp_video_supported[] = {
+	{ PCI_DEVICE_CLASS(PCI_CLASS_DISPLAY_VGA << 8, 0xffff00) },
+	{ },
+};
+
+U_BOOT_PCI_DEVICE(fsp_video, fsp_video_supported);
-- 
2.13.6

