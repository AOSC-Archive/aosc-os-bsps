From 2e794614838292499910060509d3c4a7aaed986a Mon Sep 17 00:00:00 2001
From: Rob Clark <robdclark@gmail.com>
Date: Mon, 11 Sep 2017 16:53:08 -0400
Subject: [PATCH 121/256] lib: strto: fix incorrect handling of specified base

The strto functions should honor the specified base (if non-zero) rather
than permitting a hex or octal string when the user wanted (for example)
base 10.

This has been fixed somewhere along the way in the upstream linux kernel
src tree, at some point after these was copied in to u-boot.  And also
in a way that duplicates less code.  So port _parse_integer_fixup_radix()
to u-boot.

Signed-off-by: Rob Clark <robdclark@gmail.com>
Reviewed-by: Simon Glass <sjg@chromium.org>
---
 lib/strto.c | 45 +++++++++++++++++++--------------------------
 1 file changed, 19 insertions(+), 26 deletions(-)

diff --git a/lib/strto.c b/lib/strto.c
index e93a4f5491..7f6076909a 100644
--- a/lib/strto.c
+++ b/lib/strto.c
@@ -13,25 +13,30 @@
 #include <errno.h>
 #include <linux/ctype.h>
 
+/* from lib/kstrtox.c */
+static const char *_parse_integer_fixup_radix(const char *s, unsigned int *base)
+{
+	if (*base == 0) {
+		if (s[0] == '0') {
+			if (tolower(s[1]) == 'x' && isxdigit(s[2]))
+				*base = 16;
+			else
+				*base = 8;
+		} else
+			*base = 10;
+	}
+	if (*base == 16 && s[0] == '0' && tolower(s[1]) == 'x')
+		s += 2;
+	return s;
+}
+
 unsigned long simple_strtoul(const char *cp, char **endp,
 				unsigned int base)
 {
 	unsigned long result = 0;
 	unsigned long value;
 
-	if (*cp == '0') {
-		cp++;
-		if ((*cp == 'x') && isxdigit(cp[1])) {
-			base = 16;
-			cp++;
-		}
-
-		if (!base)
-			base = 8;
-	}
-
-	if (!base)
-		base = 10;
+	cp = _parse_integer_fixup_radix(cp, &base);
 
 	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
 	    ? toupper(*cp) : *cp)-'A'+10) < base) {
@@ -128,19 +133,7 @@ unsigned long long simple_strtoull(const char *cp, char **endp,
 {
 	unsigned long long result = 0, value;
 
-	if (*cp == '0') {
-		cp++;
-		if ((*cp == 'x') && isxdigit(cp[1])) {
-			base = 16;
-			cp++;
-		}
-
-		if (!base)
-			base = 8;
-	}
-
-	if (!base)
-		base = 10;
+	cp = _parse_integer_fixup_radix(cp, &base);
 
 	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp - '0'
 		: (islower(*cp) ? toupper(*cp) : *cp) - 'A' + 10) < base) {
-- 
2.13.6

