From fd0a3e347ae276b38d88949b196382a92d556fac Mon Sep 17 00:00:00 2001
From: LABBE Corentin <clabbe.montjoie@gmail.com>
Date: Fri, 1 Jul 2016 10:35:38 +0200
Subject: [PATCH] ethernet: sun8i-emac: add optional phy regulator

Some PHY could have a regulator, this patch add support for thoses.

Signed-off-by: Corentin Labbe <clabbe.montjoie@gmail.com>
---
 drivers/net/ethernet/allwinner/sun8i-emac.c | 27 +++++++++++++++++++++++++++
 1 file changed, 27 insertions(+)

diff --git a/drivers/net/ethernet/allwinner/sun8i-emac.c b/drivers/net/ethernet/allwinner/sun8i-emac.c
index 1f41924..7180510 100644
--- a/drivers/net/ethernet/allwinner/sun8i-emac.c
+++ b/drivers/net/ethernet/allwinner/sun8i-emac.c
@@ -27,6 +27,7 @@
 #include <linux/pinctrl/consumer.h>
 #include <linux/pinctrl/pinctrl.h>
 #include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
 #include <linux/reset.h>
 #include <linux/scatterlist.h>
 #include <linux/skbuff.h>
@@ -316,6 +317,7 @@ struct sun8i_emac_priv {
 	struct device_node *mdio_node;
 	struct clk *ahb_clk;
 	struct clk *ephy_clk;
+	struct regulator *regulator;
 	bool use_internal_phy;
 
 	struct reset_control *rst_mac;
@@ -1156,8 +1158,17 @@ static int sun8i_emac_power(struct net_device *ndev)
 		}
 	}
 
+	if (priv->regulator) {
+		ret = regulator_enable(priv->regulator);
+		if (ret)
+			goto err_regulator;
+	}
+
 	return 0;
 
+err_regulator:
+	if (priv->rst_ephy)
+		reset_control_assert(priv->rst_ephy);
 err_ephy_reset:
 	if (priv->ephy_clk)
 		clk_disable_unprepare(priv->ephy_clk);
@@ -1174,6 +1185,9 @@ static void sun8i_emac_unpower(struct net_device *ndev)
 {
 	struct sun8i_emac_priv *priv = netdev_priv(ndev);
 
+	if (priv->regulator)
+		regulator_disable(priv->regulator);
+
 	if (priv->rst_ephy)
 		reset_control_assert(priv->rst_ephy);
 
@@ -2209,6 +2223,19 @@ static int sun8i_emac_probe(struct platform_device *pdev)
 		}
 	}
 
+	/* Optional regulator for PHY */
+	priv->regulator = devm_regulator_get_optional(&pdev->dev, "phy");
+	if (IS_ERR(priv->regulator)) {
+		if (PTR_ERR(priv->regulator) == -EPROBE_DEFER) {
+			ret = -EPROBE_DEFER;
+			goto probe_err;
+		}
+		dev_dbg(&pdev->dev, "no PHY regulator found\n");
+		priv->regulator = NULL;
+	} else {
+		dev_info(&pdev->dev, "PHY regulator found\n");
+	}
+
 	priv->irq = platform_get_irq(pdev, 0);
 	if (priv->irq < 0) {
 		ret = priv->irq;
