From 964cadc445f1437e63f1d2b4fffd233ac053c6e6 Mon Sep 17 00:00:00 2001
From: Simon Glass <sjg@chromium.org>
Date: Mon, 11 Jun 2018 13:07:18 -0600
Subject: [PATCH 010/144] dm: core: Add a function to decode a memory region

Add a way to decode a memory region, including the memory type (sram or
sdram) and its start address and size.

Signed-off-by: Simon Glass <sjg@chromium.org>
---
 drivers/core/of_extra.c | 81 +++++++++++++++++++++++++++++++++++++++++
 include/dm/of_extra.h   | 45 +++++++++++++++++++++++
 2 files changed, 126 insertions(+)

diff --git a/drivers/core/of_extra.c b/drivers/core/of_extra.c
index 3243caa5d1..aa48917ddd 100644
--- a/drivers/core/of_extra.c
+++ b/drivers/core/of_extra.c
@@ -34,3 +34,84 @@ int ofnode_read_fmap_entry(ofnode node, struct fmap_entry *entry)
 
 	return 0;
 }
+
+int ofnode_decode_region(ofnode node, const char *prop_name, fdt_addr_t *basep,
+			 fdt_size_t *sizep)
+{
+	const fdt_addr_t *cell;
+	int len;
+
+	debug("%s: %s: %s\n", __func__, ofnode_get_name(node), prop_name);
+	cell = ofnode_get_property(node, prop_name, &len);
+	if (!cell || (len < sizeof(fdt_addr_t) * 2)) {
+		debug("cell=%p, len=%d\n", cell, len);
+		return -1;
+	}
+
+	*basep = fdt_addr_to_cpu(*cell);
+	*sizep = fdt_size_to_cpu(cell[1]);
+	debug("%s: base=%08lx, size=%lx\n", __func__, (ulong)*basep,
+	      (ulong)*sizep);
+
+	return 0;
+}
+
+int ofnode_decode_memory_region(ofnode config_node, const char *mem_type,
+				const char *suffix, fdt_addr_t *basep,
+				fdt_size_t *sizep)
+{
+	char prop_name[50];
+	const char *mem;
+	fdt_size_t size, offset_size;
+	fdt_addr_t base, offset;
+	ofnode node;
+
+	if (!ofnode_valid(config_node)) {
+		config_node = ofnode_path("/config");
+		if (!ofnode_valid(config_node)) {
+			debug("%s: Cannot find /config node\n", __func__);
+			return -ENOENT;
+		}
+	}
+	if (!suffix)
+		suffix = "";
+
+	snprintf(prop_name, sizeof(prop_name), "%s-memory%s", mem_type,
+		 suffix);
+	mem = ofnode_read_string(config_node, prop_name);
+	if (!mem) {
+		debug("%s: No memory type for '%s', using /memory\n", __func__,
+		      prop_name);
+		mem = "/memory";
+	}
+
+	node = ofnode_path(mem);
+	if (!ofnode_valid(node)) {
+		debug("%s: Failed to find node '%s'\n", __func__, mem);
+		return -ENOENT;
+	}
+
+	/*
+	 * Not strictly correct - the memory may have multiple banks. We just
+	 * use the first
+	 */
+	if (ofnode_decode_region(node, "reg", &base, &size)) {
+		debug("%s: Failed to decode memory region %s\n", __func__,
+		      mem);
+		return -EINVAL;
+	}
+
+	snprintf(prop_name, sizeof(prop_name), "%s-offset%s", mem_type,
+		 suffix);
+	if (ofnode_decode_region(config_node, prop_name, &offset,
+				 &offset_size)) {
+		debug("%s: Failed to decode memory region '%s'\n", __func__,
+		      prop_name);
+		return -EINVAL;
+	}
+
+	*basep = base + offset;
+	*sizep = offset_size;
+
+	return 0;
+}
diff --git a/include/dm/of_extra.h b/include/dm/of_extra.h
index e1540c1fbd..97988b6663 100644
--- a/include/dm/of_extra.h
+++ b/include/dm/of_extra.h
@@ -40,4 +40,49 @@ struct fmap_entry {
  */
 int ofnode_read_fmap_entry(ofnode node, struct fmap_entry *entry);
 
+/**
+ * ofnode_decode_region() - Decode a memory region from a node
+ *
+ * Look up a property in a node which contains a memory region address and
+ * size. Then return a pointer to this address.
+ *
+ * The property must hold one address with a length. This is only tested on
+ * 32-bit machines.
+ *
+ * @param node		ofnode to examine
+ * @param prop_name	name of property to find
+ * @param basep		Returns base address of region
+ * @param size		Returns size of region
+ * @return 0 if ok, -1 on error (property not found)
+ */
+int ofnode_decode_region(ofnode node, const char *prop_name, fdt_addr_t *basep,
+			 fdt_size_t *sizep);
+
+/**
+ * ofnode_decode_memory_region()- Decode a named region within a memory bank
+ *
+ * This function handles selection of a memory region. The region is
+ * specified as an offset/size within a particular type of memory.
+ *
+ * The properties used are:
+ *
+ *	<mem_type>-memory<suffix> for the name of the memory bank
+ *	<mem_type>-offset<suffix> for the offset in that bank
+ *
+ * The property value must have an offset and a size. The function checks
+ * that the region is entirely within the memory bank.5
+ *
+ * @param node		ofnode containing the properties (-1 for /config)
+ * @param mem_type	Type of memory to use, which is a name, such as
+ *			"u-boot" or "kernel".
+ * @param suffix	String to append to the memory/offset
+ *			property names
+ * @param basep		Returns base of region
+ * @param sizep		Returns size of region
+ * @return 0 if OK, -ive on error
+ */
+int ofnode_decode_memory_region(ofnode config_node, const char *mem_type,
+				const char *suffix, fdt_addr_t *basep,
+				fdt_size_t *sizep);
+
 #endif
-- 
2.18.0

