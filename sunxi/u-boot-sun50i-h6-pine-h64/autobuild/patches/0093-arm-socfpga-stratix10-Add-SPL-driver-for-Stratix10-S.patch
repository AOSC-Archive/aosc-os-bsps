From 4765ddb0dab0ebd972f30725ca4397a93ee7272b Mon Sep 17 00:00:00 2001
From: Ley Foon Tan <ley.foon.tan@intel.com>
Date: Thu, 24 May 2018 00:17:28 +0800
Subject: [PATCH 093/144] arm: socfpga: stratix10: Add SPL driver for Stratix10
 SoC

Add SPL driver support for Stratix SoC

Signed-off-by: Chin Liang See <chin.liang.see@intel.com>
Signed-off-by: Ley Foon Tan <ley.foon.tan@intel.com>
---
 arch/arm/mach-socfpga/Makefile                |   4 +
 .../mach-socfpga/include/mach/firewall_s10.h  | 120 +++++++++++
 arch/arm/mach-socfpga/spl_s10.c               | 199 ++++++++++++++++++
 3 files changed, 323 insertions(+)
 create mode 100644 arch/arm/mach-socfpga/include/mach/firewall_s10.h
 create mode 100644 arch/arm/mach-socfpga/spl_s10.c

diff --git a/arch/arm/mach-socfpga/Makefile b/arch/arm/mach-socfpga/Makefile
index e8a1c0f45a..3131949d68 100644
--- a/arch/arm/mach-socfpga/Makefile
+++ b/arch/arm/mach-socfpga/Makefile
@@ -38,6 +38,7 @@ obj-y	+= system_manager_s10.o
 obj-y	+= wrap_pinmux_config_s10.o
 obj-y	+= wrap_pll_config_s10.o
 endif
+
 ifdef CONFIG_SPL_BUILD
 ifdef CONFIG_TARGET_SOCFPGA_GEN5
 obj-y	+= spl_gen5.o
@@ -49,6 +50,9 @@ endif
 ifdef CONFIG_TARGET_SOCFPGA_ARRIA10
 obj-y	+= spl_a10.o
 endif
+ifdef CONFIG_TARGET_SOCFPGA_STRATIX10
+obj-y	+= spl_s10.o
+endif
 endif
 
 ifdef CONFIG_TARGET_SOCFPGA_GEN5
diff --git a/arch/arm/mach-socfpga/include/mach/firewall_s10.h b/arch/arm/mach-socfpga/include/mach/firewall_s10.h
new file mode 100644
index 0000000000..b96f779f14
--- /dev/null
+++ b/arch/arm/mach-socfpga/include/mach/firewall_s10.h
@@ -0,0 +1,120 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2017-2018 Intel Corporation <www.intel.com>
+ *
+ */
+
+#ifndef	_FIREWALL_S10_
+#define	_FIREWALL_S10_
+
+struct socfpga_firwall_l4_per {
+	u32	nand;		/* 0x00 */
+	u32	nand_data;
+	u32	_pad_0x8;
+	u32	usb0;
+	u32	usb1;		/* 0x10 */
+	u32	_pad_0x14;
+	u32	_pad_0x18;
+	u32	spim0;
+	u32	spim1;		/* 0x20 */
+	u32	spis0;
+	u32	spis1;
+	u32	emac0;
+	u32	emac1;		/* 0x30 */
+	u32	emac2;
+	u32	_pad_0x38;
+	u32	_pad_0x3c;
+	u32	sdmmc;		/* 0x40 */
+	u32	gpio0;
+	u32	gpio1;
+	u32	_pad_0x4c;
+	u32	i2c0;		/* 0x50 */
+	u32	i2c1;
+	u32	i2c2;
+	u32	i2c3;
+	u32	i2c4;		/* 0x60 */
+	u32	timer0;
+	u32	timer1;
+	u32	uart0;
+	u32	uart1;		/* 0x70 */
+};
+
+struct socfpga_firwall_l4_sys {
+	u32	_pad_0x00;		/* 0x00 */
+	u32	_pad_0x04;
+	u32	dma_ecc;
+	u32	emac0rx_ecc;
+	u32	emac0tx_ecc;		/* 0x10 */
+	u32	emac1rx_ecc;
+	u32	emac1tx_ecc;
+	u32	emac2rx_ecc;
+	u32	emac2tx_ecc;		/* 0x20 */
+	u32	_pad_0x24;
+	u32	_pad_0x28;
+	u32	nand_ecc;
+	u32	nand_read_ecc;		/* 0x30 */
+	u32	nand_write_ecc;
+	u32	ocram_ecc;
+	u32	_pad_0x3c;
+	u32	sdmmc_ecc;		/* 0x40 */
+	u32	usb0_ecc;
+	u32	usb1_ecc;
+	u32	clock_manager;
+	u32	_pad_0x50;		/* 0x50 */
+	u32	io_manager;
+	u32	reset_manager;
+	u32	system_manager;
+	u32	osc0_timer;		/* 0x60 */
+	u32	osc1_timer;
+	u32	watchdog0;
+	u32	watchdog1;
+	u32	watchdog2;		/* 0x70 */
+	u32	watchdog3;
+};
+
+#define FIREWALL_L4_DISABLE_ALL		(BIT(0) | BIT(24) | BIT(16))
+#define FIREWALL_BRIDGE_DISABLE_ALL	(~0)
+
+/* Cache coherency unit (CCU) registers */
+#define CCU_CPU0_MPRT_ADBASE_DDRREG		0x4400
+#define CCU_CPU0_MPRT_ADBASE_MEMSPACE0		0x45c0
+#define CCU_CPU0_MPRT_ADBASE_MEMSPACE1A		0x45e0
+#define CCU_CPU0_MPRT_ADBASE_MEMSPACE1B		0x4600
+#define CCU_CPU0_MPRT_ADBASE_MEMSPACE1C		0x4620
+#define CCU_CPU0_MPRT_ADBASE_MEMSPACE1D		0x4640
+#define CCU_CPU0_MPRT_ADBASE_MEMSPACE1E		0x4660
+
+#define CCU_CPU0_MPRT_ADMASK_MEM_RAM0		0x4688
+
+#define CCU_IOM_MPRT_ADBASE_MEMSPACE0		0x18560
+#define CCU_IOM_MPRT_ADBASE_MEMSPACE1A		0x18580
+#define CCU_IOM_MPRT_ADBASE_MEMSPACE1B		0x185a0
+#define CCU_IOM_MPRT_ADBASE_MEMSPACE1C		0x185c0
+#define CCU_IOM_MPRT_ADBASE_MEMSPACE1D		0x185e0
+#define CCU_IOM_MPRT_ADBASE_MEMSPACE1E		0x18600
+
+#define CCU_IOM_MPRT_ADMASK_MEM_RAM0		0x18628
+
+#define CCU_ADMASK_P_MASK			BIT(0)
+#define CCU_ADMASK_NS_MASK			BIT(1)
+
+#define CCU_ADBASE_DI_MASK			BIT(4)
+
+#define CCU_REG_ADDR(reg)			\
+	(SOCFPGA_CCU_ADDRESS + (reg))
+
+/* Firewall MPU DDR SCR registers */
+#define FW_MPU_DDR_SCR_EN				0x00
+#define FW_MPU_DDR_SCR_EN_SET				0x04
+#define FW_MPU_DDR_SCR_MPUREGION0ADDR_LIMIT		0x18
+#define FW_MPU_DDR_SCR_MPUREGION0ADDR_LIMITEXT		0x1c
+#define FW_MPU_DDR_SCR_NONMPUREGION0ADDR_LIMIT		0x98
+#define FW_MPU_DDR_SCR_NONMPUREGION0ADDR_LIMITEXT	0x9c
+
+#define MPUREGION0_ENABLE				BIT(0)
+#define NONMPUREGION0_ENABLE				BIT(8)
+
+#define FW_MPU_DDR_SCR_WRITEL(data, reg)		\
+	writel(data, SOCFPGA_FW_MPU_DDR_SCR_ADDRESS + (reg))
+
+#endif /* _FIREWALL_S10_ */
diff --git a/arch/arm/mach-socfpga/spl_s10.c b/arch/arm/mach-socfpga/spl_s10.c
new file mode 100644
index 0000000000..69c2ee3d69
--- /dev/null
+++ b/arch/arm/mach-socfpga/spl_s10.c
@@ -0,0 +1,199 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2016-2018 Intel Corporation <www.intel.com>
+ *
+ */
+
+#include <asm/io.h>
+#include <asm/u-boot.h>
+#include <asm/utils.h>
+#include <common.h>
+#include <image.h>
+#include <spl.h>
+#include <asm/arch/clock_manager.h>
+#include <asm/arch/firewall_s10.h>
+#include <asm/arch/mailbox_s10.h>
+#include <asm/arch/reset_manager.h>
+#include <asm/arch/sdram_s10.h>
+#include <asm/arch/system_manager.h>
+#include <watchdog.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static struct socfpga_system_manager *sysmgr_regs =
+	(struct socfpga_system_manager *)SOCFPGA_SYSMGR_ADDRESS;
+
+u32 spl_boot_device(void)
+{
+	/* TODO: Get from SDM or handoff */
+	return BOOT_DEVICE_MMC1;
+}
+
+#ifdef CONFIG_SPL_MMC_SUPPORT
+u32 spl_boot_mode(const u32 boot_device)
+{
+#if defined(CONFIG_SPL_FAT_SUPPORT) || defined(CONFIG_SPL_EXT_SUPPORT)
+	return MMCSD_MODE_FS;
+#else
+	return MMCSD_MODE_RAW;
+#endif
+}
+#endif
+
+void spl_disable_firewall_l4_per(void)
+{
+	const struct socfpga_firwall_l4_per *firwall_l4_per_base =
+		(struct socfpga_firwall_l4_per *)SOCFPGA_FIREWALL_L4_PER;
+	u32 i;
+	const u32 *addr[] = {
+			&firwall_l4_per_base->nand,
+			&firwall_l4_per_base->nand_data,
+			&firwall_l4_per_base->usb0,
+			&firwall_l4_per_base->usb1,
+			&firwall_l4_per_base->spim0,
+			&firwall_l4_per_base->spim1,
+			&firwall_l4_per_base->emac0,
+			&firwall_l4_per_base->emac1,
+			&firwall_l4_per_base->emac2,
+			&firwall_l4_per_base->sdmmc,
+			&firwall_l4_per_base->gpio0,
+			&firwall_l4_per_base->gpio1,
+			&firwall_l4_per_base->i2c0,
+			&firwall_l4_per_base->i2c1,
+			&firwall_l4_per_base->i2c2,
+			&firwall_l4_per_base->i2c3,
+			&firwall_l4_per_base->i2c4,
+			&firwall_l4_per_base->timer0,
+			&firwall_l4_per_base->timer1,
+			&firwall_l4_per_base->uart0,
+			&firwall_l4_per_base->uart1
+			};
+
+	/*
+	 * The following lines of code will enable non-secure access
+	 * to nand, usb, spi, emac, sdmmc, gpio, i2c, timers and uart. This
+	 * is needed as most OS run in non-secure mode. Thus we need to
+	 * enable non-secure access to these peripherals in order for the
+	 * OS to use these peripherals.
+	 */
+	for (i = 0; i < ARRAY_SIZE(addr); i++)
+		writel(FIREWALL_L4_DISABLE_ALL, addr[i]);
+}
+
+void spl_disable_firewall_l4_sys(void)
+{
+	const struct socfpga_firwall_l4_sys *firwall_l4_sys_base =
+		(struct socfpga_firwall_l4_sys *)SOCFPGA_FIREWALL_L4_SYS;
+	u32 i;
+	const u32 *addr[] = {
+			&firwall_l4_sys_base->dma_ecc,
+			&firwall_l4_sys_base->emac0rx_ecc,
+			&firwall_l4_sys_base->emac0tx_ecc,
+			&firwall_l4_sys_base->emac1rx_ecc,
+			&firwall_l4_sys_base->emac1tx_ecc,
+			&firwall_l4_sys_base->emac2rx_ecc,
+			&firwall_l4_sys_base->emac2tx_ecc,
+			&firwall_l4_sys_base->nand_ecc,
+			&firwall_l4_sys_base->nand_read_ecc,
+			&firwall_l4_sys_base->nand_write_ecc,
+			&firwall_l4_sys_base->ocram_ecc,
+			&firwall_l4_sys_base->sdmmc_ecc,
+			&firwall_l4_sys_base->usb0_ecc,
+			&firwall_l4_sys_base->usb1_ecc,
+			&firwall_l4_sys_base->clock_manager,
+			&firwall_l4_sys_base->io_manager,
+			&firwall_l4_sys_base->reset_manager,
+			&firwall_l4_sys_base->system_manager,
+			&firwall_l4_sys_base->watchdog0,
+			&firwall_l4_sys_base->watchdog1,
+			&firwall_l4_sys_base->watchdog2,
+			&firwall_l4_sys_base->watchdog3
+		};
+
+	for (i = 0; i < ARRAY_SIZE(addr); i++)
+		writel(FIREWALL_L4_DISABLE_ALL, addr[i]);
+}
+
+void board_init_f(ulong dummy)
+{
+	const struct cm_config *cm_default_cfg = cm_get_default_config();
+	int ret;
+
+#ifdef CONFIG_HW_WATCHDOG
+	/* Ensure watchdog is paused when debugging is happening */
+	writel(SYSMGR_WDDBG_PAUSE_ALL_CPU, &sysmgr_regs->wddbg);
+
+	/* Enable watchdog before initializing the HW */
+	socfpga_per_reset(SOCFPGA_RESET(L4WD0), 1);
+	socfpga_per_reset(SOCFPGA_RESET(L4WD0), 0);
+	hw_watchdog_init();
+#endif
+
+	/* ensure all processors are not released prior Linux boot */
+	writeq(0, CPU_RELEASE_ADDR);
+
+	socfpga_per_reset(SOCFPGA_RESET(OSC1TIMER0), 0);
+	timer_init();
+
+	populate_sysmgr_pinmux();
+
+	/* configuring the HPS clocks */
+	cm_basic_init(cm_default_cfg);
+
+#ifdef CONFIG_DEBUG_UART
+	socfpga_per_reset(SOCFPGA_RESET(UART0), 0);
+	debug_uart_init();
+#endif
+	ret = spl_early_init();
+	if (ret) {
+		debug("spl_early_init() failed: %d\n", ret);
+		hang();
+	}
+
+	preloader_console_init();
+	cm_print_clock_quick_summary();
+
+	/* enable non-secure interface to DMA330 DMA and peripherals */
+	writel(SYSMGR_DMA_IRQ_NS | SYSMGR_DMA_MGR_NS, &sysmgr_regs->dma);
+	writel(SYSMGR_DMAPERIPH_ALL_NS, &sysmgr_regs->dma_periph);
+
+	spl_disable_firewall_l4_per();
+
+	spl_disable_firewall_l4_sys();
+
+	/* disable lwsocf2fpga and soc2fpga bridge security */
+	writel(FIREWALL_BRIDGE_DISABLE_ALL, SOCFPGA_FIREWALL_SOC2FPGA);
+	writel(FIREWALL_BRIDGE_DISABLE_ALL, SOCFPGA_FIREWALL_LWSOC2FPGA);
+
+	/* disable SMMU security */
+	writel(FIREWALL_L4_DISABLE_ALL, SOCFPGA_FIREWALL_TCU);
+
+	/* disable ocram security at CCU for non secure access */
+	clrbits_le32(CCU_REG_ADDR(CCU_CPU0_MPRT_ADMASK_MEM_RAM0),
+		     CCU_ADMASK_P_MASK | CCU_ADMASK_NS_MASK);
+	clrbits_le32(CCU_REG_ADDR(CCU_IOM_MPRT_ADMASK_MEM_RAM0),
+		     CCU_ADMASK_P_MASK | CCU_ADMASK_NS_MASK);
+
+	debug("DDR: Initializing Hard Memory Controller\n");
+	if (sdram_mmr_init_full(0)) {
+		puts("DDR: Initialization failed.\n");
+		hang();
+	}
+
+	gd->ram_size = sdram_calculate_size();
+	printf("DDR: %d MiB\n", (int)(gd->ram_size >> 20));
+
+	/* Sanity check ensure correct SDRAM size specified */
+	debug("DDR: Running SDRAM size sanity check\n");
+	if (get_ram_size(0, gd->ram_size) != gd->ram_size) {
+		puts("DDR: SDRAM size check failed!\n");
+		hang();
+	}
+	debug("DDR: SDRAM size check passed!\n");
+
+	mbox_init();
+
+#ifdef CONFIG_CADENCE_QSPI
+	mbox_qspi_open();
+#endif
+}
-- 
2.18.0

