From 760b7170c5e44c771397eaf57b7197b621373809 Mon Sep 17 00:00:00 2001
From: Simon Glass <sjg@chromium.org>
Date: Fri, 6 Jul 2018 10:27:31 -0600
Subject: [PATCH 029/144] dtoc: Fix properties with a single zero-arg phandle

At present a property with a single phandle looks like an integer value
to dtoc. Correct this by adjusting it in the phandle-processing code.

Add a test for this.

Signed-off-by: Simon Glass <sjg@chromium.org>
---
 tools/dtoc/dtb_platdata.py       | 12 ++++++++----
 tools/dtoc/dtoc_test_phandle.dts |  6 ++++++
 tools/dtoc/test_dtoc.py          | 10 ++++++++++
 tools/dtoc/test_fdt.py           |  4 +++-
 4 files changed, 27 insertions(+), 5 deletions(-)

diff --git a/tools/dtoc/dtb_platdata.py b/tools/dtoc/dtb_platdata.py
index 2f7302e529..b1323aef19 100644
--- a/tools/dtoc/dtb_platdata.py
+++ b/tools/dtoc/dtb_platdata.py
@@ -211,15 +211,21 @@ class DtbPlatdata(object):
             Number of argument cells is this is a phandle, else None
         """
         if prop.name in ['clocks']:
+            if not isinstance(prop.value, list):
+                prop.value = [prop.value]
             val = prop.value
-            if not isinstance(val, list):
-                val = [val]
             i = 0
 
             max_args = 0
             args = []
             while i < len(val):
                 phandle = fdt_util.fdt32_to_cpu(val[i])
+                # If we get to the end of the list, stop. This can happen
+                # since some nodes have more phandles in the list than others,
+                # but we allocate enough space for the largest list. So those
+                # nodes with shorter lists end up with zeroes at the end.
+                if not phandle:
+                    break
                 target = self._fdt.phandle_to_node.get(phandle)
                 if not target:
                     raise ValueError("Cannot parse '%s' in node '%s'" %
@@ -400,8 +406,6 @@ class DtbPlatdata(object):
                     continue
                 info = self.get_phandle_argc(prop, node.name)
                 if info:
-                    if not isinstance(prop.value, list):
-                        prop.value = [prop.value]
                     # Process the list as pairs of (phandle, id)
                     pos = 0
                     for args in info.args:
diff --git a/tools/dtoc/dtoc_test_phandle.dts b/tools/dtoc/dtoc_test_phandle.dts
index 91dfec5c63..a71acffc69 100644
--- a/tools/dtoc/dtoc_test_phandle.dts
+++ b/tools/dtoc/dtoc_test_phandle.dts
@@ -33,4 +33,10 @@
 		compatible = "source";
 		clocks = <&phandle &phandle_1 11 &phandle_2 12 13 &phandle>;
 	};
+
+	phandle-source2 {
+		u-boot,dm-pre-reloc;
+		compatible = "source";
+		clocks = <&phandle>;
+	};
 };
diff --git a/tools/dtoc/test_dtoc.py b/tools/dtoc/test_dtoc.py
index 20fea522c4..11cac3fc7a 100644
--- a/tools/dtoc/test_dtoc.py
+++ b/tools/dtoc/test_dtoc.py
@@ -323,6 +323,16 @@ U_BOOT_DEVICE(phandle_source) = {
 \t.platdata_size\t= sizeof(dtv_phandle_source),
 };
 
+static struct dtd_source dtv_phandle_source2 = {
+\t.clocks\t\t\t= {
+\t\t\t{&dtv_phandle_target, {}},},
+};
+U_BOOT_DEVICE(phandle_source2) = {
+\t.name\t\t= "source",
+\t.platdata\t= &dtv_phandle_source2,
+\t.platdata_size\t= sizeof(dtv_phandle_source2),
+};
+
 ''', data)
 
     def test_aliases(self):
diff --git a/tools/dtoc/test_fdt.py b/tools/dtoc/test_fdt.py
index 9fef8ed549..49d188b1c1 100755
--- a/tools/dtoc/test_fdt.py
+++ b/tools/dtoc/test_fdt.py
@@ -210,7 +210,9 @@ class TestProp(unittest.TestCase):
 
     def testPhandle(self):
         dtb = fdt.FdtScan('tools/dtoc/dtoc_test_phandle.dts')
-        node = dtb.GetNode('/phandle-source')
+        node = dtb.GetNode('/phandle-source2')
+        prop = node.props['clocks']
+        self.assertTrue(fdt32_to_cpu(prop.value) > 0)
 
     def _ConvertProp(self, prop_name):
         """Helper function to look up a property in self.node and return it
-- 
2.18.0

