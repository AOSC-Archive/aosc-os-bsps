From e46d73fa965b5d9febf251e6dcd3638cca711ae8 Mon Sep 17 00:00:00 2001
From: Lothar Felten <lothar.felten@gmail.com>
Date: Fri, 13 Jul 2018 10:45:28 +0200
Subject: [PATCH 123/144] net: sun8i-emac: support R40 GMAC

Add support for the GMAC found in the Allwinner R40/V40 SoC.

The R40 GMAC interface is not controlled by the syscon register but
has a separate configuration register in the CCU.
The clock gate and reset bits are in a different register compared
to the other SoCs supported by this driver.
The driver uses the -gmac suffix for the R40 because the R40 also
has a different 100 MBit MAC (EMAC).

Signed-off-by: Lothar Felten <lothar.felten@gmail.com>
Reviewed-by: Jagan Teki <jagan@openedev.com>
Tested-by: Jagan Teki <jagan@openedev.com>
---
 drivers/net/sun8i_emac.c | 79 +++++++++++++++++++++++++++-------------
 1 file changed, 53 insertions(+), 26 deletions(-)

diff --git a/drivers/net/sun8i_emac.c b/drivers/net/sun8i_emac.c
index ee3b2aa7f4..3ba3a1ff8b 100644
--- a/drivers/net/sun8i_emac.c
+++ b/drivers/net/sun8i_emac.c
@@ -67,6 +67,7 @@
 
 /* IO mux settings */
 #define SUN8I_IOMUX_H3		2
+#define SUN8I_IOMUX_R40	5
 #define SUN8I_IOMUX		4
 
 /* H3/A64 EMAC Register's offset */
@@ -97,6 +98,7 @@ enum emac_variant {
 	A83T_EMAC = 1,
 	H3_EMAC,
 	A64_EMAC,
+	R40_GMAC,
 };
 
 struct emac_dma_desc {
@@ -278,6 +280,9 @@ static int sun8i_emac_set_syscon(struct emac_eth_dev *priv)
 
 	reg = readl(priv->sysctl_reg + 0x30);
 
+	if (priv->variant == R40_GMAC)
+		return 0;
+
 	if (priv->variant == H3_EMAC) {
 		ret = sun8i_emac_set_syscon_ephy(priv, &reg);
 		if (ret)
@@ -495,6 +500,8 @@ static int parse_phy_pins(struct udevice *dev)
 
 		if (priv->variant == H3_EMAC)
 			sunxi_gpio_set_cfgpin(pin, SUN8I_IOMUX_H3);
+		else if (priv->variant == R40_GMAC)
+			sunxi_gpio_set_cfgpin(pin, SUN8I_IOMUX_R40);
 		else
 			sunxi_gpio_set_cfgpin(pin, SUN8I_IOMUX);
 
@@ -634,11 +641,26 @@ static void sun8i_emac_board_setup(struct emac_eth_dev *priv)
 		}
 	}
 
-	/* Set clock gating for emac */
-	setbits_le32(&ccm->ahb_gate0, BIT(AHB_GATE_OFFSET_GMAC));
-
-	/* De-assert EMAC */
-	setbits_le32(&ccm->ahb_reset0_cfg, BIT(AHB_RESET_OFFSET_GMAC));
+	if (priv->variant == R40_GMAC) {
+		/* Set clock gating for emac */
+		setbits_le32(&ccm->ahb_reset1_cfg, BIT(AHB_RESET_OFFSET_GMAC));
+
+		/* De-assert EMAC */
+		setbits_le32(&ccm->ahb_gate1, BIT(AHB_GATE_OFFSET_GMAC));
+
+		/* Select RGMII for R40 */
+		setbits_le32(&ccm->gmac_clk_cfg,
+			     CCM_GMAC_CTRL_TX_CLK_SRC_INT_RGMII |
+			     CCM_GMAC_CTRL_GPIT_RGMII);
+		setbits_le32(&ccm->gmac_clk_cfg,
+			     CCM_GMAC_CTRL_TX_CLK_DELAY(CONFIG_GMAC_TX_DELAY));
+	} else {
+		/* Set clock gating for emac */
+		setbits_le32(&ccm->ahb_gate0, BIT(AHB_GATE_OFFSET_GMAC));
+
+		/* De-assert EMAC */
+		setbits_le32(&ccm->ahb_reset0_cfg, BIT(AHB_RESET_OFFSET_GMAC));
+	}
 }
 
 #if defined(CONFIG_DM_GPIO)
@@ -805,22 +827,32 @@ static int sun8i_emac_eth_ofdata_to_platdata(struct udevice *dev)
 		return -EINVAL;
 	}
 
-	offset = fdtdec_lookup_phandle(gd->fdt_blob, node, "syscon");
-	if (offset < 0) {
-		debug("%s: cannot find syscon node\n", __func__);
-		return -EINVAL;
-	}
-	reg = fdt_getprop(gd->fdt_blob, offset, "reg", NULL);
-	if (!reg) {
-		debug("%s: cannot find reg property in syscon node\n",
-		      __func__);
+	priv->variant = dev_get_driver_data(dev);
+
+	if (!priv->variant) {
+		printf("%s: Missing variant\n", __func__);
 		return -EINVAL;
 	}
-	priv->sysctl_reg = fdt_translate_address((void *)gd->fdt_blob,
-						 offset, reg);
-	if (priv->sysctl_reg == FDT_ADDR_T_NONE) {
-		debug("%s: Cannot find syscon base address\n", __func__);
-		return -EINVAL;
+
+	if (priv->variant != R40_GMAC) {
+		offset = fdtdec_lookup_phandle(gd->fdt_blob, node, "syscon");
+		if (offset < 0) {
+			debug("%s: cannot find syscon node\n", __func__);
+			return -EINVAL;
+		}
+		reg = fdt_getprop(gd->fdt_blob, offset, "reg", NULL);
+		if (!reg) {
+			debug("%s: cannot find reg property in syscon node\n",
+			      __func__);
+			return -EINVAL;
+		}
+		priv->sysctl_reg = fdt_translate_address((void *)gd->fdt_blob,
+							 offset, reg);
+		if (priv->sysctl_reg == FDT_ADDR_T_NONE) {
+			debug("%s: Cannot find syscon base address\n",
+			      __func__);
+			return -EINVAL;
+		}
 	}
 
 	pdata->phy_interface = -1;
@@ -845,13 +877,6 @@ static int sun8i_emac_eth_ofdata_to_platdata(struct udevice *dev)
 		return -EINVAL;
 	}
 
-	priv->variant = dev_get_driver_data(dev);
-
-	if (!priv->variant) {
-		printf("%s: Missing variant\n", __func__);
-		return -EINVAL;
-	}
-
 	if (priv->variant == H3_EMAC) {
 		int parent = fdt_parent_offset(gd->fdt_blob, offset);
 
@@ -892,6 +917,8 @@ static const struct udevice_id sun8i_emac_eth_ids[] = {
 		.data = (uintptr_t)A64_EMAC },
 	{.compatible = "allwinner,sun8i-a83t-emac",
 		.data = (uintptr_t)A83T_EMAC },
+	{.compatible = "allwinner,sun8i-r40-gmac",
+		.data = (uintptr_t)R40_GMAC },
 	{ }
 };
 
-- 
2.18.0

