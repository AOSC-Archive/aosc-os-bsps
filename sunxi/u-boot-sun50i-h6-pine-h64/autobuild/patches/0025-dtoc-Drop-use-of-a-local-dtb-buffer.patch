From 960662404f492e7088e5a91833dfb0c19ef5450e Mon Sep 17 00:00:00 2001
From: Simon Glass <sjg@chromium.org>
Date: Fri, 6 Jul 2018 10:27:27 -0600
Subject: [PATCH 025/144] dtoc: Drop use of a local dtb buffer

At present the Fdt class has its own copy of the device tree. This is
confusing an unnecessary now that pylibfdt has its own. Drop it and
provide access functions to the buffer.

This allows us to move the rest of the implementation to use pylibfdt
methods instead of directly calling libfdt stubs.

Signed-off-by: Simon Glass <sjg@chromium.org>
---
 tools/dtoc/fdt.py      | 16 ++++++++--------
 tools/dtoc/test_fdt.py |  4 ++--
 2 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/tools/dtoc/fdt.py b/tools/dtoc/fdt.py
index 18cde2604f..e24acf1280 100644
--- a/tools/dtoc/fdt.py
+++ b/tools/dtoc/fdt.py
@@ -235,12 +235,13 @@ class Node:
         Note: This does not take account of property offsets - these will not
         be updated.
         """
+        fdt_obj = self._fdt._fdt_obj
         if self._offset != my_offset:
             self._offset = my_offset
-        offset = libfdt.fdt_first_subnode(self._fdt.GetFdt(), self._offset)
+        offset = fdt_obj.first_subnode(self._offset, QUIET_NOTFOUND)
         for subnode in self.subnodes:
             subnode.Refresh(offset)
-            offset = libfdt.fdt_next_subnode(self._fdt.GetFdt(), offset)
+            offset = fdt_obj.next_subnode(offset, QUIET_NOTFOUND)
 
     def DeleteProp(self, prop_name):
         """Delete a property of a node
@@ -252,7 +253,7 @@ class Node:
         Raises:
             ValueError if the property does not exist
         """
-        CheckErr(libfdt.fdt_delprop(self._fdt.GetFdt(), self.Offset(), prop_name),
+        CheckErr(self._fdt._fdt_obj.delprop(self.Offset(), prop_name),
                  "Node '%s': delete property: '%s'" % (self.path, prop_name))
         del self.props[prop_name]
         self._fdt.Invalidate()
@@ -272,8 +273,7 @@ class Fdt:
             self._fname = fdt_util.EnsureCompiled(self._fname)
 
             with open(self._fname) as fd:
-                self._fdt = bytearray(fd.read())
-                self._fdt_obj = libfdt.Fdt(self._fdt)
+                self._fdt_obj = libfdt.Fdt(fd.read())
 
     def Scan(self, root='/'):
         """Scan a device tree, building up a tree of Node objects
@@ -317,7 +317,7 @@ class Fdt:
         If the device tree has changed in memory, write it back to the file.
         """
         with open(self._fname, 'wb') as fd:
-            fd.write(self._fdt)
+            fd.write(self._fdt_obj.as_bytearray())
 
     def Pack(self):
         """Pack the device tree down to its minimum size
@@ -328,13 +328,13 @@ class Fdt:
         CheckErr(self._fdt_obj.pack(), 'pack')
         self.Invalidate()
 
-    def GetFdt(self):
+    def GetContents(self):
         """Get the contents of the FDT
 
         Returns:
             The FDT contents as a string of bytes
         """
-        return self._fdt
+        return self._fdt_obj.as_bytearray()
 
     def GetFdtObj(self):
         """Get the contents of the FDT
diff --git a/tools/dtoc/test_fdt.py b/tools/dtoc/test_fdt.py
index ba660ca9b7..daa9d128b5 100755
--- a/tools/dtoc/test_fdt.py
+++ b/tools/dtoc/test_fdt.py
@@ -72,7 +72,7 @@ class TestFdt(unittest.TestCase):
 
     def testGetFdt(self):
         """Tetst that we can access the raw device-tree data"""
-        self.assertTrue(isinstance(self.dtb.GetFdt(), bytearray))
+        self.assertTrue(isinstance(self.dtb.GetContents(), bytearray))
 
     def testGetProps(self):
         """Tests obtaining a list of properties"""
@@ -157,7 +157,7 @@ class TestProp(unittest.TestCase):
 
         # Add 12, which is sizeof(struct fdt_property), to get to start of data
         offset = prop.GetOffset() + 12
-        data = self.dtb._fdt[offset:offset + len(prop.value)]
+        data = self.dtb.GetContents()[offset:offset + len(prop.value)]
         bytes = [chr(x) for x in data]
         self.assertEqual(bytes, prop.value)
 
-- 
2.18.0

