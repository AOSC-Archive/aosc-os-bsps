From ff1fd6ccde3d166213d1277fa6b6b9685d45044f Mon Sep 17 00:00:00 2001
From: Simon Glass <sjg@chromium.org>
Date: Fri, 6 Jul 2018 10:27:23 -0600
Subject: [PATCH 021/144] binman: Move coverage logic into a new test_util file

At present only binman has the logic for determining Python test coverage
but this is useful for other tools also. Move it out into a separate file
so it can be used by other tools.

Signed-off-by: Simon Glass <sjg@chromium.org>
---
 tools/binman/binman.py    | 29 +++---------------
 tools/patman/test_util.py | 64 +++++++++++++++++++++++++++++++++++++++
 2 files changed, 68 insertions(+), 25 deletions(-)
 create mode 100644 tools/patman/test_util.py

diff --git a/tools/binman/binman.py b/tools/binman/binman.py
index 74862b1146..52e02ed91b 100755
--- a/tools/binman/binman.py
+++ b/tools/binman/binman.py
@@ -26,6 +26,7 @@ sys.path.insert(0, 'scripts/dtc/pylibfdt')
 import cmdline
 import command
 import control
+import test_util
 
 def RunTests(debug, args):
     """Run the functional tests and any embedded doctests
@@ -78,34 +79,12 @@ def RunTests(debug, args):
 
 def RunTestCoverage():
     """Run the tests and check that we get 100% coverage"""
-    # This uses the build output from sandbox_spl to get _libfdt.so
-    cmd = ('PYTHONPATH=$PYTHONPATH:%s/sandbox_spl/tools python-coverage run '
-            '--include "tools/binman/*.py" --omit "*test*,*binman.py" '
-            'tools/binman/binman.py -t' % options.build_dir)
-    os.system(cmd)
-    stdout = command.Output('python-coverage', 'report')
-    lines = stdout.splitlines()
-
-    test_set= set([os.path.basename(line.split()[0])
-                     for line in lines if '/etype/' in line])
     glob_list = glob.glob(os.path.join(our_path, 'etype/*.py'))
     all_set = set([os.path.splitext(os.path.basename(item))[0]
                    for item in glob_list if '_testing' not in item])
-    missing_list = all_set
-    missing_list.difference_update(test_set)
-    coverage = lines[-1].split(' ')[-1]
-    ok = True
-    if missing_list:
-        print 'Missing tests for %s' % (', '.join(missing_list))
-        print stdout
-        ok = False
-    if coverage != '100%':
-        print stdout
-        print "Type 'coverage html' to get a report in htmlcov/index.html"
-        print 'Coverage error: %s, but should be 100%%' % coverage
-        ok = False
-    if not ok:
-      raise ValueError('Test coverage failure')
+    test_util.RunTestCoverage('tools/binman/binman.py', None,
+            ['*test*', '*binman.py', 'tools/patman/*', 'tools/dtoc/*'],
+            options.build_dir, all_set)
 
 def RunBinman(options, args):
     """Main entry point to binman once arguments are parsed
diff --git a/tools/patman/test_util.py b/tools/patman/test_util.py
new file mode 100644
index 0000000000..1a33c997c4
--- /dev/null
+++ b/tools/patman/test_util.py
@@ -0,0 +1,64 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+# Copyright (c) 2016 Google, Inc
+#
+
+import glob
+import os
+import sys
+
+import command
+
+def RunTestCoverage(prog, filter_fname, exclude_list, build_dir, required=None):
+    """Run tests and check that we get 100% coverage
+
+    Args:
+        prog: Program to run (with be passed a '-t' argument to run tests
+        filter_fname: Normally all *.py files in the program's directory will
+            be included. If this is not None, then it is used to filter the
+            list so that only filenames that don't contain filter_fname are
+            included.
+        exclude_list: List of file patterns to exclude from the coverage
+            calculation
+        build_dir: Build directory, used to locate libfdt.py
+        required: List of modules which must be in the coverage report
+
+    Raises:
+        ValueError if the code coverage is not 100%
+    """
+    # This uses the build output from sandbox_spl to get _libfdt.so
+    path = os.path.dirname(prog)
+    if filter_fname:
+        glob_list = glob.glob(os.path.join(path, '*.py'))
+        glob_list = [fname for fname in glob_list if filter_fname in fname]
+    else:
+        glob_list = []
+    glob_list += exclude_list
+    glob_list += ['*libfdt.py', '*site-packages*']
+    cmd = ('PYTHONPATH=$PYTHONPATH:%s/sandbox_spl/tools python-coverage run '
+           '--omit "%s" %s -t' % (build_dir, ','.join(glob_list), prog))
+    os.system(cmd)
+    stdout = command.Output('python-coverage', 'report')
+    lines = stdout.splitlines()
+    if required:
+        # Convert '/path/to/name.py' just the module name 'name'
+        test_set = set([os.path.splitext(os.path.basename(line.split()[0]))[0]
+                        for line in lines if '/etype/' in line])
+        missing_list = required
+        missing_list.difference_update(test_set)
+        if missing_list:
+            print 'Missing tests for %s' % (', '.join(missing_list))
+            print stdout
+            ok = False
+
+    coverage = lines[-1].split(' ')[-1]
+    ok = True
+    print coverage
+    if coverage != '100%':
+        print stdout
+        print ("Type 'python-coverage html' to get a report in "
+               'htmlcov/index.html')
+        print 'Coverage error: %s, but should be 100%%' % coverage
+        ok = False
+    if not ok:
+        raise ValueError('Test coverage failure')
-- 
2.18.0

