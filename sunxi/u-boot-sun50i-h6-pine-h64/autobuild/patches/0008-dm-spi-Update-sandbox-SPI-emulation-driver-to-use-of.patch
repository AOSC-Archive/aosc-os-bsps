From 008dcddf9937bd2576f98b48eb5bf0f60ad36014 Mon Sep 17 00:00:00 2001
From: Simon Glass <sjg@chromium.org>
Date: Mon, 11 Jun 2018 13:07:16 -0600
Subject: [PATCH 008/144] dm: spi: Update sandbox SPI emulation driver to use
 ofnode

Update the parameters sandbox_sf_bind_emul to support livetree.

Signed-off-by: Simon Glass <sjg@chromium.org>
---
 drivers/mtd/spi/sandbox.c | 9 +++++----
 include/spi_flash.h       | 2 +-
 test/dm/spi.c             | 8 ++++----
 3 files changed, 10 insertions(+), 9 deletions(-)

diff --git a/drivers/mtd/spi/sandbox.c b/drivers/mtd/spi/sandbox.c
index f23c0e13e0..1b6c028251 100644
--- a/drivers/mtd/spi/sandbox.c
+++ b/drivers/mtd/spi/sandbox.c
@@ -556,7 +556,7 @@ static int sandbox_cmdline_cb_spi_sf(struct sandbox_state *state,
 SANDBOX_CMDLINE_OPT(spi_sf, 1, "connect a SPI flash: <bus>:<cs>:<id>:<file>");
 
 int sandbox_sf_bind_emul(struct sandbox_state *state, int busnum, int cs,
-			 struct udevice *bus, int of_offset, const char *spec)
+			 struct udevice *bus, ofnode node, const char *spec)
 {
 	struct udevice *emul;
 	char name[20], *str;
@@ -575,7 +575,7 @@ int sandbox_sf_bind_emul(struct sandbox_state *state, int busnum, int cs,
 	str = strdup(name);
 	if (!str)
 		return -ENOMEM;
-	ret = device_bind(bus, drv, str, NULL, of_offset, &emul);
+	ret = device_bind_ofnode(bus, drv, str, NULL, node, &emul);
 	if (ret) {
 		free(str);
 		printf("Cannot create emul device for spec '%s' (err=%d)\n",
@@ -620,7 +620,8 @@ static int sandbox_sf_bind_bus_cs(struct sandbox_state *state, int busnum,
 	if (ret)
 		return ret;
 
-	return sandbox_sf_bind_emul(state, busnum, cs, bus, -1, spec);
+	return sandbox_sf_bind_emul(state, busnum, cs, bus, ofnode_null(),
+				    spec);
 }
 
 int sandbox_spi_get_emul(struct sandbox_state *state,
@@ -638,7 +639,7 @@ int sandbox_spi_get_emul(struct sandbox_state *state,
 		debug("%s: busnum=%u, cs=%u: binding SPI flash emulation: ",
 		      __func__, busnum, cs);
 		ret = sandbox_sf_bind_emul(state, busnum, cs, bus,
-					   dev_of_offset(slave), slave->name);
+					   dev_ofnode(slave), slave->name);
 		if (ret) {
 			debug("failed (err=%d)\n", ret);
 			return ret;
diff --git a/include/spi_flash.h b/include/spi_flash.h
index 22533311c5..0ec98fb55d 100644
--- a/include/spi_flash.h
+++ b/include/spi_flash.h
@@ -185,7 +185,7 @@ static inline int spi_flash_erase(struct spi_flash *flash, u32 offset,
 struct sandbox_state;
 
 int sandbox_sf_bind_emul(struct sandbox_state *state, int busnum, int cs,
-			 struct udevice *bus, int of_offset, const char *spec);
+			 struct udevice *bus, ofnode node, const char *spec);
 
 void sandbox_sf_unbind_emul(struct sandbox_state *state, int busnum, int cs);
 
diff --git a/test/dm/spi.c b/test/dm/spi.c
index 252b87431f..ffd789cd7f 100644
--- a/test/dm/spi.c
+++ b/test/dm/spi.c
@@ -23,7 +23,7 @@ static int dm_test_spi_find(struct unit_test_state *uts)
 	struct udevice *bus, *dev;
 	const int busnum = 0, cs = 0, mode = 0, speed = 1000000, cs_b = 1;
 	struct spi_cs_info info;
-	int of_offset;
+	ofnode node;
 
 	ut_asserteq(-ENODEV, uclass_find_device_by_seq(UCLASS_SPI, busnum,
 						       false, &bus));
@@ -34,7 +34,7 @@ static int dm_test_spi_find(struct unit_test_state *uts)
 	 */
 	ut_asserteq(0, uclass_get_device_by_seq(UCLASS_SPI, busnum, &bus));
 	ut_assertok(spi_cs_info(bus, cs, &info));
-	of_offset = dev_of_offset(info.dev);
+	node = dev_ofnode(info.dev);
 	device_remove(info.dev, DM_REMOVE_NORMAL);
 	device_unbind(info.dev);
 
@@ -65,7 +65,7 @@ static int dm_test_spi_find(struct unit_test_state *uts)
 	ut_asserteq_ptr(NULL, info.dev);
 
 	/* Add the emulation and try again */
-	ut_assertok(sandbox_sf_bind_emul(state, busnum, cs, bus, of_offset,
+	ut_assertok(sandbox_sf_bind_emul(state, busnum, cs, bus, node,
 					 "name"));
 	ut_assertok(spi_find_bus_and_cs(busnum, cs, &bus, &dev));
 	ut_assertok(spi_get_bus_and_cs(busnum, cs, speed, mode,
@@ -75,7 +75,7 @@ static int dm_test_spi_find(struct unit_test_state *uts)
 	ut_asserteq_ptr(info.dev, slave->dev);
 
 	/* We should be able to add something to another chip select */
-	ut_assertok(sandbox_sf_bind_emul(state, busnum, cs_b, bus, of_offset,
+	ut_assertok(sandbox_sf_bind_emul(state, busnum, cs_b, bus, node,
 					 "name"));
 	ut_assertok(spi_get_bus_and_cs(busnum, cs_b, speed, mode,
 				       "spi_flash_std", "name", &bus, &slave));
-- 
2.18.0

