From 1c976c545fc6d5dafc033d5bdce5c94cd482af76 Mon Sep 17 00:00:00 2001
From: Ondrej Jirman <megous@megous.com>
Date: Thu, 11 Jun 2020 02:42:46 +0200
Subject: [PATCH 90/92] usb: typec: anx7688: Make debug log more useful, fix DR
 swapping

Don't do needless data role swaps/USB resets. Use kernel's PDO
code.

Signed-off-by: Ondrej Jirman <megous@megous.com>
---
 drivers/usb/typec/anx7688.c | 190 ++++++++++++++++++++++--------------
 1 file changed, 115 insertions(+), 75 deletions(-)

diff --git a/drivers/usb/typec/anx7688.c b/drivers/usb/typec/anx7688.c
index 7efce6e31e1a3..62514b1e44ef7 100644
--- a/drivers/usb/typec/anx7688.c
+++ b/drivers/usb/typec/anx7688.c
@@ -1,3 +1,26 @@
+/*
+ * ANX7688 USB-C HDMI bridge/PD driver
+ *
+ * How this works:
+ * - this driver allows to program firmware into ANX7688 EEPROM, and
+ *   initialize it
+ * - it then communicates with the firmware running on the OCM (on-chip
+ *   microcontroller)
+ * - it detects whether there is cable plugged in or not and powers
+ *   up or down the ANX7688 based on that
+ * - when the cable is connected the firmware on the OCM will handle
+ *   the detection of the nature of the device on the other end
+ *   of the USB-C cable
+ * - this driver then communicates with the USB phy to let it swap
+ *   data roles accordingly
+ * - it also enables VBUS and VCONN regulators as appropriate
+ * - when the firmware detects SRC.1.5A or SRC.3.0A via CC pins
+ *   or something else via PD, it notifies this driver via software
+ *   interrupt and this driver notifies the PMIC that the input
+ *   current limit can be increased
+ * - USB phy driver (Allwinner) needs to know whether to switch to
+ *   device or host mode, or whether to turn off
+ */
 #define DEBUG
 
 #include <linux/debugfs.h>
@@ -11,8 +34,9 @@
 #include <linux/module.h>
 #include <linux/of_irq.h>
 #include <linux/regulator/consumer.h>
-#include <linux/usb/typec.h>
+#include <linux/usb/pd.h>
 #include <linux/usb/role.h>
+#include <linux/usb/typec.h>
 
 #define DISABLE_OCM 0
 
@@ -81,6 +105,9 @@
 
 #define ANX7688_IRQ2_SOFT_INT           BIT(2)
 
+#define ANX7688_REG_USBC_RESET_CTRL		0x05
+#define ANX7688_USBC_RESET_CTRL_OCM_RESET	BIT(4)
+
 //#define ANX7688_IRQ2_USB_PLUGIN         BIT(4)
 //#define ANX7688_REG_IRQ_STATUS          0x53
 
@@ -108,42 +135,6 @@
 #define ANX7688_OCM_MSG_HARD_RST        0xf2
 #define ANX7688_OCM_MSG_RESTART         0xf3
 
-#define ANX7688_REG_USBC_RESET_CTRL		0x05
-#define ANX7688_USBC_RESET_CTRL_OCM_RESET	BIT(4)
-
-/* pdo */
-
-#define PDO_TYPE_FIXED		0
-#define PDO_TYPE_BATTERY	(1u << 30)
-#define PDO_TYPE_VARIABLE	(2u << 30)
-#define PDO_TYPE_MASK		(3u << 30)
-
-#define PDO_FIXED_DUAL_ROLE	(1u << 29) /* Dual role device */
-#define PDO_FIXED_SUSPEND	(1u << 28) /* USB Suspend supported */
-#define PDO_FIXED_EXTERNAL	(1u << 27) /* Externally powered */
-#define PDO_FIXED_COMM_CAP	(1u << 26) /* USB Communications Capable */
-#define PDO_FIXED_DATA_SWAP	(1u << 25) /* Data role swap command */
-#define PDO_FIXED_PEAK_CURR(v)	(((v) & 3) << 20) /* [21..20] Peak current */
-#define PDO_FIXED_VOLT(mv)	(((u32)(mv) / 50) << 10)
-#define PDO_FIXED_CURR(ma)	((u32)(ma) / 10)
-
-#define PDO_FIXED(mv, ma, flags) \
-	(PDO_FIXED_VOLT(mv) | PDO_FIXED_CURR(ma) | (flags))
-
-#define PDO_GET_TYPE(pdo)		((pdo) & PDO_TYPE_MASK)
-#define PDO_IS_FIXED_DUAL_ROLE(pdo)	((pdo) & PDO_FIXED_DUAL_ROLE)
-#define PDO_IS_FIXED_SUSPEND(pdo)	((pdo) & PDO_FIXED_SUSPEND)
-#define PDO_IS_FIXED_EXTERNAL(pdo)	((pdo) & PDO_FIXED_EXTERNAL)
-#define PDO_IS_FIXED_COMM_CAP(pdo)	((pdo) & PDO_FIXED_COMM_CAP)
-#define PDO_IS_FIXED_DATA_SWAP(pdo)	((pdo) & PDO_FIXED_DATA_SWAP)
-#define PDO_GET_FIXED_PEAK_CURR(pdo)	(((pdo) >> 20) & 3)
-
-#define PDO_GET_FIXED_VOLT(pdo)		((((pdo) >> 10) & 0x3ff) * 50)
-#define PDO_GET_FIXED_CURR(pdo)		(((pdo) & 0x3ff) * 10)
-#define PDO_GET_VAR_MAX_VOLT(pdo)	((((pdo) >> 20) & 0x3ff) * 50)
-#define PDO_GET_VAR_MIN_VOLT(pdo)	((((pdo) >> 10) & 0x3ff) * 50)
-#define PDO_GET_VAR_MAX_CURR(pdo)	(((pdo) & 0x3ff) * 10)
-
 static const char * const anx7688_supply_names[] = {
         "avdd33",
         "avdd18",
@@ -181,7 +172,7 @@ struct anx7688 {
 	struct timer_list work_timer;
 
         struct mutex lock;
-        bool vbus_on, vconn_on;
+        bool vbus_on, vconn_on, dr_dfp;
 
         struct typec_port *port;
         struct typec_partner *partner;
@@ -189,6 +180,10 @@ struct anx7688 {
 	struct usb_role_switch *role_sw;
 
         struct dentry *debug_root;
+
+	/* for debug */
+	int last_status;
+	int last_cc_status;
 };
 
 static int anx7688_reg_read(struct anx7688 *anx7688, u8 reg_addr)
@@ -371,6 +366,9 @@ static int anx7688_connect(struct anx7688 *anx7688)
 
         dev_dbg(anx7688->dev, "cable inserted\n");
 
+	anx7688->last_status = -1;
+	anx7688->last_cc_status = -1;
+
         msleep(10);
         anx7688_power_enable(anx7688);
 
@@ -464,7 +462,7 @@ static int anx7688_connect(struct anx7688 *anx7688)
 
 	pdo = cpu_to_le32(PDO_FIXED(5000, 500,
 				    PDO_FIXED_DATA_SWAP |
-				    PDO_FIXED_COMM_CAP |
+				    PDO_FIXED_USB_COMM |
 				    PDO_FIXED_DUAL_ROLE));
 	ret = anx7688_send_ocm_message(anx7688, ANX7688_OCM_MSG_PWR_SRC_CAP,
 				       (u8*)&pdo, sizeof pdo);
@@ -474,7 +472,7 @@ static int anx7688_connect(struct anx7688 *anx7688)
 
 	pdo = cpu_to_le32(PDO_FIXED(5000, 3000,
 				    PDO_FIXED_DATA_SWAP |
-				    PDO_FIXED_COMM_CAP |
+				    PDO_FIXED_USB_COMM |
 				    PDO_FIXED_DUAL_ROLE));
 	ret = anx7688_send_ocm_message(anx7688, ANX7688_OCM_MSG_PWR_SNK_CAP,
 				       (u8*)&pdo, sizeof pdo);
@@ -530,7 +528,9 @@ static void anx7688_disconnect(struct anx7688 *anx7688)
         typec_set_vconn_role(anx7688->port, TYPEC_SINK);
         typec_set_data_role(anx7688->port, TYPEC_DEVICE);
 
-	usb_role_switch_set_role(anx7688->role_sw, USB_ROLE_DEVICE);
+	if (anx7688->dr_dfp)
+		usb_role_switch_set_role(anx7688->role_sw, USB_ROLE_DEVICE);
+	anx7688->dr_dfp = 0;
 
 	clear_bit(ANX7688_F_CONNECTED, anx7688->flags);
 }
@@ -542,12 +542,9 @@ static void anx7688_handle_cable_change(struct anx7688* anx7688)
 
         mutex_lock(&anx7688->lock);
 
-        dev_dbg(anx7688->dev, "processing cabledet change (cd=%d)\n",
-                gpiod_get_value(anx7688->gpio_cabledet));
-
 	connected = test_bit(ANX7688_F_CONNECTED, anx7688->flags);
-
         cabledet = gpiod_get_value(anx7688->gpio_cabledet);
+
         if (cabledet && !connected)
                 anx7688_connect(anx7688);
         else if (!cabledet && connected)
@@ -573,6 +570,37 @@ static irqreturn_t anx7688_irq_plug_handler(int irq, void *data)
         return IRQ_HANDLED;
 }
 
+static int anx7688_handle_pd_message(struct anx7688* anx7688,
+				     u8 cmd, u8* msg, unsigned len)
+{
+	switch (cmd) {
+	case ANX7688_OCM_MSG_PWR_SRC_CAP:
+	case ANX7688_OCM_MSG_PWR_SNK_CAP:
+	case ANX7688_OCM_MSG_DP_SNK_IDENTITY:
+	case ANX7688_OCM_MSG_SVID:
+	case ANX7688_OCM_MSG_GET_DP_SNK_CAP:
+	case ANX7688_OCM_MSG_ACCEPT:
+	case ANX7688_OCM_MSG_REJECT:
+	case ANX7688_OCM_MSG_PSWAP_REQ:
+	case ANX7688_OCM_MSG_DSWAP_REQ:
+	case ANX7688_OCM_MSG_GOTO_MIN_REQ:
+	case ANX7688_OCM_MSG_VCONN_SWAP_REQ:
+	case ANX7688_OCM_MSG_VDM:
+	case ANX7688_OCM_MSG_DP_SNK_CFG:
+	case ANX7688_OCM_MSG_PWR_OBJ_REQ:
+	case ANX7688_OCM_MSG_PD_STATUS_REQ:
+	case ANX7688_OCM_MSG_DP_ALT_ENTER:
+	case ANX7688_OCM_MSG_DP_ALT_EXIT:
+	case ANX7688_OCM_MSG_RESPONSE_TO_REQ:
+	case ANX7688_OCM_MSG_SOFT_RST:
+	case ANX7688_OCM_MSG_HARD_RST:
+	case ANX7688_OCM_MSG_RESTART:
+		break;
+	}
+
+	return 0;
+}
+
 static int anx7688_receive_msg(struct anx7688* anx7688)
 {
         u8 pdo[32], checksum = 0;
@@ -596,18 +624,18 @@ static int anx7688_receive_msg(struct anx7688* anx7688)
                 return -EINVAL;
         }
 
-        dev_dbg(anx7688->dev, "recv pd packet cmd=%d %*ph\n",
+        dev_dbg(anx7688->dev, "recv ocm message cmd=%d %*ph\n",
                 pdo[1], pdo[0] + 2, pdo);
 
         for (i = 0; i < pdo[0] + 2; i++)
                 checksum += pdo[i];
 
         if (checksum != 0) {
-                dev_err(anx7688->dev, "bad checksum on received pd msg\n");
+                dev_err(anx7688->dev, "bad checksum on received message\n");
                 return -EINVAL;
         }
 
-        //anx7688_handle_pd(pdo[1], pdo + 2, pdo[0] - 1);
+        anx7688_handle_pd_message(anx7688, pdo[1], pdo + 2, pdo[0] - 1);
         return 0;
 }
 
@@ -640,7 +668,7 @@ static int anx7688_cc_status(unsigned v)
 static int anx7688_update_status(struct anx7688 *anx7688)
 {
         struct device *dev = anx7688->dev;
-	bool vbus_on, vconn_on, dr_ufp;
+	bool vbus_on, vconn_on, dr_dfp;
 	int status, cc_status, ret;
 	int cc1, cc2;
 
@@ -652,14 +680,21 @@ static int anx7688_update_status(struct anx7688 *anx7688)
 	if (cc_status < 0)
 		return cc_status;
 
-	dev_dbg(dev, "Update status (0x%02x)\n", status);
-	dev_dbg(dev, "  CC1 = %s CC2 = %s\n",
-		anx7688_cc_status_string(cc_status & 0xf),
-		anx7688_cc_status_string((cc_status >> 4) & 0xf));
+	if (anx7688->last_status == -1 || anx7688->last_status != status) {
+		anx7688->last_status = status;
+		dev_dbg(dev, "status changed to 0x%02x\n", status);
+	}
+
+	if (anx7688->last_cc_status == -1 || anx7688->last_cc_status != cc_status) {
+		anx7688->last_cc_status = cc_status;
+		dev_dbg(dev, "cc_status changed to CC1 = %s CC2 = %s\n",
+			anx7688_cc_status_string(cc_status & 0xf),
+			anx7688_cc_status_string((cc_status >> 4) & 0xf));
+	}
 
 	vbus_on = !!(status & ANX7688_VBUS_STATUS);
 	vconn_on = !!(status & ANX7688_VCONN_STATUS);
-	dr_ufp = !(status & ANX7688_DATA_ROLE_STATUS);
+	dr_dfp = !!(status & ANX7688_DATA_ROLE_STATUS);
 
 	cc1 = anx7688_cc_status(cc_status & 0xf);
 	cc2 = anx7688_cc_status((cc_status >> 4) & 0xf);
@@ -706,14 +741,17 @@ static int anx7688_update_status(struct anx7688 *anx7688)
 		anx7688->vconn_on = vconn_on;
 	}
 
-	dev_dbg(anx7688->dev, "data role = %s\n", dr_ufp ? "ufp" : "dfp");
+	typec_set_data_role(anx7688->port, dr_dfp ? TYPEC_HOST : TYPEC_DEVICE);
 
-	typec_set_data_role(anx7688->port, dr_ufp ? TYPEC_DEVICE : TYPEC_HOST);
+	if (anx7688->dr_dfp != dr_dfp) {
+		anx7688->dr_dfp = dr_dfp;
+		dev_dbg(anx7688->dev, "data role change requested to %s\n", dr_dfp ? "dfp" : "ufp");
 
-	ret = usb_role_switch_set_role(anx7688->role_sw,
-				       dr_ufp ? USB_ROLE_DEVICE : USB_ROLE_HOST);
-	if (ret)
-		return ret;
+		ret = usb_role_switch_set_role(anx7688->role_sw,
+					       dr_dfp ? USB_ROLE_HOST : USB_ROLE_DEVICE);
+		if (ret)
+			return ret;
+	}
 
 	return 0;
 }
@@ -774,16 +812,13 @@ static irqreturn_t anx7688_irq_status_handler(int irq, void *data)
                 soft_status = anx7688_reg_read(anx7688, ANX7688_REG_STATUS_INT);
                 anx7688_reg_write(anx7688, ANX7688_REG_STATUS_INT, 0);
 
-		dev_dbg(dev, "  ext2 = 0x%02x\n", ext2_status);
                 dev_dbg(dev, "  soft = 0x%02x\n", soft_status);
 
 		if (soft_status > 0) {
 			soft_status &= ANX7688_SOFT_INT_MASK;
 
-			if (soft_status & ANX7688_IRQS_RECEIVED_MSG) {
-				dev_dbg(dev, "  pd msg rcv\n");
+			if (soft_status & ANX7688_IRQS_RECEIVED_MSG)
 				anx7688_receive_msg(anx7688);
-			}
 
 			if (soft_status & (ANX7688_IRQS_CC_STATUS_CHANGE |
 					   ANX7688_IRQS_VBUS_CHANGE |
@@ -1221,7 +1256,6 @@ DEFINE_SHOW_ATTRIBUTE(anx7688_regs);
 static int anx7688_status_show(struct seq_file *s, void *data)
 {
         struct anx7688 *anx7688 = s->private;
-        //int ret;
 
         mutex_lock(&anx7688->lock);
 
@@ -1240,7 +1274,7 @@ static void anx7688_work(struct work_struct *work)
         anx7688_handle_cable_change(anx7688);
 
 	if (test_bit(ANX7688_F_CONNECTED, anx7688->flags)) {
-		/* 
+		/*
 		 * We check status periodically outside of interrupt, just to
 		 * be sure we didn't miss any status interrupts
 		 */
@@ -1254,8 +1288,6 @@ static void anx7688_cabledet_timer_fn(struct timer_list *t)
 {
 	struct anx7688 *anx7688 = from_timer(anx7688, t, work_timer);
 
-	dev_dbg(anx7688->dev, "wd timer\n");
-
 	schedule_delayed_work(&anx7688->work, 0);
 	mod_timer(t, jiffies + msecs_to_jiffies(1000));
 }
@@ -1354,6 +1386,9 @@ static int anx7688_i2c_probe(struct i2c_client *client,
 		goto err_disable_reg;
 	}
 
+	if (usb_role_switch_get_role(anx7688->role_sw) != USB_ROLE_DEVICE)
+		usb_role_switch_set_role(anx7688->role_sw, USB_ROLE_DEVICE);
+
 	// setup a typec port device
         typec_cap.revision = USB_TYPEC_REV_1_2;
         typec_cap.pd_revision = 0x200;
@@ -1370,6 +1405,11 @@ static int anx7688_i2c_probe(struct i2c_client *client,
                 goto err_role_sw;
         }
 
+        typec_set_pwr_opmode(anx7688->port, TYPEC_PWR_MODE_USB);
+        typec_set_pwr_role(anx7688->port, TYPEC_SINK);
+        typec_set_vconn_role(anx7688->port, TYPEC_SINK);
+        typec_set_data_role(anx7688->port, TYPEC_DEVICE);
+
         ret = devm_request_irq(dev, irq_cabledet, anx7688_irq_plug_handler,
                                IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
                                "anx7688-cabledet", anx7688);
@@ -1416,25 +1456,25 @@ static int anx7688_i2c_remove(struct i2c_client *client)
 {
         struct anx7688 *anx7688 = i2c_get_clientdata(client);
 
+	mutex_lock(&anx7688->lock);
+
 	del_timer_sync(&anx7688->work_timer);
         cancel_delayed_work_sync(&anx7688->work);
 
+	if (test_bit(ANX7688_F_CONNECTED, anx7688->flags))
+		anx7688_disconnect(anx7688);
+
 	typec_unregister_partner(anx7688->partner);
         typec_unregister_port(anx7688->port);
 	usb_role_switch_put(anx7688->role_sw);
 
-	if (anx7688->vbus_on)
-		regulator_disable(anx7688->supplies[ANX7688_VBUS_INDEX].consumer);
-	if (anx7688->vconn_on)
-		regulator_disable(anx7688->supplies[ANX7688_VCONN_INDEX].consumer);
-
-        anx7688_power_disable(anx7688);
-
         regulator_bulk_disable(ANX7688_NUM_ALWAYS_ON_SUPPLIES, anx7688->supplies);
         i2c_unregister_device(anx7688->client_tcpc);
 
         debugfs_remove(anx7688->debug_root);
 
+	mutex_unlock(&anx7688->lock);
+
         return 0;
 }
 
-- 
2.26.2

