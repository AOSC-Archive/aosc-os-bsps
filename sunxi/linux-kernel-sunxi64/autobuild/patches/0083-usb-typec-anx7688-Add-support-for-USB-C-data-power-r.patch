From c0da43422cff8465eb0666479f4e1f3d7a599b37 Mon Sep 17 00:00:00 2001
From: Ondrej Jirman <megous@megous.com>
Date: Tue, 19 May 2020 23:26:53 +0200
Subject: [PATCH 83/92] usb: typec: anx7688: Add support for USB-C data/power
 role switching

The driver is now ready for some testing with more USB-C devices.
It supports data and power role switching properly on all PinePhone
variants, that have the HW mod: https://xnux.eu/devices/pp-usbc-fix.jpg.

- fix possibly unbalanced connect/disconnect
- better cabledet interrupt handling
  - handle connect/disconnect in a workqueue
  - debounce cabledet changes
- send PDO to the right i2c address
- proper error handling where it matters the most
- proper locking
- handle power supplies
- handle inital connection/cable status after driver probe
  not just on cabledet change
- handle software interrupts from OCM
- allow to update OCM firmware via sysfs
- allow to dump OCM firmware via debugfs
- allow to dump registers via debugfs
- hook into allwinner usb phy driver to handle change in
  data role (via usb_role_switch)
- handle vbus/vconn enable/disable based on firmware
  requests
- proper cleanup of resources on driver unload

Todo:
- tell PMIC what USB input current limit to set based on
  PD messages from firmware
- add support for manual data/power role setting for devices
  without the HW mod

Signed-off-by: Ondrej Jirman <megous@megous.com>
---
 drivers/usb/typec/anx7688.c | 1575 +++++++++++++++++++++++++++++------
 1 file changed, 1313 insertions(+), 262 deletions(-)

diff --git a/drivers/usb/typec/anx7688.c b/drivers/usb/typec/anx7688.c
index bd6244c771cfa..0da14c29c3264 100644
--- a/drivers/usb/typec/anx7688.c
+++ b/drivers/usb/typec/anx7688.c
@@ -1,386 +1,1437 @@
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/i2c.h>
+#define DEBUG
+
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
 #include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
 #include <linux/interrupt.h>
 #include <linux/irqreturn.h>
-#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/of_irq.h>
+#include <linux/regulator/consumer.h>
 #include <linux/usb/typec.h>
+#include <linux/usb/role.h>
+
+#define DISABLE_OCM 0
+
+/* firmware regs */
 
-#define ANX7688_REG_FUNCTION_OPTION	0x27
-#define ANX7688_REG_IRQ_SOURCE_0	0x54
-#define ANX7688_REG_IRQ_SOURCE_1	0x55
-#define ANX7688_REG_IRQ_SOURCE_2	0x56
+#define ANX7688_REG_VBUS_OFF_DELAY_TIME 0x22
+#define ANX7688_REG_FEATURE_CTRL        0x27
+#define ANX7688_REG_EEPROM_LOAD_STATUS1 0x11
+#define ANX7688_REG_EEPROM_LOAD_STATUS0 0x12
+#define ANX7688_REG_FW_VERSION1         0x15
+#define ANX7688_REG_FW_VERSION0         0x16
 
-#define ANX7688_TCPC_REG_VENDOR_ID_0	0x00
-#define ANX7688_TCPC_REG_VENDOR_ID_1	0x01
+#define ANX7688_EEPROM_FW_LOADED	0x01
+
+#define ANX7688_REG_STATUS_INT_MASK     0x17
+#define ANX7688_REG_STATUS_INT          0x28
+#define ANX7688_IRQS_RECEIVED_MSG       BIT(0)
+#define ANX7688_IRQS_RECEIVED_ACK       BIT(1)
+#define ANX7688_IRQS_VCONN_CHANGE       BIT(2)
+#define ANX7688_IRQS_VBUS_CHANGE        BIT(3)
+#define ANX7688_IRQS_CC_STATUS_CHANGE   BIT(4)
+#define ANX7688_IRQS_DATA_ROLE_CHANGE   BIT(5)
+
+#define ANX7688_REG_STATUS              0x29
+#define ANX7688_VCONN_STATUS            BIT(2) /* 0 = off  1 = on */
+#define ANX7688_VBUS_STATUS             BIT(3) /* 0 = off  1 = on */
+#define ANX7688_DATA_ROLE_STATUS        BIT(5) /* 0 = device 1 = host */
+
+#define ANX7688_REG_CC_STATUS           0x2a
+#define ANX7688_REG_TRY_UFP_TIMER       0x23
+#define ANX7688_REG_TIME_CTRL           0x24
+
+#define ANX7688_REG_MAX_VOLTAGE         0x1b
+#define ANX7688_REG_MAX_POWER           0x1c
+#define ANX7688_REG_MIN_POWER           0x1d
+#define ANX7688_REG_MAX_VOLTAGE_STATUS  0x1e
+#define ANX7688_REG_MAX_POWER_STATUS    0x1f
+
+#define ANX7688_SOFT_INT_MASK           0x7f
+
+/* tcpc regs */
+
+#define ANX7688_TCPC_REG_VENDOR_ID0     0x00
+#define ANX7688_TCPC_REG_VENDOR_ID1     0x01
+#define ANX7688_TCPC_REG_ALERT0         0x10
+#define ANX7688_TCPC_REG_ALERT1         0x11
+#define ANX7688_TCPC_REG_ALERT_MASK0    0x12
+#define ANX7688_TCPC_REG_ALERT_MASK1    0x13
 #define ANX7688_TCPC_REG_INTERFACE_SEND 0x30
 #define ANX7688_TCPC_REG_INTERFACE_RECV 0x51
 
-#define ANX7688_TYPE_PWR_SRC_CAP  	0x00
-#define ANX7688_TYPE_PWR_SNK_CAP  	0x01
+/* hw regs */
+
+#define ANX7688_REG_IRQ_EXT_SOURCE0     0x3e
+#define ANX7688_REG_IRQ_EXT_SOURCE1     0x4e
+#define ANX7688_REG_IRQ_EXT_SOURCE2     0x4f
+#define ANX7688_REG_IRQ_EXT_MASK0       0x3b
+#define ANX7688_REG_IRQ_EXT_MASK1       0x3c
+#define ANX7688_REG_IRQ_EXT_MASK2       0x3d
+#define ANX7688_REG_IRQ_SOURCE0         0x54
+#define ANX7688_REG_IRQ_SOURCE1         0x55
+#define ANX7688_REG_IRQ_SOURCE2         0x56
+#define ANX7688_REG_IRQ_MASK0           0x57
+#define ANX7688_REG_IRQ_MASK1           0x58
+#define ANX7688_REG_IRQ_MASK2           0x59
+
+#define ANX7688_IRQ2_SOFT_INT           BIT(2)
+
+//#define ANX7688_IRQ2_USB_PLUGIN         BIT(4)
+//#define ANX7688_REG_IRQ_STATUS          0x53
+
+/* ocm messages */
 
-#define ANX7688_PDO_FIXED_DUAL_ROLE	(1 << 29)
-#define ANX7688_PDO_FIXED_SUSPEND	(1 << 28)
-#define ANX7688_PDO_FIXED_EXTERNAL	(1 << 27)
-#define ANX7688_PDO_FIXED_COMM_CAP	(1 << 26)
-#define ANX7688_PDO_FIXED_DATA_SWAP	(1 << 25)
+#define ANX7688_OCM_MSG_PWR_SRC_CAP     0x00
+#define ANX7688_OCM_MSG_PWR_SNK_CAP     0x01
+#define ANX7688_OCM_MSG_DP_SNK_IDENTITY 0x02
+#define ANX7688_OCM_MSG_SVID            0x03
+#define ANX7688_OCM_MSG_GET_DP_SNK_CAP  0x04
+#define ANX7688_OCM_MSG_ACCEPT          0x05
+#define ANX7688_OCM_MSG_REJECT          0x06
+#define ANX7688_OCM_MSG_PSWAP_REQ       0x10
+#define ANX7688_OCM_MSG_DSWAP_REQ       0x11
+#define ANX7688_OCM_MSG_GOTO_MIN_REQ    0x12
+#define ANX7688_OCM_MSG_VCONN_SWAP_REQ  0x13
+#define ANX7688_OCM_MSG_VDM             0x14
+#define ANX7688_OCM_MSG_DP_SNK_CFG      0x15
+#define ANX7688_OCM_MSG_PWR_OBJ_REQ     0x16
+#define ANX7688_OCM_MSG_PD_STATUS_REQ   0x17
+#define ANX7688_OCM_MSG_DP_ALT_ENTER    0x19
+#define ANX7688_OCM_MSG_DP_ALT_EXIT     0x1a
+#define ANX7688_OCM_MSG_RESPONSE_TO_REQ 0xf0
+#define ANX7688_OCM_MSG_SOFT_RST        0xf1
+#define ANX7688_OCM_MSG_HARD_RST        0xf2
+#define ANX7688_OCM_MSG_RESTART         0xf3
+
+#define ANX7688_REG_USBC_RESET_CTRL		0x05
+#define ANX7688_USBC_RESET_CTRL_OCM_RESET	BIT(4)
+
+/* pdo */
+
+#define PDO_TYPE_FIXED		0
+#define PDO_TYPE_BATTERY	(1u << 30)
+#define PDO_TYPE_VARIABLE	(2u << 30)
+#define PDO_TYPE_MASK		(3u << 30)
+
+#define PDO_FIXED_DUAL_ROLE	(1u << 29) /* Dual role device */
+#define PDO_FIXED_SUSPEND	(1u << 28) /* USB Suspend supported */
+#define PDO_FIXED_EXTERNAL	(1u << 27) /* Externally powered */
+#define PDO_FIXED_COMM_CAP	(1u << 26) /* USB Communications Capable */
+#define PDO_FIXED_DATA_SWAP	(1u << 25) /* Data role swap command */
+#define PDO_FIXED_PEAK_CURR(v)	(((v) & 3) << 20) /* [21..20] Peak current */
+#define PDO_FIXED_VOLT(mv)	(((u32)(mv) / 50) << 10)
+#define PDO_FIXED_CURR(ma)	((u32)(ma) / 10)
+
+#define PDO_FIXED(mv, ma, flags) \
+	(PDO_FIXED_VOLT(mv) | PDO_FIXED_CURR(ma) | (flags))
+
+#define PDO_GET_TYPE(pdo)		((pdo) & PDO_TYPE_MASK)
+#define PDO_IS_FIXED_DUAL_ROLE(pdo)	((pdo) & PDO_FIXED_DUAL_ROLE)
+#define PDO_IS_FIXED_SUSPEND(pdo)	((pdo) & PDO_FIXED_SUSPEND)
+#define PDO_IS_FIXED_EXTERNAL(pdo)	((pdo) & PDO_FIXED_EXTERNAL)
+#define PDO_IS_FIXED_COMM_CAP(pdo)	((pdo) & PDO_FIXED_COMM_CAP)
+#define PDO_IS_FIXED_DATA_SWAP(pdo)	((pdo) & PDO_FIXED_DATA_SWAP)
+#define PDO_GET_FIXED_PEAK_CURR(pdo)	(((pdo) >> 20) & 3)
+
+#define PDO_GET_FIXED_VOLT(pdo)		((((pdo) >> 10) & 0x3ff) * 50)
+#define PDO_GET_FIXED_CURR(pdo)		(((pdo) & 0x3ff) * 10)
+#define PDO_GET_VAR_MAX_VOLT(pdo)	((((pdo) >> 20) & 0x3ff) * 50)
+#define PDO_GET_VAR_MIN_VOLT(pdo)	((((pdo) >> 10) & 0x3ff) * 50)
+#define PDO_GET_VAR_MAX_CURR(pdo)	(((pdo) & 0x3ff) * 10)
+
+static const char * const anx7688_supply_names[] = {
+        "avdd33",
+        "avdd18",
+        "dvdd18",
+        "avdd10",
+        "dvdd10",
+        "hdmi_vt",
+
+        "vconn", // power for VCONN1/VCONN2 switches
+        "vbus", // vbus power
+};
+
+#define ANX7688_NUM_SUPPLIES ARRAY_SIZE(anx7688_supply_names)
+#define ANX7688_NUM_ALWAYS_ON_SUPPLIES (ANX7688_NUM_SUPPLIES - 2)
+#define ANX7688_VCONN_INDEX (ANX7688_NUM_SUPPLIES - 2)
+#define ANX7688_VBUS_INDEX (ANX7688_NUM_SUPPLIES - 1)
+
+enum {
+	ANX7688_F_POWERED,
+	ANX7688_F_CONNECTED,
+};
 
 struct anx7688 {
-	struct device *dev;
-	struct i2c_client *client;
-	struct i2c_client *client_tcpc;
-	struct gpio_desc *gpio_poweron;
-	struct gpio_desc *gpio_reset;
-	struct gpio_desc *gpio_irq;
-	struct gpio_desc *gpio_cabledet;
-	int irq_plug;
-	int irq_status;
-	
-	struct typec_port *port;
-	struct typec_partner *partner;
-	struct usb_pd_identity partner_identity;
+        struct device *dev;
+        struct i2c_client *client;
+        struct i2c_client *client_tcpc;
+        struct regulator_bulk_data supplies[ANX7688_NUM_SUPPLIES];
+        struct gpio_desc *gpio_enable;
+        struct gpio_desc *gpio_reset;
+        struct gpio_desc *gpio_cabledet;
+
+	unsigned long flags[1];
+
+        struct delayed_work work;
+        struct mutex lock;
+        bool vbus_on, vconn_on;
+
+        struct typec_port *port;
+        struct typec_partner *partner;
+        struct usb_pd_identity partner_identity;
+	struct usb_role_switch *role_sw;
+
+        struct dentry *debug_root;
 };
 
 static int anx7688_reg_read(struct anx7688 *anx7688, u8 reg_addr)
 {
-	int ret;
-	ret = i2c_smbus_read_byte_data(anx7688->client, reg_addr);
-	if (ret < 0)
-		dev_printk(KERN_ERR, anx7688->dev, "i2c read failed addr 0x%x reg 0x%x, error %d\n",
-				anx7688->client->addr, reg_addr, ret);
-	return ret;
+        int ret;
+
+        ret = i2c_smbus_read_byte_data(anx7688->client, reg_addr);
+        if (ret < 0)
+                dev_err(anx7688->dev, "i2c read failed at 0x%x (%d)\n",
+                        reg_addr, ret);
+
+        return ret;
 }
 
-static int anx7688_tcpc_reg_read(struct anx7688 *anx7688, u8 reg_addr)
+static int anx7688_reg_write(struct anx7688 *anx7688, u8 reg_addr, u8 value)
 {
-	int ret;
-	ret = i2c_smbus_read_byte_data(anx7688->client_tcpc, reg_addr);
-	if (ret < 0)
-		dev_printk(KERN_ERR, anx7688->dev, "i2c read failed addr 0x%x reg 0x%x, error %d\n",
-				anx7688->client_tcpc->addr, reg_addr, ret);
-	return ret;
+        int ret;
+
+        ret = i2c_smbus_write_byte_data(anx7688->client, reg_addr, value);
+        if (ret < 0)
+                dev_err(anx7688->dev, "i2c write failed at 0x%x (%d)\n",
+                        reg_addr, ret);
+
+        return ret;
 }
 
-static int anx7688_reg_write(struct anx7688 *anx7688, u8 reg_addr, u8 value)
+static int anx7688_reg_update_bits(struct anx7688 *anx7688, u8 reg_addr,
+                                   u8 mask, u8 value)
 {
-	int ret;
-	ret = i2c_smbus_write_byte_data(anx7688->client, reg_addr, value);
-	if (ret < 0)
-		dev_printk(KERN_ERR, anx7688->dev, "i2c write failed addr 0x%x reg 0x%x, error %d\n",
-				anx7688->client->addr, reg_addr, ret);
-	return ret;
+        int ret;
+
+        ret = anx7688_reg_read(anx7688, reg_addr);
+        if (ret < 0)
+                return ret;
+
+        ret &= ~mask;
+        ret |= value;
+
+        return anx7688_reg_write(anx7688, reg_addr, ret);
+}
+
+static int anx7688_tcpc_reg_read(struct anx7688 *anx7688, u8 reg_addr)
+{
+        int ret;
+
+        ret = i2c_smbus_read_byte_data(anx7688->client_tcpc, reg_addr);
+        if (ret < 0)
+                dev_err(anx7688->dev, "tcpc i2c read failed at 0x%x (%d)\n",
+                        reg_addr, ret);
+
+        return ret;
 }
 
 static int anx7688_tcpc_reg_write(struct anx7688 *anx7688, u8 reg_addr, u8 value)
 {
-	int ret;
-	ret = i2c_smbus_write_byte_data(anx7688->client_tcpc, reg_addr, value);
-	if (ret < 0)
-		dev_printk(KERN_ERR, anx7688->dev, "i2c write failed addr 0x%x reg 0x%x, error %d\n",
-				anx7688->client_tcpc->addr, reg_addr, ret);
-	return ret;
+        int ret;
+
+        ret = i2c_smbus_write_byte_data(anx7688->client_tcpc, reg_addr, value);
+        if (ret < 0)
+                dev_err(anx7688->dev, "tcpc i2c write failed at 0x%x (%d)\n",
+                        reg_addr, ret);
+
+        return ret;
 }
 
-static int anx7688_power_enable(struct anx7688 *anx7688)
+static void anx7688_power_enable(struct anx7688 *anx7688)
 {
-	dev_printk(KERN_INFO, anx7688->dev, "ANX7688 power enable\n");
-	gpiod_set_value(anx7688->gpio_poweron, 1);
-	usleep_range(10000, 11000);
-	gpiod_set_value(anx7688->gpio_reset, 1);
-	usleep_range(12000, 13000);
-	return 0;
+        gpiod_set_value(anx7688->gpio_reset, 1);
+        gpiod_set_value(anx7688->gpio_enable, 1);
+
+        /* wait for power to stabilize and release reset */
+        msleep(10);
+        gpiod_set_value(anx7688->gpio_reset, 0);
+        udelay(2);
+
+        dev_dbg(anx7688->dev, "power enabled\n");
+
+	set_bit(ANX7688_F_POWERED, anx7688->flags);
 }
 
-static int anx7688_power_disable(struct anx7688 *anx7688)
+static void anx7688_power_disable(struct anx7688 *anx7688)
 {
-	dev_printk(KERN_INFO, anx7688->dev, "ANX7688 power disable\n");
-	gpiod_set_value(anx7688->gpio_reset, 0);
-	usleep_range(1000, 1100);
-	gpiod_set_value(anx7688->gpio_poweron, 0);
-	usleep_range(1000, 1100);
-	return 0;
+        gpiod_set_value(anx7688->gpio_reset, 1);
+        msleep(5);
+        gpiod_set_value(anx7688->gpio_enable, 0);
+
+        dev_dbg(anx7688->dev, "power disabled\n");
+
+	clear_bit(ANX7688_F_POWERED, anx7688->flags);
 }
 
-static int anx7688_send_buffer(struct anx7688 *anx7688, u8 len, u8 cmd, const char *buf)
+static int anx7688_send_ocm_message(struct anx7688 *anx7688, int cmd,
+                                    const u8 *data, int data_len)
 {
-	int status;
-	int ret = 0;
-	int i;
-	u8 pdo[32];
-	u8 checksum;
+        int ret = 0, i;
+        u8 pdo[32];
 
-	pdo[0] = len + 1;
-	pdo[1] = cmd;
-	memcpy(pdo+2, buf, len);
+        if (data_len > sizeof(pdo) - 3 || data_len < 1) {
+                dev_dbg(anx7688->dev,
+                        "invalid ocm message length cmd=%d len=%d\n",
+                        cmd, data_len);
+                return -EINVAL;
+        }
 
-	for (i = 0; i < len; i++)
-		checksum += buf[i];
+        // prepare pd packet
+        pdo[0] = data_len + 1;
+        pdo[1] = cmd;
+        memcpy(pdo + 2, data, data_len);
+        pdo[2 + data_len] = 0;
+        for (i = 0; i < data_len + 2; i++)
+                pdo[data_len + 2] -= pdo[i];
 
-	pdo[len+2] = (u8) (0 - checksum);
+        dev_dbg(anx7688->dev, "send pd packet cmd=%d %*ph\n",
+                cmd, data_len + 3, pdo);
 
-	dev_printk(KERN_INFO, anx7688->dev, "send pd packet\n");
-	status = anx7688_tcpc_reg_read(anx7688, ANX7688_TCPC_REG_INTERFACE_SEND);
-	if (status == 0) {
-		ret = i2c_smbus_write_i2c_block_data(anx7688->client,
-				ANX7688_TCPC_REG_INTERFACE_SEND, len + 3, pdo);
-		if (ret < 0)
-			dev_printk(KERN_ERR, anx7688->dev, "i2c buffer write error, addr %x, len %d, ret %d\n",
-					anx7688->client_tcpc->addr, len, ret);
-	}
-	return ret;
+        ret = anx7688_tcpc_reg_read(anx7688, ANX7688_TCPC_REG_INTERFACE_SEND);
+        if (ret) {
+                dev_err(anx7688->dev,
+                        "failed to send pd packet (tx buffer full)\n");
+                return -EBUSY;
+        }
+
+        ret = i2c_smbus_write_i2c_block_data(anx7688->client_tcpc,
+                                             ANX7688_TCPC_REG_INTERFACE_SEND,
+                                             data_len + 3, pdo);
+        if (ret < 0)
+                dev_err(anx7688->dev,
+                        "failed to send pd packet (err=%d)\n", ret);
+
+        // wait until the message is processed (10ms max)
+        for (i = 0; i < 100; i++) {
+                ret = anx7688_tcpc_reg_read(anx7688, ANX7688_TCPC_REG_INTERFACE_SEND);
+                if (ret <= 0)
+                        return ret;
+
+                udelay(100);
+        }
+
+        dev_err(anx7688->dev, "timeout waiting for the message queue flush\n");
+        return -ETIMEDOUT;
 }
 
-static int anx7688_make_pdo(int mv, int ma, int flags)
+static int anx7688_connect(struct anx7688 *anx7688)
 {
-	int ret = 0;
-	ret |= ma / 10; // current in mA
-	ret |= (mv / 50) << 10; // current in mV
-	ret |= flags;
-	return ret;
+#if DISABLE_OCM
+        int ret;
+
+        dev_dbg(anx7688->dev, "cable inserted\n");
+
+        msleep(10);
+        anx7688_power_enable(anx7688);
+
+	/* reset the OCM right away */
+        ret = anx7688_reg_update_bits(anx7688, ANX7688_REG_USBC_RESET_CTRL,
+                                      ANX7688_USBC_RESET_CTRL_OCM_RESET,
+                                      ANX7688_USBC_RESET_CTRL_OCM_RESET);
+	if (ret)
+		goto err_poweroff;
+
+	/* enable interrupts for VBUS, etc. */
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_IRQ_EXT_SOURCE2, 0xff);
+	if (ret)
+		goto err_poweroff;
+
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_IRQ_EXT_MASK2, ~(BIT(6) | BIT(5) | BIT(4)));
+	if (ret)
+		goto err_poweroff;
+
+	set_bit(ANX7688_F_CONNECTED, anx7688->flags);
+        return 0;
+
+err_poweroff:
+        anx7688_power_disable(anx7688);
+        return ret;
+#else
+	struct typec_partner_desc desc = {};
+        int ret, i;
+        u8 fw[2];
+        u32 pdo;
+
+        dev_dbg(anx7688->dev, "cable inserted\n");
+
+        msleep(10);
+        anx7688_power_enable(anx7688);
+
+        ret = regulator_enable(anx7688->supplies[ANX7688_VCONN_INDEX].consumer);
+        if (ret) {
+                dev_err(anx7688->dev, "failed to enable vconn\n");
+                goto err_poweroff;
+        }
+
+        /* wait till the firmware is loaded (typically ~30ms) */
+        for (i = 0; i < 100; i++) {
+                ret = anx7688_reg_read(anx7688, ANX7688_REG_EEPROM_LOAD_STATUS0);
+
+                if (ret >= 0 && (ret & ANX7688_EEPROM_FW_LOADED) == ANX7688_EEPROM_FW_LOADED) {
+                        dev_dbg(anx7688->dev, "eeprom0 = 0x%02x\n", ret);
+                        dev_info(anx7688->dev, "fw loaded after %d ms\n", i * 10);
+                        goto fw_loaded;
+                }
+
+                msleep(5);
+        }
+
+        dev_err(anx7688->dev, "boot firmware load failed\n");
+        ret = -ETIMEDOUT;
+        goto err_vconoff;
+
+fw_loaded:
+        ret = i2c_smbus_read_i2c_block_data(anx7688->client,
+                                            ANX7688_REG_FW_VERSION1, 2, fw);
+        if (ret < 0) {
+                dev_err(anx7688->dev, "failed to read firmware version\n");
+                goto err_vconoff;
+        }
+
+        dev_info(anx7688->dev, "OCM firmware loaded (version 0x%04x)\n",
+                 fw[1] | fw[0] << 8);
+
+        /* Unmask interrupts */
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_STATUS_INT, 0);
+	if (ret)
+		goto err_vconoff;
+
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_STATUS_INT_MASK, ~ANX7688_SOFT_INT_MASK);
+	if (ret)
+		goto err_vconoff;
+
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_IRQ_EXT_SOURCE2, 0xff);
+	if (ret)
+		goto err_vconoff;
+
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_IRQ_EXT_MASK2, (u8)~ANX7688_IRQ2_SOFT_INT);
+	if (ret)
+		goto err_vconoff;
+
+
+        /* time to turn off vbus after cc disconnect (unit is 4 ms) */
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_VBUS_OFF_DELAY_TIME, 100 / 4);
+	if (ret)
+		goto err_vconoff;
+
+        //anx7688_reg_write(anx7688, ANX7688_REG_TIME_CTRL, 0x00);
+
+        /* 300ms (unit is 2 ms) */
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_TRY_UFP_TIMER, 300 / 2);
+	if (ret)
+		goto err_vconoff;
+
+
+        /* maximum voltage in 100 mV units */
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_MAX_VOLTAGE, 50); /* 5 V */
+	if (ret)
+		goto err_vconoff;
+
+
+        /* min/max power in 500 mW units */
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_MAX_POWER, 5 * 2); /* 5 W */
+	if (ret)
+		goto err_vconoff;
+
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_MIN_POWER, 1 * 2);  /* 1 W */
+	if (ret)
+		goto err_vconoff;
+
+
+        /* auto_pd, try.src, try.sink, goto safe 5V */
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_FEATURE_CTRL, 0x1e);
+	if (ret)
+		goto err_vconoff;
+
+
+	pdo = cpu_to_le32(PDO_FIXED(5000, 500,
+				    PDO_FIXED_DATA_SWAP |
+				    PDO_FIXED_COMM_CAP |
+				    PDO_FIXED_DUAL_ROLE));
+	ret = anx7688_send_ocm_message(anx7688, ANX7688_OCM_MSG_PWR_SRC_CAP,
+				       (u8*)&pdo, sizeof pdo);
+	if (ret)
+		goto err_vconoff;
+
+
+	pdo = cpu_to_le32(PDO_FIXED(5000, 3000,
+				    PDO_FIXED_DATA_SWAP |
+				    PDO_FIXED_COMM_CAP |
+				    PDO_FIXED_DUAL_ROLE));
+	ret = anx7688_send_ocm_message(anx7688, ANX7688_OCM_MSG_PWR_SNK_CAP,
+				       (u8*)&pdo, sizeof pdo);
+	if (ret)
+		goto err_vconoff;
+
+
+        dev_dbg(anx7688->dev, "OCM configuration completed\n");
+
+        desc.accessory = TYPEC_ACCESSORY_NONE;
+
+	typec_unregister_partner(anx7688->partner);
+
+        anx7688->partner = typec_register_partner(anx7688->port, &desc);
+        if (IS_ERR(anx7688->partner)) {
+                ret = PTR_ERR(anx7688->partner);
+		goto err_vconoff;
+	}
+
+	set_bit(ANX7688_F_CONNECTED, anx7688->flags);
+        return 0;
+
+err_vconoff:
+        regulator_disable(anx7688->supplies[ANX7688_VCONN_INDEX].consumer);
+err_poweroff:
+        anx7688_power_disable(anx7688);
+        return ret;
+#endif
 }
 
-static int anx7688_config(struct anx7688 *anx7688)
+static void anx7688_disconnect(struct anx7688 *anx7688)
 {
-	static int source_caps[1];
-	static int sink_caps[1];
-	source_caps[0] = anx7688_make_pdo(5000, 1500, ANX7688_PDO_FIXED_DUAL_ROLE | ANX7688_PDO_FIXED_COMM_CAP | ANX7688_PDO_FIXED_DATA_SWAP);
-	sink_caps[0] = anx7688_make_pdo(5000, 3000, ANX7688_PDO_FIXED_DUAL_ROLE | ANX7688_PDO_FIXED_COMM_CAP | ANX7688_PDO_FIXED_DATA_SWAP);
+        dev_dbg(anx7688->dev, "cable removed\n");
 
-	// Reset interrupts
-	anx7688_reg_write(anx7688, ANX7688_REG_IRQ_SOURCE_0, 0);
-	anx7688_reg_write(anx7688, ANX7688_REG_IRQ_SOURCE_1, 0);
-	anx7688_reg_write(anx7688, ANX7688_REG_IRQ_SOURCE_2, 0);
+	if (anx7688->vconn_on) {
+		regulator_disable(anx7688->supplies[ANX7688_VCONN_INDEX].consumer);
+		anx7688->vconn_on = false;
+	}
 
-	// Send source and sink capabilities
-	anx7688_send_buffer(anx7688, sizeof(source_caps), ANX7688_TYPE_PWR_SRC_CAP, (const char *)source_caps);
-	anx7688_send_buffer(anx7688, sizeof(sink_caps), ANX7688_TYPE_PWR_SNK_CAP, (const char *)sink_caps);
-	return 0;
+	if (anx7688->vbus_on) {
+		regulator_disable(anx7688->supplies[ANX7688_VBUS_INDEX].consumer);
+		anx7688->vbus_on = false;
+	}
+
+        anx7688_power_disable(anx7688);
+
+	typec_unregister_partner(anx7688->partner);
+        anx7688->partner = NULL;
+
+        typec_set_pwr_opmode(anx7688->port, TYPEC_PWR_MODE_USB);
+        typec_set_pwr_role(anx7688->port, TYPEC_SINK);
+        typec_set_vconn_role(anx7688->port, TYPEC_SINK);
+        typec_set_data_role(anx7688->port, TYPEC_DEVICE);
+
+	clear_bit(ANX7688_F_CONNECTED, anx7688->flags);
 }
 
-static int anx7688_connect(struct anx7688 *anx7688)
+static void anx7688_handle_cable_change(struct anx7688* anx7688)
 {
-	struct typec_partner_desc desc;
+        int cabledet;
+	bool connected;
 
-	dev_printk(KERN_INFO, anx7688->dev, "Cable inserted\n");
-	anx7688_power_enable(anx7688);
-	anx7688_config(anx7688);
+        mutex_lock(&anx7688->lock);
 
-	desc.usb_pd = false;
-	desc.accessory = TYPEC_ACCESSORY_NONE;
-	desc.identity = NULL;
+        dev_dbg(anx7688->dev, "processing cabledet change (cd=%d)\n",
+                gpiod_get_value(anx7688->gpio_cabledet));
 
-	if (!IS_ERR(anx7688->partner))
-		typec_unregister_partner(anx7688->partner);
+	connected = test_bit(ANX7688_F_CONNECTED, anx7688->flags);
 
-	anx7688->partner = typec_register_partner(anx7688->port, &desc);
-	if (IS_ERR(anx7688->partner))
-		return PTR_ERR(anx7688->partner);
+        cabledet = gpiod_get_value(anx7688->gpio_cabledet);
+        if (cabledet && !connected)
+                anx7688_connect(anx7688);
+        else if (!cabledet && connected)
+                anx7688_disconnect(anx7688);
 
-	if (desc.identity)
-		typec_partner_set_identity(anx7688->partner);
+        mutex_unlock(&anx7688->lock);
+}
 
-	return 0;
+static void anx7688_work(struct work_struct *work)
+{
+        struct anx7688 *anx7688 = container_of(work, struct anx7688, work.work);
+
+        anx7688_handle_cable_change(anx7688);
 }
 
-static int anx7688_disconnect(struct anx7688 *anx7688)
+static irqreturn_t anx7688_irq_plug_handler(int irq, void *data)
 {
-	dev_printk(KERN_INFO, anx7688->dev, "Cable removed\n");
+        struct anx7688 *anx7688 = data;
 
-	if (!IS_ERR(anx7688->partner))
-		typec_unregister_partner(anx7688->partner);
+        dev_dbg(anx7688->dev, "plug irq (cd=%d)\n",
+                gpiod_get_value(anx7688->gpio_cabledet));
 
-	anx7688->partner = NULL;
-	
-	typec_set_pwr_opmode(anx7688->port, TYPEC_PWR_MODE_USB);
-	typec_set_pwr_role(anx7688->port, TYPEC_SINK);
-	typec_set_data_role(anx7688->port, TYPEC_DEVICE);
-	anx7688_power_disable(anx7688);
+        /*
+         * After each cabledet change the scheduled work timer is reset
+         * to fire in ~10ms. So the work is done only after the cabledet
+         * is stable for ~10ms.
+         */
+        schedule_delayed_work(&anx7688->work, msecs_to_jiffies(10));
 
-	return 0;
+        return IRQ_HANDLED;
 }
 
-static irqreturn_t anx7688_irq_plug_handler(int irq, void *data)
+static int anx7688_receive_msg(struct anx7688* anx7688)
 {
-	struct i2c_client *client = to_i2c_client(data);
-	struct anx7688 *anx7688 = i2c_get_clientdata(client);
-	int value;
+        u8 pdo[32], checksum = 0;
+        int i, ret;
 
-	value = gpiod_get_value(anx7688->gpio_cabledet);
-	if(value){
-		anx7688_connect(anx7688);
-	}else{
-		anx7688_disconnect(anx7688);
+        ret = i2c_smbus_read_i2c_block_data(anx7688->client_tcpc,
+                                            ANX7688_TCPC_REG_INTERFACE_RECV,
+                                            32, pdo);
+        if (ret < 0) {
+                dev_err(anx7688->dev, "failed to read pd msg\n");
+                return ret;
+        }
+
+        ret = anx7688_tcpc_reg_write(anx7688, ANX7688_TCPC_REG_INTERFACE_RECV, 0);
+        if (ret) {
+                dev_warn(anx7688->dev, "failed to clear recv fifo\n");
+        }
+
+        if (pdo[0] == 0 || pdo[0] > sizeof(pdo) - 2) {
+                dev_err(anx7688->dev, "received invalid pd message\n");
+                return -EINVAL;
+        }
+
+        dev_dbg(anx7688->dev, "recv pd packet cmd=%d %*ph\n",
+                pdo[1], pdo[0] + 2, pdo);
+
+        for (i = 0; i < pdo[0] + 2; i++)
+                checksum += pdo[i];
+
+        if (checksum != 0) {
+                dev_err(anx7688->dev, "bad checksum on received pd msg\n");
+                return -EINVAL;
+        }
+
+        //anx7688_handle_pd(pdo[1], pdo + 2, pdo[0] - 1);
+        return 0;
+}
+
+static const char* anx7688_cc_status_string(unsigned v)
+{
+	switch (v) {
+	case 0: return "SRC.Open";
+	case 1: return "SRC.Rd";
+	case 2: return "SRC.Ra";
+	case 4: return "SNK.Default";
+	case 8: return "SNK.Power1.5";
+	case 12: return "SNK.Power3.0";
+	default: return "UNK";
 	}
+}
 
-	return IRQ_HANDLED;
+static int anx7688_cc_status(unsigned v)
+{
+	switch (v) {
+	case 0: return -1;
+	case 1: return -1;
+	case 2: return -1;
+	case 4: return TYPEC_PWR_MODE_USB;
+	case 8: return TYPEC_PWR_MODE_1_5A;
+	case 12: return TYPEC_PWR_MODE_3_0A;
+	default: return -1;
+	}
+}
+
+static int anx7688_update_status(struct anx7688 *anx7688)
+{
+        struct device *dev = anx7688->dev;
+	bool vbus_on, vconn_on, dr_ufp;
+	int status, cc_status, ret;
+	int cc1, cc2;
+
+	status = anx7688_reg_read(anx7688, ANX7688_REG_STATUS);
+	cc_status = anx7688_reg_read(anx7688, ANX7688_REG_CC_STATUS);
+
+	dev_dbg(dev, "Update status (0x%02x)\n", status);
+	dev_dbg(dev, "  CC1 = %s CC2 = %s\n",
+		anx7688_cc_status_string(cc_status & 0xf),
+		anx7688_cc_status_string((cc_status >> 4) & 0xf));
+
+	vbus_on = !!(status & ANX7688_VBUS_STATUS);
+	vconn_on = !!(status & ANX7688_VCONN_STATUS);
+	dr_ufp = !(status & ANX7688_DATA_ROLE_STATUS);
+
+	cc1 = anx7688_cc_status(cc_status & 0xf);
+	cc2 = anx7688_cc_status((cc_status >> 4) & 0xf);
+	if (cc1 >= 0)
+		typec_set_pwr_opmode(anx7688->port, cc1);
+	else if (cc2 >= 0)
+		typec_set_pwr_opmode(anx7688->port, cc2);
+
+	if (anx7688->vbus_on != vbus_on) {
+		if (vbus_on) {
+			ret = regulator_enable(anx7688->supplies[ANX7688_VBUS_INDEX].consumer);
+			if (ret) {
+				dev_err(anx7688->dev, "failed to enable vbus\n");
+				return ret;
+			}
+		} else {
+			ret = regulator_disable(anx7688->supplies[ANX7688_VBUS_INDEX].consumer);
+			if (ret) {
+				dev_err(anx7688->dev, "failed to disable vbus\n");
+				return ret;
+			}
+		}
+
+		typec_set_pwr_role(anx7688->port, vbus_on ? TYPEC_SOURCE : TYPEC_SINK);
+		anx7688->vbus_on = vbus_on;
+	}
+
+	if (anx7688->vconn_on != vconn_on) {
+		if (vbus_on) {
+			ret = regulator_enable(anx7688->supplies[ANX7688_VCONN_INDEX].consumer);
+			if (ret) {
+				dev_err(anx7688->dev, "failed to enable vconn\n");
+				return ret;
+			}
+		} else {
+			ret = regulator_disable(anx7688->supplies[ANX7688_VCONN_INDEX].consumer);
+			if (ret) {
+				dev_err(anx7688->dev, "failed to disable vconn\n");
+				return ret;
+			}
+		}
+
+		typec_set_vconn_role(anx7688->port, vconn_on ? TYPEC_SOURCE : TYPEC_SINK);
+		anx7688->vconn_on = vconn_on;
+	}
+
+	dev_dbg(anx7688->dev, "data role = %s\n", dr_ufp ? "ufp" : "dfp");
+
+	typec_set_data_role(anx7688->port, dr_ufp ? TYPEC_DEVICE : TYPEC_HOST);
+
+	ret = usb_role_switch_set_role(anx7688->role_sw,
+				       dr_ufp ? USB_ROLE_DEVICE : USB_ROLE_HOST);
+	if (ret)
+		return ret;
+
+	return 0;
 }
 
 static irqreturn_t anx7688_irq_status_handler(int irq, void *data)
 {
-	struct i2c_client *client = to_i2c_client(data);
-	struct anx7688 *anx7688 = i2c_get_clientdata(client);
-	int source0;
-	int source1;
-	int source2;
+#if DISABLE_OCM
+        struct anx7688 *anx7688 = data;
+        struct device *dev = anx7688->dev;
+        int ext2_status;
+
+        mutex_lock(&anx7688->lock);
+
+        if (!test_bit(ANX7688_F_CONNECTED, anx7688->flags)) {
+                /*
+		 * The chip should be disabled and powered off, nothing
+                 * more to do.
+		 */
+                dev_dbg(dev, "spurious status irq\n");
+                goto out_unlock;
+        }
+
+        dev_dbg(dev, "status irq\n");
+
+        ext2_status = anx7688_reg_read(anx7688, ANX7688_REG_IRQ_EXT_SOURCE2);
+	dev_dbg(dev, "  ext2 = 0x%02x\n", ext2_status);
+	anx7688_reg_write(anx7688, ANX7688_REG_IRQ_EXT_SOURCE2, ext2_status);
+
+out_unlock:
+        mutex_unlock(&anx7688->lock);
+
+        return IRQ_HANDLED;
+#else
+        struct anx7688 *anx7688 = data;
+        struct device *dev = anx7688->dev;
+        int tcpc_status, ext2_status, soft_status;
 
-	dev_printk(KERN_INFO, anx7688->dev, "status interrupt received\n");
-	source0 = anx7688_reg_read(anx7688, ANX7688_REG_IRQ_SOURCE_0);
-	source1 = anx7688_reg_read(anx7688, ANX7688_REG_IRQ_SOURCE_1);
-	source2 = anx7688_reg_read(anx7688, ANX7688_REG_IRQ_SOURCE_2);
-	dev_printk(KERN_INFO, anx7688->dev, "source is %d %d %d\n", source0, source1, source2);
+        mutex_lock(&anx7688->lock);
 
-	// Clear IRQ bits
-	anx7688_reg_write(anx7688, ANX7688_REG_IRQ_SOURCE_0, 0);
-	anx7688_reg_write(anx7688, ANX7688_REG_IRQ_SOURCE_1, 0);
-	anx7688_reg_write(anx7688, ANX7688_REG_IRQ_SOURCE_2, 0);
+        if (!test_bit(ANX7688_F_CONNECTED, anx7688->flags)) {
+                dev_dbg(dev, "spurious status irq\n");
+                /* anx chip should be disabled and power off, nothing
+                 * more to do */
+                goto out_unlock;
+        }
 
-	return IRQ_HANDLED;
+        dev_dbg(dev, "status irq\n");
+
+        // clear tcpc interrupt
+        tcpc_status = anx7688_tcpc_reg_read(anx7688, ANX7688_TCPC_REG_ALERT0);
+        if (tcpc_status > 0) {
+                dev_dbg(dev, "  tcpc = 0x%02x\n", tcpc_status);
+                anx7688_tcpc_reg_write(anx7688, ANX7688_TCPC_REG_ALERT0, tcpc_status);
+        }
+
+        ext2_status = anx7688_reg_read(anx7688, ANX7688_REG_IRQ_EXT_SOURCE2);
+        if (ext2_status & ANX7688_IRQ2_SOFT_INT) {
+                soft_status = anx7688_reg_read(anx7688, ANX7688_REG_STATUS_INT);
+                anx7688_reg_write(anx7688, ANX7688_REG_STATUS_INT, 0);
+
+		dev_dbg(dev, "  ext2 = 0x%02x\n", ext2_status);
+                dev_dbg(dev, "  soft = 0x%02x\n", soft_status);
+
+		if (soft_status > 0) {
+			soft_status &= ANX7688_SOFT_INT_MASK;
+
+			if (soft_status & ANX7688_IRQS_RECEIVED_MSG) {
+				dev_dbg(dev, "  pd msg rcv\n");
+				anx7688_receive_msg(anx7688);
+			}
+
+			if (soft_status & (ANX7688_IRQS_CC_STATUS_CHANGE |
+					   ANX7688_IRQS_VBUS_CHANGE |
+					   ANX7688_IRQS_VCONN_CHANGE |
+					   ANX7688_IRQS_DATA_ROLE_CHANGE)) {
+				anx7688_update_status(anx7688);
+			}
+		}
+
+                anx7688_reg_write(anx7688, ANX7688_REG_IRQ_EXT_SOURCE2, ANX7688_IRQ2_SOFT_INT);
+        }
+
+out_unlock:
+        mutex_unlock(&anx7688->lock);
+
+        return IRQ_HANDLED;
+#endif
 }
 
 static int anx7688_dr_set(struct typec_port *port, enum typec_data_role role)
 {
-	printk(KERN_WARNING "data role set\n");
-	return 0;
+        struct anx7688 *anx7688 = typec_get_drvdata(port);
+
+        dev_info(anx7688->dev, "data role set %d\n", role);
+
+        return -ENOTSUPP;
 }
 
 static int anx7688_pr_set(struct typec_port *port, enum typec_role role)
 {
-	printk(KERN_WARNING "power role set\n");
-	return 0;
+        struct anx7688 *anx7688 = typec_get_drvdata(port);
+
+        dev_info(anx7688->dev, "power role set %d\n", role);
+
+        return -ENOTSUPP;
+}
+
+/*
+ * Calls to the eerpom functions need to be taken under the anx7688 lock.
+ */
+
+static int anx7688_eeprom_set_address(struct anx7688 *anx7688, u16 addr)
+{
+        int ret;
+
+        ret = anx7688_reg_write(anx7688, 0xe0, (addr >> 8) & 0xff);
+        if (ret < 0)
+                return ret;
+
+        return anx7688_reg_write(anx7688, 0xe1, addr & 0xff);
+}
+
+static int anx7688_eeprom_wait_done(struct anx7688 *anx7688)
+{
+        ktime_t timeout;
+        int ret;
+
+        // wait for read to be done
+        timeout = ktime_add_us(ktime_get(), 10000);
+        while (true) {
+                ret = anx7688_reg_read(anx7688, 0xe2);
+                if (ret < 0)
+                        return ret;
+
+                if (ret & BIT(3))
+                        return 0;
+
+                if (ktime_after(ktime_get(), timeout)) {
+                        dev_err(anx7688->dev, "timeout waiting for eeprom\n");
+                        return -ETIMEDOUT;
+                }
+        }
+}
+
+/* wait for internal FSM of EEPROM to be in a state ready for
+ * programming/reading
+ */
+static int anx7688_eeprom_wait_ready(struct anx7688 *anx7688)
+{
+        ktime_t timeout;
+        int ret;
+
+        // wait until eeprom is ready
+        timeout = ktime_add_us(ktime_get(), 1000000);
+        while (true) {
+                ret = anx7688_reg_read(anx7688, 0x7f);
+                if (ret < 0)
+                        return ret;
+
+                if ((ret & 0x0f) == 7)
+                        return 0;
+
+                if (ktime_after(ktime_get(), timeout)) {
+                        dev_err(anx7688->dev, "timeout waiting for eeprom to initialize\n");
+                        return -ETIMEDOUT;
+                }
+
+                msleep(5);
+        }
+}
+
+static int anx7688_eeprom_read(struct anx7688 *anx7688, unsigned addr, u8 buf[16])
+{
+        int ret;
+
+        ret = anx7688_eeprom_set_address(anx7688, addr);
+        if (ret)
+                return ret;
+
+        // initiate read
+        ret = anx7688_reg_write(anx7688, 0xe2, 0x06);
+        if (ret < 0)
+                return ret;
+
+        ret = anx7688_eeprom_wait_done(anx7688);
+        if (ret)
+                return ret;
+
+        ret = i2c_smbus_read_i2c_block_data(anx7688->client, 0xd0, 16, buf);
+        if (ret < 0) {
+                dev_err(anx7688->dev,
+                        "failed to read eeprom data (err=%d)\n", ret);
+                return ret;
+        }
+
+        return 0;
+}
+
+static int anx7688_eeprom_write(struct anx7688 *anx7688, unsigned addr,
+                                const u8 buf[16])
+{
+        int ret;
+
+        ret = anx7688_eeprom_set_address(anx7688, addr);
+        if (ret)
+                return ret;
+
+        ret = i2c_smbus_write_i2c_block_data(anx7688->client, 0xd0, 16, buf);
+        if (ret < 0) {
+                dev_err(anx7688->dev,
+                        "failed to write eeprom data (err=%d)\n", ret);
+                return ret;
+        }
+
+        dev_info(anx7688->dev, "eeprom wr %x %*ph\n", addr, 16, buf);
+
+        // initiate write
+        ret = anx7688_reg_write(anx7688, 0xe2, 0x01);
+        if (ret < 0)
+                return ret;
+
+        ret = anx7688_eeprom_wait_done(anx7688);
+        if (ret)
+                return ret;
+
+        return 0;
+}
+
+/*
+ * The firmware is flashed as is from address 0x10 up to 0xffff.
+ */
+static int anx7688_flash_firmware(struct anx7688 *anx7688)
+{
+        const char* fw_name = "anx7688-fw.bin";
+        const struct firmware *fw;
+        unsigned addr;
+        u8 buf[16];
+        int ret;
+
+        ret = request_firmware(&fw, fw_name, anx7688->dev);
+        if (ret < 0)
+                return ret;
+
+        if (fw->size > 0x10000 - 16) {
+                dev_err(anx7688->dev, "Firmware is too big %s\n", fw_name);
+                ret = -E2BIG;
+                goto err_release;
+        }
+
+        mutex_lock(&anx7688->lock);
+
+	/*
+	 * Cabledet changes will not be processed, since we're holding the
+	 * lock, so the firmware flashing is safe from interruptions.
+	 */
+
+	if (test_bit(ANX7688_F_CONNECTED, anx7688->flags))
+                anx7688_disconnect(anx7688);
+
+	msleep(20);
+
+	anx7688_power_enable(anx7688);
+
+        // reset OCM
+        ret = anx7688_reg_update_bits(anx7688, ANX7688_REG_USBC_RESET_CTRL,
+                                      ANX7688_USBC_RESET_CTRL_OCM_RESET,
+                                      ANX7688_USBC_RESET_CTRL_OCM_RESET);
+        if (ret < 0)
+                goto err_unlock;
+
+        ret = anx7688_eeprom_wait_ready(anx7688);
+        if (ret)
+                goto err_unlock;
+
+        msleep(10);
+
+        ret = anx7688_reg_update_bits(anx7688, 0x3f, BIT(5), BIT(5));
+        if (ret < 0)
+                goto err_unlock;
+
+        ret = anx7688_reg_update_bits(anx7688, 0x44,
+                                      BIT(0) | BIT(7),
+                                      BIT(0) | BIT(7));
+        if (ret < 0)
+                goto err_unlock;
+
+        ret = anx7688_reg_update_bits(anx7688, 0x66, BIT(3), BIT(3));
+        if (ret < 0)
+                goto err_unlock;
+
+        for (addr = 0; addr < fw->size; addr += sizeof buf) {
+                memset(buf, 0, sizeof buf);
+                memcpy(buf, fw->data + addr, min_t(unsigned, fw->size - addr, sizeof buf));
+
+                ret = anx7688_eeprom_write(anx7688, addr + 0x10, buf);
+                if (ret < 0)
+                        goto err_unlock;
+        }
+
+err_unlock:
+	anx7688_power_disable(anx7688);
+	schedule_delayed_work(&anx7688->work, msecs_to_jiffies(20));
+        mutex_unlock(&anx7688->lock);
+
+err_release:
+        release_firmware(fw);
+        return ret;
 }
 
 static const struct typec_operations anx7688_typec_ops = {
-	.dr_set = anx7688_dr_set,
-	.pr_set = anx7688_pr_set,
+        .dr_set = anx7688_dr_set,
+        .pr_set = anx7688_pr_set,
 };
 
-static int anx7688_i2c_probe(struct i2c_client *client,
-			     const struct i2c_device_id *id)
-{
-	struct anx7688 *anx7688;
-	struct device *dev = &client->dev;
-	struct typec_capability typec_cap = { };
-	int typec_revision;
-	int vid;
-	int ret = 0;
-	
-	anx7688 = devm_kzalloc(&client->dev, sizeof(struct anx7688), GFP_KERNEL);
-	if (!anx7688)
-		return -ENOMEM;
-
-	i2c_set_clientdata(client, anx7688);
-	anx7688->client = client;
-	anx7688->dev = &client->dev;
-
-	// Register the TCPC i2c interface as second interface (0x58)
-	anx7688->client_tcpc = i2c_new_dummy_device(client->adapter, 0x2c);
-
-	dev_printk(KERN_INFO, dev, "=== ANX7688 i2c probe ===\n");
-
-	anx7688->gpio_poweron = devm_gpiod_get(&client->dev, "enable", GPIOD_OUT_LOW);
-	if(IS_ERR(anx7688->gpio_poweron)) {
-		dev_printk(KERN_ERR, dev, "Could not get poweron gpio\n");
-		return PTR_ERR(anx7688->gpio_poweron);
-	}
-	anx7688->gpio_reset = devm_gpiod_get(&client->dev, "reset", GPIOD_OUT_LOW);
-	if(IS_ERR(anx7688->gpio_reset)) {
-		dev_printk(KERN_ERR, dev, "Could not get reset gpio\n");
-		return PTR_ERR(anx7688->gpio_reset);
-	}
-	anx7688->gpio_cabledet = devm_gpiod_get(&client->dev, "cabledet", GPIOD_IN);
-	if(IS_ERR(anx7688->gpio_cabledet)) {
-		dev_printk(KERN_ERR, dev, "Could not get cabledet gpio\n");
-		return PTR_ERR(anx7688->gpio_cabledet);
+static ssize_t flash_eeprom_show(struct device *dev,
+                           struct device_attribute *attr, char *buf)
+{
+        return scnprintf(buf, PAGE_SIZE, "Write 1 to this file to initiate firmware flashing. Consult dmesg for results.\n");
+}
+
+static ssize_t flash_eeprom_store(struct device *dev,
+                            struct device_attribute *attr,
+                            const char *buf, size_t len)
+{
+        struct anx7688 *anx7688 = i2c_get_clientdata(to_i2c_client(dev));
+        unsigned val;
+        int ret;
+
+        ret = kstrtouint(buf, 0, &val);
+        if (ret)
+                return ret;
+
+        if (val == 1) {
+                ret = anx7688_flash_firmware(anx7688);
+                if (ret)
+                        return ret;
+        }
+
+        return len;
+}
+static DEVICE_ATTR_RW(flash_eeprom);
+
+static ssize_t reg_update_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+        struct anx7688 *anx7688 = i2c_get_clientdata(to_i2c_client(dev));
+        unsigned val, addr, devaddr, data;
+        int ret;
+
+        ret = kstrtouint(buf, 16, &val);
+        if (ret)
+                return ret;
+
+	data = val & 0xff;
+	addr = (val >> 8) & 0xff;
+	devaddr = (val >> 16) & 0xff;
+
+	mutex_lock(&anx7688->lock);
+
+	if (!test_bit(ANX7688_F_POWERED, anx7688->flags)) {
+		ret = -ENODEV;
+		goto out_unlock;
 	}
 
+	if (devaddr == 0x50)
+		ret = anx7688_reg_write(anx7688, addr, val);
+	else if (devaddr == 0x58)
+		ret = anx7688_tcpc_reg_write(anx7688, addr, val);
+	else
+		ret = -EINVAL;
+
+out_unlock:
+	mutex_unlock(&anx7688->lock);
+
+        return ret ? ret : len;
+}
+static DEVICE_ATTR_WO(reg_update);
+
+static ssize_t hwreset_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+        struct anx7688 *anx7688 = i2c_get_clientdata(to_i2c_client(dev));
+
+	mutex_lock(&anx7688->lock);
+
+	if (test_bit(ANX7688_F_CONNECTED, anx7688->flags))
+                anx7688_disconnect(anx7688);
+
+	schedule_delayed_work(&anx7688->work, msecs_to_jiffies(20));
+	mutex_unlock(&anx7688->lock);
+
+        return len;
+}
+static DEVICE_ATTR_WO(hwreset);
+
+static struct attribute *anx7688_attrs[] = {
+        &dev_attr_flash_eeprom.attr,
+        &dev_attr_reg_update.attr,
+        &dev_attr_hwreset.attr,
+        NULL,
+};
+
+ATTRIBUTE_GROUPS(anx7688);
+
+/*
+ * This function has to work when the ANX7688 is active, and when
+ * it is powered down. It power cycles the chip and asserts the OCM
+ * reset, to prevent OCM FW interfering with EEPROM reading.
+ *
+ * After reading EEPROM, the reconnection is scheduled.
+ */
+static int anx7688_firmware_show(struct seq_file *s, void *data)
+{
+        struct anx7688 *anx7688 = s->private;
+        unsigned addr;
+        u8 buf[16];
+        int ret;
+
+        mutex_lock(&anx7688->lock);
+
+	if (test_bit(ANX7688_F_CONNECTED, anx7688->flags))
+		anx7688_disconnect(anx7688);
+
+	msleep(20);
+
 	anx7688_power_enable(anx7688);
-	vid = anx7688_tcpc_reg_read(anx7688, ANX7688_TCPC_REG_VENDOR_ID_0);
-	vid |= anx7688_tcpc_reg_read(anx7688, ANX7688_TCPC_REG_VENDOR_ID_1) << 8;
-	dev_printk(KERN_INFO, dev, "Chip vendor id is 0x%x\n", vid);
-	typec_revision = anx7688_reg_read(anx7688, 0x06);
+
+	ret = anx7688_reg_update_bits(anx7688, ANX7688_REG_USBC_RESET_CTRL,
+				      ANX7688_USBC_RESET_CTRL_OCM_RESET,
+				      ANX7688_USBC_RESET_CTRL_OCM_RESET);
+	if (ret < 0)
+		goto out_powerdown;
+
+        ret = anx7688_eeprom_wait_ready(anx7688);
+        if (ret)
+                goto out_powerdown;
+
+	msleep(10);
+
+        for (addr = 0x10; addr < 0x10000; addr += 16) {
+                // set address
+                ret = anx7688_eeprom_read(anx7688, addr, buf);
+                if (ret < 0)
+                        goto out_powerdown;
+
+                seq_write(s, buf, sizeof buf);
+        }
+
+out_powerdown:
 	anx7688_power_disable(anx7688);
+        schedule_delayed_work(&anx7688->work, 0);
+        mutex_unlock(&anx7688->lock);
 
-	typec_cap.revision = USB_TYPEC_REV_1_2;
-	typec_cap.pd_revision = 0x200;
-	typec_cap.prefer_role = TYPEC_NO_PREFERRED_ROLE;
-	typec_cap.ops = &anx7688_typec_ops;
-	typec_cap.type = TYPEC_PORT_DRP;
-	typec_cap.data = TYPEC_PORT_DRD;
-	
-	anx7688->port = typec_register_port(&client->dev, &typec_cap);
-	if (IS_ERR(anx7688->port)) {
-		dev_err(dev, "Could not register type-c port\n");
-		return PTR_ERR(anx7688->port);
-	}
+        return ret;
+}
+DEFINE_SHOW_ATTRIBUTE(anx7688_firmware);
 
-	anx7688->irq_plug = of_irq_get(dev->of_node, 0);
-	anx7688->irq_status = of_irq_get(dev->of_node, 1);
+static int anx7688_regs_show(struct seq_file *s, void *data)
+{
+        struct anx7688 *anx7688 = s->private;
+        u8 buf[16];
+        unsigned i, addr;
+        int ret = -ENODEV;
 
-	ret = devm_request_threaded_irq(&client->dev, anx7688->irq_plug, NULL, anx7688_irq_plug_handler, IRQF_ONESHOT, "anx7688plug", &client->dev);
-	if (ret < 0) {
-		dev_err(dev, "Could not register cable detection irq: %d\n", ret);
-		goto error;
-	}
-	ret = devm_request_threaded_irq(&client->dev, anx7688->irq_status, NULL, anx7688_irq_status_handler, IRQF_ONESHOT, "anx7688status", &client->dev);
-	if (ret < 0) {
-		dev_err(dev, "Could not register status update irq: %d\n", ret);
-		goto error;
+        mutex_lock(&anx7688->lock);
+
+	if (!test_bit(ANX7688_F_POWERED, anx7688->flags))
+		goto out_unlock;
+
+        for (addr = 0; addr < 256; addr += 16) {
+                ret = i2c_smbus_read_i2c_block_data(anx7688->client, addr,
+                                                    sizeof buf, buf);
+                if (ret < 0) {
+                        dev_err(anx7688->dev,
+                                "failed to read registers (err=%d)\n", ret);
+                        goto out_unlock;
+                }
+
+                for (i = 0; i < 16; i++)
+                        seq_printf(s, "50%02x: %02x\n", addr + i, buf[i]);
+        }
+
+        for (addr = 0; addr < 256; addr += 16) {
+                ret = i2c_smbus_read_i2c_block_data(anx7688->client_tcpc, addr,
+                                                    sizeof buf, buf);
+                if (ret < 0) {
+                        dev_err(anx7688->dev,
+                                "failed to read registers (err=%d)\n", ret);
+                        goto out_unlock;
+                }
+
+                for (i = 0; i < 16; i++)
+                        seq_printf(s, "58%02x: %02x\n", addr + i, buf[i]);
+        }
+
+out_unlock:
+        mutex_unlock(&anx7688->lock);
+
+        return ret;
+}
+DEFINE_SHOW_ATTRIBUTE(anx7688_regs);
+
+static int anx7688_status_show(struct seq_file *s, void *data)
+{
+        struct anx7688 *anx7688 = s->private;
+        //int ret;
+
+        mutex_lock(&anx7688->lock);
+
+	seq_printf(s, "not much\n");
+
+        mutex_unlock(&anx7688->lock);
+
+        return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(anx7688_status);
+
+static int anx7688_i2c_probe(struct i2c_client *client,
+                             const struct i2c_device_id *id)
+{
+        struct anx7688 *anx7688;
+        struct device *dev = &client->dev;
+        struct typec_capability typec_cap = { };
+        int i, vid_h, vid_l;
+        int irq_cabledet;
+        int ret = 0;
+
+        anx7688 = devm_kzalloc(dev, sizeof(*anx7688), GFP_KERNEL);
+        if (!anx7688)
+                return -ENOMEM;
+
+        i2c_set_clientdata(client, anx7688);
+        anx7688->client = client;
+        anx7688->dev = &client->dev;
+        mutex_init(&anx7688->lock);
+        INIT_DELAYED_WORK(&anx7688->work, anx7688_work);
+
+        for (i = 0; i < ANX7688_NUM_SUPPLIES; i++)
+                anx7688->supplies[i].supply = anx7688_supply_names[i];
+        ret = devm_regulator_bulk_get(dev, ANX7688_NUM_SUPPLIES,
+                                      anx7688->supplies);
+        if (ret)
+                return ret;
+
+        anx7688->gpio_enable = devm_gpiod_get(dev, "enable", GPIOD_OUT_LOW);
+        if (IS_ERR(anx7688->gpio_enable)) {
+                dev_err(dev, "Could not get enable gpio\n");
+                return PTR_ERR(anx7688->gpio_enable);
+        }
+
+        anx7688->gpio_reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+        if (IS_ERR(anx7688->gpio_reset)) {
+                dev_err(dev, "Could not get reset gpio\n");
+                return PTR_ERR(anx7688->gpio_reset);
+        }
+
+        anx7688->gpio_cabledet = devm_gpiod_get(dev, "cabledet", GPIOD_IN);
+        if (IS_ERR(anx7688->gpio_cabledet)) {
+                dev_err(dev, "Could not get cabledet gpio\n");
+                return PTR_ERR(anx7688->gpio_cabledet);
+        }
+
+        irq_cabledet = gpiod_to_irq(anx7688->gpio_cabledet);
+        if (irq_cabledet < 0) {
+                dev_err(dev, "Could not get cabledet irq\n");
+                return irq_cabledet;
+        }
+
+        ret = devm_device_add_groups(&client->dev, anx7688_groups);
+        if (ret)
+                return ret;
+
+        // Register the TCPC i2c interface as second interface (0x58)
+        anx7688->client_tcpc = i2c_new_dummy_device(client->adapter, 0x2c);
+        if (IS_ERR(anx7688->client_tcpc)) {
+                dev_err(dev, "Could not register tcpc i2c client\n");
+                return PTR_ERR(anx7688->client_tcpc);
+        }
+        i2c_set_clientdata(anx7688->client_tcpc, anx7688);
+
+        // powerup and probe the ANX chip
+
+        ret = regulator_bulk_enable(ANX7688_NUM_ALWAYS_ON_SUPPLIES,
+                                    anx7688->supplies);
+        if (ret) {
+                dev_err(dev, "Could not enable regulators\n");
+                goto err_dummy_dev;
+        }
+
+        msleep(10);
+
+        anx7688_power_enable(anx7688);
+
+        vid_l = anx7688_tcpc_reg_read(anx7688, ANX7688_TCPC_REG_VENDOR_ID0);
+        vid_h = anx7688_tcpc_reg_read(anx7688, ANX7688_TCPC_REG_VENDOR_ID1);
+	if (vid_l < 0 || vid_h < 0) {
+		anx7688_power_disable(anx7688);
+		goto err_disable_reg;
 	}
 
-error:
-	if (ret) {
-		typec_unregister_port(anx7688->port);
+        dev_info(dev, "Vendor id 0x%04x\n", vid_l | vid_h << 8);
+
+        anx7688_power_disable(anx7688);
+
+	anx7688->role_sw = usb_role_switch_get(dev);
+	if (IS_ERR(anx7688->role_sw)) {
+                dev_err(dev, "Could not get role switch\n");
+		ret = PTR_ERR(anx7688->role_sw);
+		goto err_disable_reg;
 	}
 
-	return ret;
+	// setup a typec port device
+        typec_cap.revision = USB_TYPEC_REV_1_2;
+        typec_cap.pd_revision = 0x200;
+        typec_cap.prefer_role = TYPEC_NO_PREFERRED_ROLE;
+        typec_cap.type = TYPEC_PORT_DRP;
+        typec_cap.data = TYPEC_PORT_DRD;
+        typec_cap.driver_data = anx7688;
+        typec_cap.ops = &anx7688_typec_ops;
+
+        anx7688->port = typec_register_port(dev, &typec_cap);
+        if (IS_ERR(anx7688->port)) {
+                dev_err(dev, "Could not register type-c port\n");
+                ret = PTR_ERR(anx7688->port);
+                goto err_role_sw;
+        }
+
+        ret = devm_request_irq(dev, irq_cabledet, anx7688_irq_plug_handler,
+                               IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+                               "anx7688-cabledet", anx7688);
+        if (ret < 0) {
+                dev_err(dev, "Could not request cabledet irq (%d)\n", ret);
+                goto err_cport;
+        }
+
+        ret = devm_request_threaded_irq(dev, client->irq,
+                                        NULL, anx7688_irq_status_handler,
+                                        IRQF_ONESHOT, NULL, anx7688);
+        if (ret < 0) {
+                dev_err(dev, "Could not request irq (%d)\n", ret);
+                goto err_cport;
+        }
+
+        anx7688->debug_root = debugfs_create_dir("anx7688", NULL);
+        debugfs_create_file("firmware", 0444, anx7688->debug_root, anx7688,
+                            &anx7688_firmware_fops);
+        debugfs_create_file("regs", 0444, anx7688->debug_root, anx7688,
+                            &anx7688_regs_fops);
+        debugfs_create_file("status", 0444, anx7688->debug_root, anx7688,
+                            &anx7688_status_fops);
+
+        schedule_delayed_work(&anx7688->work, msecs_to_jiffies(10));
+
+        return 0;
+
+err_cport:
+        typec_unregister_port(anx7688->port);
+err_role_sw:
+	usb_role_switch_put(anx7688->role_sw);
+err_disable_reg:
+        regulator_bulk_disable(ANX7688_NUM_ALWAYS_ON_SUPPLIES, anx7688->supplies);
+err_dummy_dev:
+        i2c_unregister_device(anx7688->client_tcpc);
+        return ret;
 }
 
 static int anx7688_i2c_remove(struct i2c_client *client)
 {
-	struct anx7688 *anx7688;
-	printk(KERN_INFO "ANX7688 i2c remove\n");
-	anx7688 = i2c_get_clientdata(client);
+        struct anx7688 *anx7688 = i2c_get_clientdata(client);
 
+        cancel_delayed_work_sync(&anx7688->work);
 
-	anx7688_power_disable(anx7688);
-	devm_free_irq(anx7688->dev, anx7688->irq_plug, anx7688->dev);
-	devm_free_irq(anx7688->dev, anx7688->irq_status, anx7688->dev);
-	i2c_unregister_device(anx7688->client_tcpc);
-	return 0;
+	typec_unregister_partner(anx7688->partner);
+        typec_unregister_port(anx7688->port);
+	usb_role_switch_put(anx7688->role_sw);
+
+	if (anx7688->vbus_on)
+		regulator_disable(anx7688->supplies[ANX7688_VBUS_INDEX].consumer);
+	if (anx7688->vconn_on)
+		regulator_disable(anx7688->supplies[ANX7688_VCONN_INDEX].consumer);
+
+        anx7688_power_disable(anx7688);
+
+        regulator_bulk_disable(ANX7688_NUM_ALWAYS_ON_SUPPLIES, anx7688->supplies);
+        i2c_unregister_device(anx7688->client_tcpc);
+
+        debugfs_remove(anx7688->debug_root);
+
+        return 0;
 }
 
-static const struct i2c_device_id anx7688_id[] = {
-	{"anx7688", 0},
-	{}
+static const struct i2c_device_id anx7688_ids[] = {
+        { "anx7688", 0 },
+        { }
 };
-
-MODULE_DEVICE_TABLE(i2c, anx7688_id);
+MODULE_DEVICE_TABLE(i2c, anx7688_ids);
 
 #ifdef CONFIG_OF
-static struct of_device_id anx_match_table[] = {
-	{.compatible = "analogix,anx7688",},
-	{},
+static struct of_device_id anx7688_of_match_table[] = {
+        { .compatible = "analogix,anx7688" },
+        { },
 };
+MODULE_DEVICE_TABLE(of, anx7688_of_match_table);
 #endif
 
 static struct i2c_driver anx7688_driver = {
-	.driver = {
-		.name = "anx7688",
+        .driver = {
+                .name = "anx7688",
 #ifdef CONFIG_OF
-		.of_match_table = anx_match_table,
+                .of_match_table = anx7688_of_match_table,
 #endif
-	},
-	.probe = anx7688_i2c_probe,
-	.remove = anx7688_i2c_remove,
-	.id_table = anx7688_id,
+        },
+        .probe = anx7688_i2c_probe,
+        .remove = anx7688_i2c_remove,
+        .id_table = anx7688_ids,
 };
 
 module_i2c_driver(anx7688_driver);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Martijn Braam <martijn@brixit.nl>");
+MODULE_AUTHOR("Ondrej Jirman <megous@megous.com>");
 MODULE_DESCRIPTION("Analogix ANX7688 USB-C DisplayPort bridge");
-MODULE_VERSION("0.01");
-
-- 
2.26.2

