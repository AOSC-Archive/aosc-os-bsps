From 0b430cc34fee3b37386352851d744b29a7124cbd Mon Sep 17 00:00:00 2001
From: Ondrej Jirman <megous@megous.com>
Date: Wed, 10 Jun 2020 12:52:22 +0200
Subject: [PATCH 88/92] usb: typec: anx7688: Check status and cabledet also
 periodically

Just to be sure check the cabledet and status outside of interrupt
from a watchdog.

Signed-off-by: Ondrej Jirman <megous@megous.com>
---
 drivers/usb/typec/anx7688.c | 45 +++++++++++++++++++++++++++++++------
 1 file changed, 38 insertions(+), 7 deletions(-)

diff --git a/drivers/usb/typec/anx7688.c b/drivers/usb/typec/anx7688.c
index 200e33a0b6b5d..7efce6e31e1a3 100644
--- a/drivers/usb/typec/anx7688.c
+++ b/drivers/usb/typec/anx7688.c
@@ -178,6 +178,8 @@ struct anx7688 {
 	unsigned long flags[1];
 
         struct delayed_work work;
+	struct timer_list work_timer;
+
         struct mutex lock;
         bool vbus_on, vconn_on;
 
@@ -554,13 +556,6 @@ static void anx7688_handle_cable_change(struct anx7688* anx7688)
         mutex_unlock(&anx7688->lock);
 }
 
-static void anx7688_work(struct work_struct *work)
-{
-        struct anx7688 *anx7688 = container_of(work, struct anx7688, work.work);
-
-        anx7688_handle_cable_change(anx7688);
-}
-
 static irqreturn_t anx7688_irq_plug_handler(int irq, void *data)
 {
         struct anx7688 *anx7688 = data;
@@ -650,7 +645,12 @@ static int anx7688_update_status(struct anx7688 *anx7688)
 	int cc1, cc2;
 
 	status = anx7688_reg_read(anx7688, ANX7688_REG_STATUS);
+	if (status < 0)
+		return status;
+
 	cc_status = anx7688_reg_read(anx7688, ANX7688_REG_CC_STATUS);
+	if (cc_status < 0)
+		return cc_status;
 
 	dev_dbg(dev, "Update status (0x%02x)\n", status);
 	dev_dbg(dev, "  CC1 = %s CC2 = %s\n",
@@ -1233,6 +1233,33 @@ static int anx7688_status_show(struct seq_file *s, void *data)
 }
 DEFINE_SHOW_ATTRIBUTE(anx7688_status);
 
+static void anx7688_work(struct work_struct *work)
+{
+        struct anx7688 *anx7688 = container_of(work, struct anx7688, work.work);
+
+        anx7688_handle_cable_change(anx7688);
+
+	if (test_bit(ANX7688_F_CONNECTED, anx7688->flags)) {
+		/* 
+		 * We check status periodically outside of interrupt, just to
+		 * be sure we didn't miss any status interrupts
+		 */
+		mutex_lock(&anx7688->lock);
+		anx7688_update_status(anx7688);
+		mutex_unlock(&anx7688->lock);
+	}
+}
+
+static void anx7688_cabledet_timer_fn(struct timer_list *t)
+{
+	struct anx7688 *anx7688 = from_timer(anx7688, t, work_timer);
+
+	dev_dbg(anx7688->dev, "wd timer\n");
+
+	schedule_delayed_work(&anx7688->work, 0);
+	mod_timer(t, jiffies + msecs_to_jiffies(1000));
+}
+
 static int anx7688_i2c_probe(struct i2c_client *client,
                              const struct i2c_device_id *id)
 {
@@ -1369,6 +1396,9 @@ static int anx7688_i2c_probe(struct i2c_client *client,
 
         schedule_delayed_work(&anx7688->work, msecs_to_jiffies(10));
 
+	timer_setup(&anx7688->work_timer, anx7688_cabledet_timer_fn, 0);
+	mod_timer(&anx7688->work_timer, jiffies + msecs_to_jiffies(1000));
+
         return 0;
 
 err_cport:
@@ -1386,6 +1416,7 @@ static int anx7688_i2c_remove(struct i2c_client *client)
 {
         struct anx7688 *anx7688 = i2c_get_clientdata(client);
 
+	del_timer_sync(&anx7688->work_timer);
         cancel_delayed_work_sync(&anx7688->work);
 
 	typec_unregister_partner(anx7688->partner);
-- 
2.26.2

